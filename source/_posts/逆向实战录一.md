---
title: 逆向实战录一
comments: true
toc: true
copyright: true
declare: true
categories:
  - iOS
  - 逆向
tags:
  - 逆向
date: 2019-04-10 01:33:45
top:
---

本篇记录一下在 Mac 上逆向 MWeb 付费 APP 的过程。仅与读者探讨技术，请勿将逆向后的 APP 商用。请支持正版！
<!--more-->
### 工具准备
* Xcode: 附加进程动态调试，UI 调试
* restore-symbol: [符号表恢复](https://github.com/tobefuturer/restore-symbol)
* Hopper Disassembler 或 IDA: 静态调试，Hopper 在 Mac 上方便点，另外 Hopper 会对伪代码自行优化，可能忽略一些代码。推荐 Windows IDA，伪代码更详细。

### 恢复符号表
* 我们下载的 APP 一般都是删除符号表的，这样不仅增加一点逆向成本，APP 体积也更小。而且逆向总要去 hook 方法。

	```shell restore-symbol路径
	./restore-symbol /Applications/MWeb.app/Contents/MacOS/MWeb -o MWeb
	```
	可以看到恢复后的可执行文件变大了。然后将新的可执行文件替换原来的。发现启动应用没有任何反应。
	
	打开 Console.app 查看日志
	![console_mweb_crash](https://i.loli.net/2019/04/10/5cacd7359e4ae.jpg)
	很明显，是检测了 APP 的什么状态, 然后直接终止应用。是时候祭出 Hopper 了。
	
### 使用 Hopper 静态调试
#### 思路
* 暴力模式：遇到拦路虎，分析出大概位置，然后 Hopper 定位，在对应代码段中直接 `ret` 掉函数或者直接修改寄存器值绕过检测。这种方式不推荐，也许会影响正常使用；而且产生的崩溃信息仍然被记录···。但是本篇采用这种方式，因为来得快啊！
* 优雅模式：分析出中断函数的上层逻辑，比如上图`_appTrackingState`，猜测会有一个`if`或`switch`语句，我们就在这之前将其值修改为其他值；再甚者，分析出`_appTrackingState`的是如何被赋值的，然后去 hook 相应函数。

#### 开始暴力破解
* 直接终止应用？这可是一个超明显标识啊。`Hopper - Labels或Strings` 中直接搜索 quit、terminate、exit、abort 等函数名
	![hoper_mweb_terminate](https://i.loli.net/2019/04/10/5cacd735a9e30.jpg)
	明显看到 C++ 的 `terminate`函数，查看伪代码
	
	```
	function _ZSt9terminatev {
	    rax = std::terminate();
	    return rax;
	}
	```
	直接将该函数提前 `return`即可。`alt + a`修改汇编
	![hoper_mweb_terminate_ret](https://i.loli.net/2019/04/10/5cacd741635b5.jpg)
	然后生成新的可执行文件，替换原 APP 中的。
	![hoper_produce_mweb_1](https://i.loli.net/2019/04/10/5cacd735a0f28.jpg)
* 现在 APP 可以启动看到试用界面了，同时还有个`Insecure update error!`提示框。
	![mweb_dsa_error_trial](https://i.loli.net/2019/04/10/5cacd7357eb81.jpg)
* error 先暂时不管，先绕过试用界面再说。
* 试用界面和主界面几乎是同时出现的，因此推断处理逻辑在`applicationWillFinish`或`applicationDidFinish`中。Hopper 对刚才新的可执行文件进行分析。
	![hoper_mweb_application_finish](https://i.loli.net/2019/04/10/5cacd74153a76.jpg)
* 在 `DidFinish` 中我们看到以下字段

	```objc -[AppDelegate applicationDidFinishLaunching:]
	rbx = @selector(setIsDisableAllUI:);
    _objc_msgSend(r13, rbx);
    if (sub_100253020(0x0) != 0x0) {
            _objc_msgSend(r13, rbx);
    }
    else {
            intrinsic_movsd(xmm0, *0x1003715c0);
            [DevMateKit setupTimeTrial:r13 withTimeInterval:rcx];
    }
    [r13 updateMWebLicenseInfoUI:0x0];
	```
	其中`r13 = self`。这里需要注意，给出的`objc_msgSend`只给了两个参数（self，_cmd）。但是`setIsDisableAllUI:`还需要一个参数。
	
	{% blockquote Endv, https://www.cnblogs.com/endv/p/4110798.html, https://www.cnblogs.com/endv/p/4110798.html, X86-64寄存器和栈帧 %}
		* %rax 作为函数返回值使用。
		* %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。
	{% endblockquote %}
	
	对应下来 rdx 中就是方法的参数。为此我们需要分析一下汇编
	![hoper_mweb_diable_all_ui](https://i.loli.net/2019/04/10/5cacd735c6188.jpg)
	框出来的部分就是在传参，按照上面寄存器顺序
	* 0x1 传到 edx，也就是 rdx 的低32位。第三个参数为 1
	* r13 传到 rdi。第一个参数为 self
	* rbx 传到 rsi，最上面一句 rbx 存储的是方法的编号。第二个参数为 @selector(setIsDisableAllUI:)
	* 接下来调用 objc_msgSend 发消息，也就是 `[self setIsDisableAllUI:YES]`
	* 然后异或（同0异1）操作将 edi 赋值为 0，作为 if 条件中 `sub_100253020`函数的参数。edi 即 rdi 的低32位。其实这句也可以用 `mov edi, 0x0`，但是异或操作性能更好。
	* 调用 sub_100253020 函数，获取返回值后和 0 进行比较。
	* 左边对 edx 寄存器进行异或置0，那么整个左边其实就是 `[self setIsDisableAllUI:NO]`
	
	因此整个逻辑：
	
	* 先将 UI 禁用，然后调用 sub_100253020 函数验证 APP 激活状态。
	* 有效激活，激活所有 UI。
	* 无效，使用第三方 `DevMateKit` 走试用步骤。

	> 如果用 IDA, 一目了然 ···
	>> ![ida_mweb_didFinish](https://i.loli.net/2019/04/10/5cacd7357831b.jpg)

	所以重点就是 sub_100253020 的 hook。这里选择直接定位(Hopper 中直接双击即可)，然后修改返回值为1。
	![hoper_mweb_activate_ret_1](https://i.loli.net/2019/04/10/5cacd735874d8.jpg)
	`alt + a`添加图中两句即可。然后生成新的二进制文件去替换。
	
	接下打开 APP，激活窗口已经被绕过了。但是还有个 `update error`的窗口，直接点击 ok 已经可以使用软件了。
	
	第一直觉应该是个 Alert 窗口，但是在 AppDelegate 的几个入口函数中并没看到。绝望中直接百度了下 [insecure update error](http://bbs.iosre.com/t/osx-insecure-update-error/3139)。居然有现成的解决办法^_^。
	
	其实这个校验三方是集成在另一个第三方框架 `DevMateKit`中。过程就是找啊找啊找···
	
	Hopper 打开动态库的二进制文件(`xxx.app/Contents/Frmaeworks/DevMateKit.framework/Versions/A/DevMateKit`), `Strings` 中搜索 `insecure update error`。
	![hoper_insecure_update_error](https://i.loli.net/2019/04/10/5cacd735bbaa0.jpg)
	
	在字符串上点击右键，选择 `reference to address 0xxxxxx`，弹出的窗口中选择引用地址，GO，会跳转到引用该地址的地方。
	![hoper_reference_to_insecure_update_error](https://i.loli.net/2019/04/10/5cacd735a0f6a.jpg)
	![hoper_reference_to_address_go](https://i.loli.net/2019/04/10/5cacd735887ae.jpg)
	
	跳转后，在高亮的代码上继续右键，GO，来到引用字符串的函数中
	![hoper_check_if_properly](https://i.loli.net/2019/04/10/5cacd735b7419.jpg)
	
	> 该方法返回值是 void 类型，所以其实可以直接将该方法给 ret 掉。本文结束。
	
	---
	
	我们要 **“ 操作的就是 var\_50 和 rax=var\_58 ”** 的值，对应的汇编代码
	![hoper_check_if_properly_var58_a.jpg](https://i.loli.net/2019/04/10/5cacd9ade122c.jpg)
	
	> var\_50 和 var\_58 是一个 offset，在该段汇编的开头可以查到具体的值为 -80 和 -88(注意是10进制表示)。
	> 因此我们实际操作的是 rbp - offset 指向的地址中的值。
	
	现在我们要回溯之前的汇编代码，尽量得出 `rbp - var_50`和`rbp - bar_58`中是个什么值。
	
	* ~~先看 var\_50，最近的赋值 `mov byte [rbp + var_50], al`。al 是 rax 的低 8 位。也就是将 rax 的低 8位 赋值到 `rbp - 80`指向的地址的低8位。接下来再回溯看 rax 的值即可。~~ 结合上面伪代码图中蓝色框图, var\_50 应该是个 bool 值，因此我们要将其修改为 1 。
	![hoper_check_if_properly_var50_1.jpg](https://i.loli.net/2019/04/10/5cacd9adc6cc2.jpg)
	* 上面红色框中伪代码，var\_58 应该是个字符串，因此不能为空。要注意的是，qword 表示要读取64位。**这里赋值时，如何给存储区赋值字符串？`mov qword [rbp-88], ？？`** 有知道的朋友请告知，谢谢。直接赋值会造成之后的代码紊乱。
	![hoper_check_proper_hex.jpg](https://i.loli.net/2019/04/10/5cacd9add7665.jpg)
	往上分析，这里 rax 存放的是 `@selector(publicDSAKey)` 的返回值，因此找到该方法，直接往 rax 里放个字符串。（其实还可以继续分析 DSAKey 是如何来的，但是笔者选择了简单一点的方法）
	

	
### UI 调试

* Xcode 随便新建一个 MacOS 项目。`Debug - Attach To Process - 选中要附加的 APP`。Xcode 上方状态栏显示 Running xxx 后，使用 Xcode `Debug View Hierarchy`断住 APP。

* 接下来使用 `bt all`打印 APP 所有在使用线程的堆栈。



### 相关链接
* [一篇文章走进Mac逆向的世界](http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/)
* [最简单的Hopper Disassembler玩转Mac逆向](https://www.jianshu.com/p/c04ac36c6641)
* [macOS 逆向之生成动态注入 APP](https://blog.nswebfrog.com/2018/02/09/make-injection-APP-for-mac)
* [X86-64寄存器和栈帧](https://www.cnblogs.com/endv/p/4110798.html)