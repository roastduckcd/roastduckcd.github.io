---
title: 逆向实战录一
comments: true
toc: true
copyright: true
declare: true
categories:
  - iOS
  - 逆向
tags:
  - 逆向
date: 2019-04-10 01:33:45
top:
---

本篇记录一下在 Mac 上逆向某付费 APP 的过程。仅与读者探讨技术，请勿将逆向后的 APP 商用。请支持正版！
<!--more-->

### 工具准备
* Xcode: 附加进程动态调试，UI 调试
* restore-symbol: [符号表恢复](https://github.com/tobefuturer/restore-symbol)
* Hopper Disassembler 或 IDA: 静态调试，Hopper 在 Mac 上方便点，另外 Hopper 会对伪代码自行优化，可能忽略一些代码。推荐 Windows IDA，伪代码更详细。

### 思路
* 暴力模式：遇到拦路虎，分析出大概位置，然后 Hopper 定位，在对应代码段中直接 `ret` 掉函数或者直接修改寄存器值绕过检测。这种方式不推荐，也许会影响正常使用；而且产生的崩溃信息仍然被记录···。但是本篇采用这种方式，因为来得快啊！
* 优雅模式：分析出中断函数的上层逻辑，比如上图`_appTrackingState`，猜测会有一个`if`或`switch`语句，我们就在这之前将其值修改为其他值；再甚者，分析出`_appTrackingState`的是如何被赋值的，然后去 hook 相应函数。

### hopper 开始暴力破解
* 打开界面
    ![mweb_trial_zero](https://i.loli.net/2019/04/17/5cb6b57d31b3c.jpg)
    很明显，第一步肯定是要绕过这个试用界面。试用界面和主界面几乎是同时出现的，因此推断处理逻辑在`applicationWillFinish`或`applicationDidFinish`中。其次，查看一下菜单栏，发现一些主要菜单都被禁用了。这也是我们需要绕过的一步。
    
* Hopper 对刚才新的可执行文件进行分析。
	![hoper_mweb_application_finish](https://i.loli.net/2019/04/17/5cb6b575e5447.jpg)
* 在 `DidFinish` 中我们看到以下字段

	```objc -[AppDelegate applicationDidFinishLaunching:]
	rbx = @selector(setIsDisableAllUI:);
    _objc_msgSend(r13, rbx);
    if (sub_100253020(0x0) != 0x0) {
            _objc_msgSend(r13, rbx);
    }
    else {
            intrinsic_movsd(xmm0, *0x1003715c0);
            [DevMateKit setupTimeTrial:r13 withTimeInterval:rcx];
    }
    [r13 updateMWebLicenseInfoUI:0x0];
	```
	`setIsDisableAllUI:`，应该是菜单禁用的逻辑。
	其中`r13 = self`。这里需要注意，给出的`objc_msgSend`只给了两个参数（self，_cmd）。但是`setIsDisableAllUI:`有一个冒号，所以还需要一个参数，但是 hopper ···给优化了？。好吧，自己查看汇编分析寄存器咯。
	
	{% blockquote Endv, https://www.cnblogs.com/endv/p/4110798.html, https://www.cnblogs.com/endv/p/4110798.html, X86-64寄存器和栈帧 %}
		* %rax 作为函数返回值使用。
		* %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。
	{% endblockquote %}
	
	`obj_msgSend`函数的第一、二个参数是`self`和`_cmd`。然后才是方法参数，也就是在寄存器 rdx 中。来到汇编
	![hoper_mweb_diable_all_ui](https://i.loli.net/2019/04/17/5cb6b575e47b8.jpg)
	框出来的部分就是在传参，按照上面寄存器顺序
	* 0x1 传到 edx，也就是 rdx 的低32位。那么第三个参数为 1
	* r13 传到 rdi。第一个参数为 self
	* rbx 传到 rsi，最上面一句 rbx 存储的是方法的编号。第二个参数为 @selector(setIsDisableAllUI:)
	* 接下来调用 objc_msgSend 发消息，也就是 `[self setIsDisableAllUI:YES]`
	* 然后异或（同0异1）操作将 edi 赋值为 0，作为 if 条件中 `sub_100253020`函数的参数。edi 即 rdi 的低32位。其实这句也可以用 `mov edi, 0x0`，但是异或操作性能更好。
	* 调用 sub_100253020 函数，获取返回值后和 0 进行比较。
	* 左边对 edx 寄存器进行异或置0，那么整个左边其实就是 `[self setIsDisableAllUI:NO]`
	
	因此整个逻辑：
	
	* 先将 UI 禁用，然后调用 sub_100253020 函数验证 APP 激活状态。
	* 有效激活，激活所有 UI。
	* 无效，使用第三方 `DevMateKit` 走试用步骤，显示使用界面。

	一下子就将两个步骤给逮到了。破解思路就是让函数 sub_100253020 返回 YES（1）。 

	> 如果用 IDA, 不用分析汇编，一目了然 ···
	>> ![ida_mweb_didFinish](https://i.loli.net/2019/04/17/5cb6b5759efd2.jpg)

	接下来 hook sub_100253020 函数。这里选择直接定位(Hopper 中直接双击即可)，然后修改返回值为1。
	![hoper_mweb_activate_ret_1](https://i.loli.net/2019/04/17/5cb6b575b2c9b.jpg)
	`alt + a`添加图中两句即可。然后生成新的二进制文件去替换。
	
	接下打开 APP，激活窗口已经被绕过了。但是还有个 `update error`的窗口，直接点击 ok 已经可以使用软件了。
	![mweb_dsa_error_trial](https://i.loli.net/2019/04/17/5cb6b575ae994.jpg)
	第一直觉应该是个 Alert 窗口，但是在 AppDelegate 的几个入口函数中并没看到。绝望中直接百度了下 [insecure update error](http://bbs.iosre.com/t/osx-insecure-update-error/3139)。居然有现成的解决办法^_^。
	
	其实这个校验三方是集成在另一个第三方框架 `DevMateKit`中。过程就是找啊找啊找···
	
	Hopper 打开动态库的二进制文件(`xxx.app/Contents/Frmaeworks/DevMateKit.framework/Versions/A/DevMateKit`), `Strings` 中搜索 `insecure update error`。
	![hoper_insecure_update_error](https://i.loli.net/2019/04/17/5cb6b57d3b202.jpg)
	
	在字符串上点击右键，选择 `reference to address 0xxxxxx`，弹出的窗口中选择引用地址，GO，会跳转到引用该字符串的地方。
	![hoper_reference_to_insecure_update_error](https://i.loli.net/2019/04/17/5cb6b575c7b34.jpg)
	![hoper_reference_to_address_go](https://i.loli.net/2019/04/17/5cb6b575afb28.jpg)
	
	跳转后，在高亮的代码上继续右键，GO，来到引用字符串的函数中
	![hoper_check_if_properly](https://i.loli.net/2019/04/17/5cb6b575df024.jpg)
	
	> 该方法返回值是 void 类型，所以其实可以直接将该方法给 ret 掉，生成新的动态库MachO文件替换原来的。
	> 本文结束···。
	
	我们要 **“ 操作的就是 var\_50 和 rax=var\_58 ”** 的值，对应的汇编代码
	![hoper_check_proper_hex](https://i.loli.net/2019/04/17/5cb6b575c18ca.jpg)
	
	> var\_50 和 var\_58 是一个 offset，在该段汇编的开头可以查到具体的值为 -80(十六进制的50) 和 -88(十六进制的58)。
	> 因此我们实际操作的是 rbp - offset 指向的地址中的值。
	> var_50等变量是 hopper 提供的，修改汇编时不能直接使用。需要使用对应的值，16进制或10进制都可。
	
	现在我们要回溯之前的汇编代码，尽量得出 `rbp - var_50`和`rbp - bar_58`中是个什么值。
	
	* 先看 var\_50，最近的赋值 `mov byte [rbp + var_50], al`。al 是 rax 的低 8 位。也就是将 rax 的低 8位 赋值到 `rbp - 80`指向的地址的低8位。接下来再回溯看 rax 的值即可。 结合上面伪代码图中蓝色框图, var\_50 应该是个 bool 值。

	   这里笔者有两种思路：第一种因为最后是拿 rbp + var_50 中的值比较，因此我们可以直接将 0x1 传进去 。第二种是去修改 al 即某个函数的返回值，需要去追溯最近调用的函数。
	
	  ~~按照第一种思路将汇编改为 `mov byte [rbp - 80], 0x1`。修改后，由于对应指令的机器码长度不一样，新的机器码覆盖掉后面的机器码，造成后续汇编指令被意外修改，影响程序流程。~~解决方案是找到一句汇编，保证原来逻辑的同时，机器码保持原来的字节数。笔者自己也是汇编新手，感觉很难啊！至于汇编和机器码的转换会在后续文章推出。
	  
	  这里笔者最后选择了思路二。
	  ![hopper_bundleAtURLIsCodeSigned](https://i.loli.net/2019/04/17/5cb6b575e492f.jpg)
	  al 即 rax 中的值是方法 `bundleAtURLIsCodeSigned:`的返回值。直接修改汇编令该方法返回 0x1。
	  
	  > 然后生成新的动态库 MachO 文件进行替换后，MWeb 可以运行了。
	  
	* 根据上面伪代码红色框中，var\_58 应该是个字符串，因此不能为空。要注意的是，qword 表示要读取64位。
	   
	   和 var_50 思路相同，这里 rax 存放的是 `@selector(publicDSAKey)` 的返回值，因此找到该方法，直接往 rax 里放个字符串。对应的汇编`lea        rax, qword [0x90822]; "Insecure update error!" `，lea 也可以使用 mov。这里传到 rax 的是字符串的地址。笔者在数据段里随便找了字符串，然后 MWeb 崩溃了。本来猜测对 key 做了校验，后来笔者随便试了下`mov rax, 0x1； ret；`居然成功了-_-!。这个地方需要进一步分析汇编代码，有兴趣的读者可以再试试。

### 相关链接
* [一篇文章走进Mac逆向的世界](http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/)
* [最简单的Hopper Disassembler玩转Mac逆向](https://www.jianshu.com/p/c04ac36c6641)
* [macOS 逆向之生成动态注入 APP](https://blog.nswebfrog.com/2018/02/09/make-injection-APP-for-mac)
* [X86-64寄存器和栈帧](https://www.cnblogs.com/endv/p/4110798.html)