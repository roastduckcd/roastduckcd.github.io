---
title: 汇编与机器码
comments: true
toc: true
copyright: true
declare: true
categories:
  - 汇编
tags:
  - 机器码
date: 2019-04-18 00:10:08
top:
---


* 在[逆向实战录一](http://roastduck.xyz/article/%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E5%BD%95%E4%B8%80.html)中提到过修改汇编导致机器码的改变。部分机器码覆盖了原有的机器码，进而导致了下一条汇编的改变，甚至可能影响程序流程。那么汇编和机器码到底是怎样转换的呢？
<!--more-->
* 由于上一篇是 Mac 逆向，所以用到的是 intel 的 x86-64 架构指令。

* 指令和机器码对照需要查询 intel 手册，本篇使用的是[这个](https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-2a-2b-2c-and-2d-instruction-set-reference-a-z)。 [最新手册看这里](https://software.intel.com/en-us/articles/intel-sdm)

### IA32 MODE 下 x86-64 的机器码结构

* 翻到手册 2.1 章节
    ![intel_instruction_format](https://i.loli.net/2019/04/18/5cb8906cb601b.jpg)
    * 指令结构从右到左 -- 低位到高位
    * `Opcode`: 是必需的，我们看到的 mov，jne 等操作码是它的一部分。一条机器码需要操作码(Opcode)和操作数(Operand)类型共同确定。有时候还需要 ModR/M 的 Reg/Opcode 3个 bit 作为补充。
    * `ModR/M`: 用于寄存器间接寻址和寄存器相对寻址。它包含3个部分。
        * `Mod` 和 `R/M`：两者共5bit，形成32种组合：8种寄存器模式(Mod 为 11)和24中地址寻址模式。有时候也会用于补充描述操作码。当作为寄存器时，使用的是32位；配合 prefix REX.R 使用64位。
        * `Reg/Opcode`: 该部分要么指定寄存器编号，要么作为主操作码的补充。至于何时二选一会在主操作码中指定。当作为寄存器时，使用的是32位；配合 prefix REX.R 使用64位。
        * 查看 2.1.3 章节  table 2-2
        
         ![intel_instruction_ModR:M](https://i.loli.net/2019/04/18/5cb8906cd8ed1.jpg)
    * 在表格中 note 1 的情况需要使用 SIB 部分。SIB 用于基址加变址寻址或比例加变址寻址。
        * `Scale`：比例因子
        * `Index`：指定变址寄存器编号。这里使用的是32位；配合 prefix REX.X 使用64位。
        * `Base`：指定基址寄存器编号。当作为寄存器时，使用的是32位；配合 prefix REX.B 使用64位。
            ![intel_instruction_SIB](https://i.loli.net/2019/04/18/5cb8906cd78c4.jpg)
    * `prefixes`: 指令前缀，它的作用有两个：指定特殊的编码方式，一共分成四组，具体的可以参看手册 2.1.1 部分。本文仅关注第二种方式，用于对 Opcode 的扩展。32位有8个寄存器，3个 bit 刚好够用；现在64位有16个寄存器，需要4个 bit 来表示：原有的3个 bit 加上 REX.R bit。2.2.1.2 章节 table 2-4 
        ![intel_instruction_prefix_format](https://i.loli.net/2019/04/18/5cb8906c89ed0.jpg)
        前4 bit 固定不变，后面4 bit需要根据查表或根据使用的寄存器宽度置 1或0。
* 根据上面写一个完整指令
    * `mov qword [rax + rcx * 8 + 0x11223344], 0x12345678`
    * `qword`: 相当于一个说明符，表示后面的寄存器或内存要读取 4字（8个字节，64bit）的数据。同样的还有 dword（双字，4个字节），word（字，2个字节），byte（1个字节）
    * 对应指令解释：`Opcode [base + index * scale + displacement], immediate`
### 指令中的部分标识
* 查表我们会看到一些通用标识，来代表一类操作数。比如 /r、ib、r/m8等，接下来我们列举一些常用的。这些都可以在 3.1.1 章节找到。
    ![instruction_symbols](https://i.loli.net/2019/04/18/5cb8906caaae1.jpg)
* Opcode 列中的标识。3.1.1.1 章节
    * `/r`：ModR/M 位中包含有一个寄存器操作数和一个寄存器或内存操作数。
    * `REX.W（R、X、B）`：指定 REX prefix 中使用的 bit。
    * `/digit`：digit 为0~7，ModR/M 中的 Reg/Opcode 用于主操作码的补充，在表中对应顶部单元格的倒数第二行。
    * `ib、iw、id、io`: 立即数的宽度（位数），一次为单字节(byte)，字(双字节，word)，双字(dword)，四字(qword)。
    * `rb、rw、rd、ro`：Opcode的低 3 bit 用于表示寄存器，且不使用 ModR/M。如果是64位，则需要 REX.B补充表示。
* Instruction 列中的部分标识。3.1.1.3 章节
    * `r8/16/32/64`：不同宽度的寄存器，64位需要 REX.R位支持。
    * `r/m8/16/32/64`：寄存器或内存中不同宽度的操作数，64位寄存器需要 REX.R位支持。_和上面一条对比，笔者个人理解上一条表示寄存器直接寻址，该条表示寄存器相对寻址。不知道是否正确···_
    * `imm8/16/32/64`：不同宽度的立即数
    * `m8/16/32/64`：内存中不同宽度的操作数
    * `moffs8/16/32/64`：内存偏移，真正的物理地址需要段基地址+偏移得到。不使用ModR/M。笔者在这里有点蒙圈，因为实际的编码和笔者查出来的不同。比如 mov 指令中 `mov al, moffs8`的 Opcode 是 `A0`。笔者查找 `mov al, [0x6]`却是 `8A` 开头。不知道偏移指令是否是这样写的？读者朋友请告知一下，谢谢！

### 举例解释，如有分析错误请留言指出。
* [逆向实战录一](http://roastduck.xyz/article/%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E5%BD%95%E4%B8%80.html)中对栈寄存器的赋值操作`mov byte [rbp + var_50], al`，后面删除线中的错误操作`mov byte [rbp + var_50], 0x1`（var_50就是0x50）。接下来依据机器码解释修改汇编为什么导致后续指令改变的原因。

#### `mov byte [rbp - 0x50], al`
* 初步分析：mov 指令；byte 表示后面内容只取 8 bit；目的操作数是基址寄存器相对寻址；源操作数是寄存器直接寻址；displacement 0x50 只有 8 bit； al 低8位寄存器。
* mov 指令在 4.3 章节，善用搜索。一整页 pdf 表格，依据操作数的不同类型，给出了 mov 的不同 Opcode 。由于我们这里 byte 限定了只取8 bit 的数据，al 也是8bit 寄存器。我们找到
    ![intel_opcode_mov_rm8_r8](https://i.loli.net/2019/04/18/5cb8906c68494.jpg)
    由于实际用不到64位寄存器，因此选择第一条。因此 `Opcode 为 88`。第二条 *** 提示64位下该条指令不能使用AH、BH、CH、DH 4个单字节寄存器。

* Opcode 列含有 /r，接下来查看 ModR/M 部分。目的操作数寄存器相对寻址，并且 displacement 为 8 bit。因此在 table 2-2 ModR/M 表中对应找到`[EBP]+disp8`一行。Mod 为 01， R/M 为 101。源操作数为 al，在表中顶部单元格 r8 一行找到第一列。行列交叉处得到 ModR/M 为 45。
* displacement -0x50 直接嵌在最后。要注意这里是负数，需要找0x50的补码表示。displacement 为 B0
* 所以整个机器码为 88 45 BO。

#### `mov byte [rbp - 0x50], 0x1`
* 现在源操作数为立即数。在 mov 指令下找到
    ![mov_r:m8_imm8](https://i.loli.net/2019/04/18/5cb8906c5190c.jpg)
    Opcode 为 C6
* 接下来看 ModR/M 。目的操作数不变，还是找到`[EBP]+disp8`一行。然后在上面指令中 C6 后面跟着/0 ib。ib 表示立即数，这里就是 0x1。/0 需要在 ModR/M 顶部单元格 /digit 中找，0就是第一列。行列交叉得到 45。
* displacement 在 immediate 前面。所以整个机器码为 C6 45 B0 01。

将两条机器码对比，后一条笔者修改的多出了一个字节，而这个字节将后面指令的机器码覆盖了，变相修改了下一条指令。改变了寄存器之间的赋值。

因此逆向时修改汇编除非是 ret 整个函数，否则在不改变原有赋值的情况下直接修改指令：要么找到一条指令满足逆向需求，同时不能增加或减少字节数，要么就一直修改到底。尤其是对笔者这种刚入门的，是挺抓脑的。所以还是借助 MonkeyDev、substrate 等工具 hook 函数好一些。

### 相关链接
* https://blog.csdn.net/cosmoslife/article/details/7631923
* https://www.cnblogs.com/guocai/archive/2012/10/18/2730048.html
* https://blog.csdn.net/winsenjiansbomber/article/details/27253577
* https://blog.csdn.net/u011555996/article/details/80264855
* https://bbs.pediy.com/thread-191802.htm