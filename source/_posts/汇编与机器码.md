---
title: 汇编与机器码
comments: true
toc: true
copyright: true
declare: true
categories:
  - 汇编
tags:
  - 机器码
date: 2019-04-18 00:10:08
top:
---

在[逆向实战录一](http://roastduck.xyz/article/%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E5%BD%95%E4%B8%80.html)中提到过修改汇编导致机器码的改变。部分机器码覆盖了原有的机器码，进而导致了下一条汇编的改变，甚至可能影响程序流程。那么汇编和机器码到底是怎样转换的呢？
<!--more-->

* 由于上一篇是 Mac 逆向，所以用到的是 intel 的 x86-64 架构指令。

* 指令和机器码对照需要查询 intel 手册，本篇使用的是[这个](https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-2a-2b-2c-and-2d-instruction-set-reference-a-z)。 [最新手册看这里](https://software.intel.com/en-us/articles/intel-sdm)

### IA32 MODE 下 x86-64 的机器码结构

* 翻到手册 2.1 章节
    ![intel_instruction_format](media/intel_instruction_format.jpg)
    * 指令结构从右到左 -- 低位到高位
    * Opcode 是必需的，我们看到的 mov，jne 等操作码是它的一部分。一条 Opcode 的确定需要操作码和操作数类型共同确定。
    * prefixes 指令前缀，2.2.1.2 章节 table 2-4 
        ![intel_instruction_prefix_format](media/intel_instruction_prefix_format.jpg)
    * ModR/M 从图中看出这是两个部分，mod 表示寻址模式，Reg/Opcode 表示可补充为寄存器或操作码，R/M  表示寄存器或内存
    
    * 查表时首先要查找的就是这个，其次再根据操作数的类型去确定。

### 举例解释
* [逆向实战录一](http://roastduck.xyz/article/%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E5%BD%95%E4%B8%80.html)中对栈寄存器的赋值操作`mov byte [rbp + var_50], al`，后面删除线中的错误操作`mov byte [rbp + var_50], 0x1`。（var_50就是0x50）依据机器码解释修改汇编为什么导致后续指令改变的原因。

#### `mov byte [rbp - 0x50], al`
* 初步分析：这是寄存器相对寻址；mov 指令； rbp 64位寄存器，但是整个中括号表示的是内存偏移，0x50 只有 8 bit； al 低8位寄存器。
* mov 指令在 4.3 章节，善用搜索吧。一整页 pdf 表格，依据操作数的不同类型，给出了 mov 的不同 Opcode 码。依据`mov 偏移，r8`我们找到
    ![intel_opcode_mov_offset8_al](media/intel_opcode_mov_offset8_al.jpg)
    因此 `Opcode 为 A2`。同时这里使用到了 REX prefix 的 W 位，将该位置 1，其余为0。
    ![rexPrefix_Opcode](media/rexPrefix_Opcode.jpg)
    `机器码：48 A2`
* 接下来查看 ModR/M 字节。查看 2.1.3 章节  table 2-2
    ![intel_instruction_ModR:M](media/intel_instruction_ModR:M.jpg)
    注意这里只有32位的格式，而我们的目的操作数中 rbp 是64位的。不过没关系，64位就是32位扩展来的嘛。
    
    首先看竖排，是目的操作数。rbp 的32位叫 ebp，结合 0x50 为 8 bit，我们找到 `[EBP]+disp8`这行：Mod 为 01；R/M 为 101。然后最上面为源操作数，al 对应 000。
    ![modr_m](media/modr_m.jpg)
    因此：ModR/M 为 45
* 0x50 为 displacement。整个机器码为：48 A2 45 50。
    

MM表示64位MMX寄存器.
r32表示32位通用寄存器或esi,edi
m32表示32位内存变量
m64表示64位内存变量
m128表示128位内存变量
imm8表示8位立即数

左操作数为目的操作数,右操作数为源操作数
'|'字符表示每组数据之间的间隔分隔符


mov r8, imm8   寄存器寻址
mov r/m8, imm8 寄存器相对寻址？？还是寄存器 or 直接寻址


### 相关链接
* https://blog.csdn.net/cosmoslife/article/details/7631923