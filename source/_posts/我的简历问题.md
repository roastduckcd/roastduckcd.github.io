---
title: 我的简历问题
date: 2019-04-27 22:33:24
comments: true
toc: true
copyright: true
declare: true
top:
categories:
- 面试
tags:
- 面试
---

# 我的简历问题
<!--more-->

####1. 熟练掌握UI设计以及视图的自定义
http://www.jianshu.com/p/7e47da62899c
http://www.jianshu.com/p/911468e948ee
新建一个继承UIView的类
在刚刚新建类的类扩展中添加子控件属性（用weak声明，防止内存泄露）
在initWithFrame:方法中添加子控件
在layoutSubviews方法中设置子控件的frame（在该方法中一定要调用[super layoutSubviews]方法）
提供一个模型属性，重写模型属性的set方法
在该setter方法中取出模型属性，给对应的子控件赋值

#####创建
- \- (instancetype)initWithFrame:(CGRect)frame
            （***Controller代码生成view时调用***）
    *  使用纯代码的方式创建自定义类，无论使用init方法创建，还是initWithFrame:方法创建，但是无论哪种方式，最后都会调用到initWithFrame:方法。
    
    * 将需要的子控件添加时，一般只是将子控件加到view而不设置尺寸，然后在***layoutSubviews***方法中设置子控件frame。若使用init方法创建，view的frame不确定，此时添加子视图会造成子视图frame为0.所以应该保证view的frame设置完才会设置它的子控件的尺寸。
    
- \- (id)initWithCoder:(NSCoder *)aDecoder 
            （***Controller通过XIB生成view时调用***）
    * 在该方法中方法IBoutlet之类的属性，如self.button等，值可能为nil。因为控件正在初始化。IBoutlet相当于获取控件进行初始化，然后addSubview，这些操作都是在initWithCoder之后的。所以建议在**awakeFromNib**方法中进行初始化的额外操作。因为awakeFromNib是在初始化完成后调用，所以在这个方法里面访问属性（IBOutlet）就可以保证不为nil。
    * 控件添加及尺寸设置在xib中已完成，但需要在控制器中设置view的位置。
    * 加载xib的俩种方法：

    ```
    // 第一种方法（较为常用）
    CYLView *view = [[[NSBundle mainBundle] loadNibNamed:@"CYLView" owner:nil options:nil] firstObject]; 
    // CYLView代表CYLView.xib，代表CYLView这个类对应的xib文件。这个方法返回的是一个NSArray，我们取第一个Object或最后一个（因为这个数组只有一个CYLView没有其他对象）就是需要加载的CYLView。
    //owner xib的拥有者，在控制器中指定owner为self，相当于[self.view addSubview:···]
    
    // 第二种方法
    UINib *nib = [UINib nibWithNibName:@"CYLView" bundle:nil];
    NSArray *objectArray = [nib instantiateWithOwner:nil options:nil];
    CYLView *view = [objectArray firstObject];
    
    ```
    
#####控件布局
- \- (instancetype)initWithFrame:(CGRect)frame 或
- \- (void)drawRect:(CGRect)rect   或
    需要做自定义绘图的时候
- \- (void)layoutSubviews 等
    对子视图进行重新布局
    该方法调用时机：
    *   init初始化不会触发layoutSubviews
    * addSubview会触发layoutSubviews
    * 设置view的Frame会触发layoutSubviews，当然前提是frame的值         设置前后发生了变化
    * 滚动一个UIScrollView会触发layoutSubviews
    * 旋转Screen会触发父UIView上的layoutSubviews事件
    * 改变一个UIView大小的时候也会触发父UIView上的layoutSubview             s事件
#####数据设置
对于需要初始化一些值时，可以创建一个初始化的工厂方法，控件的初始化和数据的初始化通过一个借口操作。

    + (instancetype)viewWithBook: (Book *)book;

```
+ (instancetype)viewWithBook: (Book *)book
{
    CYLView *view = [[[NSBundle mainBundle] loadNibNamed: NSStringFromClass(self) owner: nil opetions: nil] firstObject];
    view.book = book;
      return view;
}
```
但是如果之后需要修改一些属性，则最好对外提供设置数据接口的属性，重写setter方法给子控件设置显示数据。

    @property (nonatomic, strong) Book *book;

```
- (void)setBook: (Book *)book 
{
    _book = book; // 注意在这个方法中，不写这句也是没有问题的，因为在下面的语句使用的是book而非self.book或_book，但是如果在其他的方法中也想要访问book这个属性，那么就需要写上，否则self.book或_book会一直是nil（因为出了这个方法的作用域，book就销毁了，如果再想访问需要有其他的引用指向它）。所以建议，要写上这句。

    [self.button setTitle: book.like forState...];
    self.label = book.name;
}
```
这样控制器只需要创建自定义类和给它传递数据，不需要拿到自定义类中的子控件去操作，所以当需求改变时，我们的控制器有可能完全不用改动，只需改变自定义类的内部就可以。

####2. 一般常用设计模式如MVC、单例、委托等,了解MVVM设计模式
http://www.cnblogs.com/luoxiaofu/p/5308979.html
#####MVC
* Model：数据模型，负责界面显示需要的数据及数据转换操作逻辑，定义操控和处理数据的逻辑和运算
* View：视图展示，负责向用户展示界面和可视化Model，响应用户操作。UIview所产生的事件都可以采用委托的方式，交给控制器来实现
* Controller：控制器，负责加载View和访问Model并控制View展示数据，同时监听事件和操作数据。
![MVC][1]
  [1]: http://images2015.cnblogs.com/blog/755161/201510/755161-20151024111915458-112572637.png
模型会把任何数据的变更通知控制器，然后控制器更新视图数据。视图对象通知控制器用户的操作，控制器要么根据需要来更新模型，要么检索任何被请求的数据。
#####单例设计模式
单例设计模式确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。它通常采用懒加载的方式在第一次用到实例的时候再去创建它，如[NSUserDefaults standardUserDefaults], [UIApplication sharedApplication], [UIScreen mainScreen], [NSFileManager defaultManager]。可用于实现线程安全的方式访问共享实例。
```
- (Custome *)sharedInstance{
    
    static Custome *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        
        sharedInstance = [[Custome   alloc] init];
    });
    return sharedInstance;
}
```
#####门面模式
针对复杂的子系统提供了单一的接口，不需要暴漏一些列的类和API给用户，你仅仅暴漏一个简单统一的API。
#####装饰器模式：
    在不修改原来代码的情况下动态的给对象增加新的行为和职责，它通过一个对象包装被装饰对象的方法来修改类的行为，这种方法可以做为子类化的一种替代方法。
*Category(类别)*：是一种不需要子类化就可以让你能动态的给已经存在的类增加方法的强有力的机制。新增的方法是在编译期增加的，这些方法执行的时候和被扩展的类的其它方法是一样的。它可能与装饰器设计模式的定义稍微有点不同，因为Category(类别)不会保存被扩展类的引用。
#####委托代理模式
**委托**是装饰器模式中的经典实现，是一种和其它对象交互的机制。通过协议（Protocol）来声明可选以及必要的方法。
委托方：
1》定义协议
2》增加一个属性，存储代理对象的引用
    代理属性的时候通常用weak修饰
3》在合适的时机，给代理发消息

代理方：
1》遵守协议
2》实现方法
3》将自己设置为代理方（将自己的引用给B传过去）
#####观察者模式
一个对象任何状态的变更都会通知另外的对改变感兴趣的对象。观察者注册自己感兴趣的其它对象的状态变更事件。当状态发生变化的时候，所有的观察者都会得到通知。
*通知（NSNotification）：*
通知是一种基于订阅-发布模式的模型，它让发布者可以给订阅者发送消息，并且发布者不需要对订阅者有任何的了解。

*KVO  Key-Value Observing：*
当指定的对象的属性被修改后，KVO自动通知相应的观察者。
使用KVO的步骤
第一步：注册观察者
```
[message addObserver:self forKeyPath:kKVOPathKey options:NSKeyValueObservingOptionNew context:Nil];
```
第二步：更改主题对象属性的值，即触发发送更改的通知 
`_message.key = @"asdfasd";`
第三步：在制定的回调函数中，处理收到的更改通知
```
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context{
   
}
```
第四步：注销观察者 
`[_message removeObserver:self forKeyPath:kKVOPathKey];`

####3. 通知与代理、block的区别

1）代理针对的是一对一的关系，并且接收方可以返回值给发送方，代理的逻辑结构清晰，实现起来较为简单，声明协议、设置代理属性（为了避免循环引用，设置代理属性的时候通常用weak修饰）设定方法，最后在想要代理所做的事情的方法中调用即可。需要注意的是：创建协议的时候必须实现的方法用@require修饰，可选的方法使用@optional来修饰。

2）通知：通知是一对多的形式，只要是注册了该通知的对象，都可以接受消息。他的实现较为复杂，注册通知、发出通知，接受消息。当自己定义通知的时候，需要定义一个key来给通知命名，当接收通知的时候，这个key拼写错误的话就无法接受通知，通常使用宏的方式来避免这个问题。注册的通知中心需要手动的移除。

3）block是目前开发较为常用的一种方式，功能比较强大。最大的特点就是回调，回到的时候可以传入参数，最重要的是，无论在哪里嗲用，block的执行都会回到block创建的地方执行，而非调用的地方。

文／没有昵称会怎样（简书作者）
原文链接：http://www.jianshu.com/p/20c5500fbc79
著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。

####4. __block和__weak修饰符的区别

1.__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。

2.__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。

3.__block对象可以在block中被重新赋值，__weak不可以。

文／没有昵称会怎样（简书作者）
原文链接：http://www.jianshu.com/p/20c5500fbc79
著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。
####5. XML/JSON数据解析
#####JSON格式
* NSJSONSerialization

    [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
* 字典和Model互转
    * MJEXTENSION
    * YYModel
#####XML格式
* SAX（Simple API for XML）
    基于事件驱动的解析方式，***逐行***解析数据，采用协议回调机制
    原生 NSXMLParse：一边读一边解析，解析过程由NSXMLParserDelegate协议方法回调
```
@property (strong, nonatomic) NSXMLParser *parser;
//标记当前标签，以索引查找XML的内容
@property (copy, nonatomic) NSString *currentElement;
```
```
//启动解析器
[self.parser parse];
```
```
//开始解析
- (void)parserDidStartDocument:(NSXMLParser *)parser{
    NSLog(@"parser XML start successfully");
}
//遍历节点（<>部分）：属性
- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary<NSString *,NSString *> *)attributeDict{
    
    self.currentElement = elementName;
    if ([self.currentElement isEqualToString:@"student"]) {
        
        self.model = [[Model alloc] init];
        NSLog(@"开始了一个节点，生成了一个student model");
    }
}
//获取节点内容（<> </>之间的部分）:值
- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string{
    
    if ([self.currentElement isEqualToString:@"pid"]) {
        
        self.model.pid = string;
        NSLog(@"解析到pid");
    }else if([self.currentElement isEqualToString:@"name"]){
        
        self.model.name = string;
        NSLog(@"解析到name");
    }else if ([self.currentElement isEqualToString:@"sex"]){
        
        self.model.sex = string;
        NSLog(@"解析到sex");
    }else if ([self.currentElement isEqualToString:@"age"]){
        
        self.model.age = string;
        NSLog(@"解析到age");
    }
}
//解析完一个节点
- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName{
    
    if ([elementName isEqualToString:@"student"]) {
        
        [self.mDataArray addObject:self.model];
    }
    self.currentElement = nil;
}
//解析完毕
- (void)parserDidEndDocument:(NSXMLParser *)parser{
    NSLog(@"parser XML end ");
}
```
* DOM（Document Object Model ）
    文档对象模型。解析时需要将XML文件整体读入，并且将XML结构化成树状，使用时再通过树状结构读取相关数据，***查找***特定节点，然后对节点进行读或写
GDataXML
依赖libxml2，在Build Phases里面的Link Binary With Libraries添加
Header Search Paths，添加路径“/usr/include/libxml2”。
Other Link Flags，添加“-lxml2“（ARC），（MRC版本添加-libxml2）
```
NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"test" ofType:@"xml"]];
    //初始化对象
    GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data error:nil];
    //获取根节点
    GDataXMLElement *rootElement = [doc rootElement];
    //获取节点下的所有内容以数组存储
    NSArray *elements = [rootElement elementsForName:@"student"];
    for (GDataXMLElement *propertyNode in elements) {
        
        self.model = [[Model alloc] init];
        
        //获取节点下的所有内容以数组存储
        GDataXMLElement *pid = [propertyNode elementsForName:@"pid"].firstObject;
        self.model.pid = [pid stringValue];
        
        GDataXMLElement *name = [propertyNode elementsForName:@"name"].firstObject;
        self.model.name = [name stringValue];
        
        GDataXMLElement *sex = [propertyNode elementsForName:@"sex"].firstObject;
        self.model.sex = [sex stringValue];
        
        GDataXMLElement *age = [propertyNode elementsForName:@"age"].firstObject;
        self.model.age = [age stringValue];
        
        [self.mDataArray addObject:self.model];
    }
```
####6.数据持久化
#####沙盒
iOS程序访问的自己的目录。
目录结构：
```
应用程序包:应用程序的源文件，包括资源文件和可执行文件。
Documents:适合存储重要数据,iTunes同步该应用时会同步此文件夹中的内容。
Library:
  Caches:iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。
  Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保
               存应用的设置信息。
tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录
     下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。
```
```
//应用程序包
NSString *path = [[NSBundle mainBundle] bundlePath];
//Documents
NSString *path = NSSearchPathForDirectoriesInDomains(
    NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
//Library/Caches
NSString *path = NSSearchPathForDirectoriesInDomains(
    NSCachesDirectory, NSUserDomainMask, YES).firstObject;
//Library/Preferences
NSString *path = NSSearchPathForDirectoriesInDomains(
    NSPreferencePanesDirectory, NSUserDomainMask, YES).firstObject;
//tmp
NSString *path = NSTemporaryDirectory();
```
#####Sqlite
C语言库

* 字段类型
    * integer : 整数
    * real : 实数（浮点数）
    * text : 文本字符串
    * blob : 二进制数据，比如文件，图片之类的
    将图片、视频音频数据转换成NSData，然后上传到数据库中。
读取数据的时候要从数据库获取这些NSData数据，然后再转换成应有的格式，存入到本地文件夹。

***主键必须设置成integer***

* 使用准备
    * 添加库文件：libsqlite3.dylib并导入主头文件
    * 先需要创建数据库和表，才能操作一条条记录。
    * 打开一个数据库 ，若无则创建
```
   //创建数据库和一张表
- (void)createDatabaseAndTable{
    
    //一般存储在Documents文件夹
    NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    NSString *databasePath = [docPath stringByAppendingPathComponent:@"person.db"];
    
    //打开数据库，若无自动创建
    NSInteger success = sqlite3_open(databasePath.UTF8String, &_sqlite3);
    if (success == SQLITE_OK) {
        
        NSLog(@"创建数据库成功");
        
        char *errmsg = NULL;
        //sqlite3_exec()可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。
        sqlite3_exec(
                     _sqlite3,
                     "CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age int)",   /* SQL to be evaluated */
                     NULL,       /* Callback function */
                     NULL,       /* 1st argument to callback */
                     &errmsg     /* Error msg written here */
                     );
        if (errmsg) {
            
            NSLog(@"%s",errmsg);
        }else{
            
            NSLog(@"创建表成功");
        }
    }else{
        
        NSLog(@"创建数据库失败");
    }
} 
```
* 增：插入语句
```
//插入一般数据
- (void)insertData{
    
    char *errmsg = NULL;
    for (int i=0; i<1000; i++) {
        
        //注意c字符串
        //主线程阻塞，应使用多线程
        NSString *nsStr = [NSString stringWithFormat:@"INSERT INTO t_person (id, name, age) VALUES(%d, \"record-%d\", %d)", i, i, arc4random_uniform(80)];
        const char *sqliteStr = [nsStr cStringUsingEncoding:NSUTF8StringEncoding];
        
        sqlite3_exec(_sqlite3, sqliteStr, NULL, NULL, &errmsg);
        if (errmsg) {
            NSLog(@"%s",errmsg);
            return;
        }else{
        }
    }
    NSLog(@"插入一千条数据了");
}
```
* 修改表名以及增加字段（列）
SQLite 仅仅支持 ALTER TABLE 语句的一部分功能，我们可以用 ALTER TABLE 语句来更改一个表的名字，也可向表中增加一个字段（列），但是我们不能删除一个已经存在的字段，或者更改一个已经存在的字段的名称、数据类型、限定符等等。

----------
注意修改之后，使用新的表名。苦逼T_T

---------

```
//修改表名并且增加一个image的字段
- (void)alterTableNameAndAddColumnForImage{
    
    char *errmsg = NULL;
    //注意需要引号
    //修改表名：alter table "旧名字" rename to "新名字"
    NSString *nsStr = [NSString stringWithFormat:@"alter table \"t_person\" rename to \"person\""];
    int success = sqlite3_exec(_sqlite3, nsStr.UTF8String, NULL, NULL, &errmsg);
    if (success == SQLITE_OK) {
        
        NSLog(@"修改表成功");
        //接下来是新表名 person
        //注意无引号
        //添加列：alter table 表名 add column 列名 类型
        NSString *addStr = [NSString stringWithFormat:@"alter table person add column image blob"];
        int succ = sqlite3_exec(_sqlite3, addStr.UTF8String, NULL, NULL, &errmsg);
        if (succ == SQLITE_OK) {
            
            NSLog(@"添加成功");
        }else{
            
            NSLog(@"添加失败");
        }
    }else{
        
        NSLog(@"修改表名失败");
    }
}
```
* 多媒体文件读写：给新表插入图片
多媒体转换成二进制文件进行存储，NSData
```
//插入图片
- (void)insertImageData{
    
    //insert into时，如果是已存在的记录，insert into 失败，应用update
    NSString *nsStr = @"insert into person (id, name, age, image) values (?, ?, ?, ?)";
    
    sqlite3_stmt *stmt = NULL;
    int result = sqlite3_prepare(_sqlite3, nsStr.UTF8String, -1, &stmt, NULL);
    if (result == SQLITE_OK) {

        NSLog(@"预执行正确");
        //绑定参数
        // ?
        // 第一个 int 为 列号，默认从1开始的
        sqlite3_bind_int(stmt, 1, 1200);
        sqlite3_bind_text(stmt, 2, "xiaosongyang", -1, NULL);
        sqlite3_bind_int(stmt, 3, 22);
        
        NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"thread1" ofType:@"jpg"]];
        sqlite3_bind_blob(stmt, 4, [data bytes], (int)data.length, NULL);
        
        if (sqlite3_step(stmt) == SQLITE_DONE) {
            
            NSLog(@"插入成功");
        }else{
            
            NSLog(@"插入失败");
        }
    }else{
        
        NSLog(@"预执行失败");
    }
    
    sqlite3_finalize(stmt);
}
```
* 删除语句
```
//删除语句
- (void)deleteData{
    
    char *errmsg = NULL;
    
    NSString *nsStr = [NSString stringWithFormat:@"DELETE FROM t_person where id = 1"];
    
    sqlite3_exec(_sqlite3, nsStr.UTF8String, NULL, NULL, &errmsg);
    if (errmsg) {
        NSLog(@"%s",errmsg);
    }
    NSLog(@"删除成功");
}
```
* 修改语句
```
//修改语句
- (void)updateData{
    
    char *errmsg = NULL;
    //sqlite中字符串用单引号
    //使用NSString时要注意转意字符的使用
    NSString *nsStr = [NSString stringWithFormat:@"UPDATE t_person SET name = %@ where id = 2", @"\"songyangyang\""];
//    char *sql = "UPDATE t_person SET name = 'songyang' where id = 3";
    sqlite3_exec(_sqlite3, nsStr.UTF8String, NULL, NULL, &errmsg);
    if (errmsg) {
        NSLog(@"%s",errmsg);
    }
    NSLog(@"删除成功");
}
```
* 查询语句
    * sqlite3_prepare_v2() : 检查sql的合法性
    * sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录
    * sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。
    * sqlite3_finalize() : 释放stmt
```
//查询语句
- (void)readData{
    
    //where条件查询
    //全部查询 select * from t_person
    char *sqliteQuery = "select * from person";
//    char *sqliteQuery = "select * from person";
    sqlite3_stmt *stmt = NULL;
    
    //检查
    NSInteger result = sqlite3_prepare_v2(_sqlite3, sqliteQuery, -1, &stmt, NULL);
    if (result == SQLITE_OK) {
        
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            
            //iCol,第几列；
            //注意列号的使用，下标越界查询为空的问题
            //id取值
            NSInteger id = sqlite3_column_int(stmt, 0);
            //字符串取值
            char *name = (char *)sqlite3_column_text(stmt, 1);
            //整形取值
            NSInteger age = sqlite3_column_int(stmt, 2);
            //图片取值
            //先取出二进制数据
            const char *data = sqlite3_column_blob(stmt, 3);
            //长度
            int length = sqlite3_column_bytes(stmt, 3);
            //转为NSData
            NSData *imageData = [[NSData alloc] initWithBytes:data length:length];
            UIImage *image = [UIImage imageWithData:imageData];
            
            
            
            Model *model = [Model modelWithName:[NSString stringWithCString:name encoding:NSUTF8StringEncoding] age:[NSString stringWithFormat:@"%ld", age] headImage:image];
            [self.mDataArray addObject:model];
        }
    }
    Model *model = self.mDataArray[999];
    sqlite3_finalize(stmt);
}
```
######三方：FMDB

* FMDBDatabase：一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句
* FMResultSet：使用FMDatabase执行***查询***后的结果集
* FMDatabaseQueue：用于在多线程中执行多个查询或更新，它是线程安全的。


具体使用：

* 打开一个数据库 ，若无则创建

```
//创建数据库和表
- (void)createDatabaseAndTable{
    
    NSString *basePath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    NSString *databasePath = [basePath stringByAppendingPathComponent:@"animal.sqlite"];
    
    //path的三种情况
    //1. path 为nil，在内存创建一个临时数据库，数据库连接关闭时自动销毁。
    //2. path 为空字符串@"",在临时文件夹创建一个临时数据库，数据库连接关闭时自动销毁。
    //3. 有具体文件路径，如果不存在数据库则创建一个新的永久数据库。
    
    //出现显示创建成功，但是无实际文件创建
    //出现out of memoty
    
    self.database = [FMDatabase databaseWithPath:databasePath];
    NSString *errmsg = [_database lastErrorMessage];
    if (![self.database open]) {
        
        NSLog(@"创建数据库失败");
        return;
    }
    //操作时注意数据库语法错误
    BOOL success = [self.database executeUpdate:@"CREATE TABLE IF NOT EXISTS t_animal (id integer primary key autoincrement, name text, age integer)"];
    if (success) {
        
        NSLog(@"建表成功");
    }else{
        
        NSString *errmsg1 = [_database lastErrorMessage];
    }
}

```
* 使用FMDataBase类执行数据库销毁命令SQLdrop ...
```
//如果表格存在 则销毁
[self.database executeUpadate:@“drop table if exists t_student;”];
```
在FMDB中，把出select以外的操作统称为UPDATE调用一个方法，使用不同数据库语句。

* 更新 UPDATE
```
三种常用更新语句：
- (BOOL)executeUpdate:(NSString*)sql, ...
- (BOOL)executeUpdateWithFormat:(NSString*)format, ...
- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments
```
```
//更新一条数据
- (void)updateData{
    
    //1. executeUpdate:不确定的参数用？来占位（后面参数必须是oc对象，；代表语句结束, ; 可有可无）
    BOOL success = [self.database executeUpdate:@"UPDATE t_animal SET name = ? where id = ?", @"songyangyang", [NSNumber numberWithInt:2]];
    //2. executeUpdateWithFormat:不确定的参数用%@，%d等来占位 （参数为原始数据类型，执行语句不区分大小写）
    success = [self.database executeUpdateWithFormat:@"update t_animal SET name = %@ where id = %d", @"songyang", 1];
    //3. 参数是数组的使用方式,不确定的参数用？来占位（后面参数必须是oc对象，；代表语句结束, ; 可有可无）
    success = [self.database executeUpdate:@"update t_animal set name = ? where id = ?" withArgumentsInArray:@[@"xiaosongyang", @3]];
    
    if (success) {
        
        NSLog(@"修改成功");
    }else{
        
        NSString *errmsg = [self.database lastErrorMessage];
        NSLog(@"%@",errmsg);
    }
}
```
```
//插入数据
- (void)insertData{
    
    for (int i=0; i<1000; i++) {
        //FMDB中数据库语句参数 必须是 对象 参数
        [self.database executeUpdate:@"INSERT INTO t_animal
                    (id, name, age) VALUES (?, ?, ?)",
                    [NSNumber numberWithInt:i], 
            [NSString stringWithFormat:@"\"animal-\"%d", i],
            [NSNumber numberWithInt:arc4random_uniform(40)]];
    }
    NSString *errmsg = [self.database lastErrorMessage];
}
```
```
//删除一条数据
- (void)deleteData{
    
    BOOL success = [self.database executeUpdate:@"DELETE FROM t_animal where id = ?",[NSNumber numberWithInt:0]];
    if (success) {
        
        NSLog(@"删除成功");
    }else{
        
        NSString *errmsg = [self.database lastErrorMessage];
    }
}
```
* 查询
```
//三种常用查询语句,使用方法同三种更新语句
- (FMResultSet *)executeQuery:(NSString*)sql, ...
- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...
- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments
```
```
//查询数据
- (void)readData{
    
    FMResultSet *resultSet = [self.database executeQuery:@"select * from t_animal"];
    
    //遍历结果集
    while ([resultSet next]) {
        
//        NSInteger id = [resultSet intForColumn:@"id"];
        NSString *name = [resultSet stringForColumn:@"name"];
        NSInteger age = [resultSet intForColumn:@"age"];
        
        Model *model = [Model modelWithName:name age:[NSString stringWithFormat:@"%ld", age]];
        [self.mDataArray addObject:model];
    }
    
}
```

---
图片，音频，视频等多媒体文件需要转换成NSData存储。
---
* 线程安全
不能在多个线程中同时使用同一个FMDatabase实例，否则可能造成数据混乱。最好的方法是使用FMDatabaseQueue,后台会自动创建系列化的GCD队列。
```
- (void)queueCreateDatabaseAndTable{
    
    NSString *basePath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    NSString *databasePath = [basePath stringByAppendingPathComponent:@"man.sqlite"];
    
    self.databaseQueue = [FMDatabaseQueue databaseQueueWithPath:databasePath];
    
    [self.databaseQueue inDatabase:^(FMDatabase *db) {
       
        NSString *errmsg = nil;
        //同一个FMDatabase实例
        //创建
        BOOL success = [db executeUpdate:@"create table if not exists t_man (id integer primary key autoincrement, name text, age int);"];
        if (success) {
            
            NSLog(@"建表成功");
        }else{
            
            NSLog(@"建表失败");
            errmsg = [db lastErrorMessage];
        }
        //插入数据
        for (int i=0; i<10; i++) {
            
            [db executeUpdate:@"insert into t_man 
                (id, name, age) values (?, ?, ?)", 
                [NSNumber numberWithInt:i], 
                [NSString stringWithFormat:@"man-%d", i],
            [NSNumber numberWithInt:arc4random_uniform(90)]];
        }
        //删除数据
        success = [db executeUpdate:@"delete from t_man where id = ?", [NSNumber numberWithInt:1]];
        if (success) {
            
            NSLog(@"删除成功");
        }else{
            
            NSLog(@"删除失败");
            errmsg = [db lastErrorMessage];
        }
        //修改数据
        success = [db executeUpdate:@"update t_man set name = ? where id = ?", @"songyangyang", [NSNumber numberWithInt:3]];
        if (success) {
            
            NSLog(@"修改成功");
        }else{
            
            NSLog(@"修改失败");
            errmsg = [db lastErrorMessage];
        }
        //查询数据
        FMResultSet *resultSet = [db executeQuery:@"select * from t_man"];
        
        while ([resultSet next]) {
            
            NSString *name = [resultSet stringForColumn:@"name"];
            NSInteger age = [resultSet intForColumn:@"age"];
            
            Model *model = [Model modelWithName:name age:[NSString stringWithFormat:@"%ld", age]];
            [self.mDataArray addObject:model];
        }
        for (Model *model in self.mDataArray) {
            
            NSLog(@"test here");
        }
    }];
}
```

---
以下为覆盖存储，如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。
#####plist
通过XML文件的方式保存在目录，可以被序列化的类型只有如下几种：

* NSArray;
* NSMutableArray;
* NSDictionary;
* NSMutableDictionary;
* NSData;
* NSMutableData;
* NSString;
* NSMutableString;
* NSNumber;
* NSDate;
```
- (void)plist{
    
    //1. 获得文件路径
    NSString *basePath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    NSString *plistPath = [basePath stringByAppendingPathComponent:@"record.plist"];
    //2. 存储
    NSArray *writeArray = @[@"123", @"songyangyang", @"烤鸭"];
    //atomically表示是否需要写一个辅助文件，再把辅助文件拷贝到目标文件地址。如此更安全。
    [writeArray writeToFile:plistPath atomically:YES];
    //3. 读取
    NSArray *readArray = [NSArray arrayWithContentsOfFile:plistPath];
    NSLog(@"%@",readArray);
    
    //2. 存储
    NSDictionary *writeDic = @{@"shit":@"nice", @"dog":@"love", @"cat":@"mouse"};
    [writeDic writeToFile:plistPath atomically:YES];
    //3. 读取
    NSDictionary *readDic = [NSDictionary dictionaryWithContentsOfFile:plistPath];
    //会覆盖原文件
    NSLog(@"%@",readDic);
}
```
#####Preferences
专门用来保存应用程序的配置信息，偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。
```
- (void)preference{
    
    NSUserDefaults *prefercence = [NSUserDefaults standardUserDefaults];
    //写内容
    [prefercence setObject:@"songyangyang" forKey:@"name"];
    [prefercence setBool:YES forKey:@"isNice"];
    [prefercence setInteger:25 forKey:@"songyang"];
    
    //如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。
    //立即同步
    [prefercence synchronize];
    
    NSString *name = [prefercence objectForKey:@"name"];
    BOOL is = [prefercence boolForKey:@"isNice"];
    NSInteger age = [prefercence integerForKey:@"songyang"];
    
    NSLog(@"%@, %d, %ld", name, is, age);
}
```
#####NSAchiving
遵循了NSCoding协议的对象都可以通过它实现序列化。
1. 遵循NSCoding协议,实现俩个协议方法。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。
```
//遵守协议
@interface Achiving : NSObject<NSCoding>

@property (copy, nonatomic) NSString *name;
@property (assign, nonatomic) NSInteger age;
@property (strong, nonatomic) NSArray *array;

@end
```
```
如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法;

//解档
- (instancetype)initWithCoder:(NSCoder *)coder
{
    if (self = [super init]) {
        
        self.array = [coder decodeObjectForKey:@"array"];
        self.name = [coder decodeObjectForKey:@"name"];
        self.age = [coder decodeIntegerForKey:@"age"];
    }
    return self;
}
//归档
- (void)encodeWithCoder:(NSCoder *)aCoder{
    
    [aCoder encodeObject:self.name forKey:@"name"];
    [aCoder encodeObject:self.array forKey:@"array"];
    [aCoder encodeInteger:self.age forKey:@"age"];
}
```
2. 使用
```
必须遵循并实现NSCoding协议
保存文件的扩展名可以任意指定
继承时必须先调用父类的归档解档方法

Achiving *ach = [[Achiving alloc] init];
    ach.name = @"songyangyang";
    ach.age = 22;
    ach.array = @[@"shit", @23, @(YES), @"mine"];
    
    //获取文件路径，文件后缀可任意指定
    NSString *basePath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    NSString *filePath = [basePath stringByAppendingPathComponent:@"shit.data"];
    //开始归档
    [NSKeyedArchiver archiveRootObject:ach toFile:filePath];
    //开始解档
    Achiving *decodeAch = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];
    if (decodeAch) {
        
        NSString *name = decodeAch.name;
        NSArray *array = decodeAch.array;
        NSInteger age = decodeAch.age;
    }
```
