---
title: 排序算法
date: 2019-05-03 22:29:56
comments: true
toc: true
copyright: true
declare: true
top:
categories:
- 算法
tags:
- 排序
---



## 排序算法的稳定性
　　一个待排序列当中，极有可能含有相同的元素。我们暂定两个，其索引为`i, j (i<j)`。我们所说排序稳定是指，任意一趟排序后，这两个相同元素仍然保持索引不变，也就是说这两个相同值的相对位置并没有改变。反之则是不稳定的排序。

## 冒泡排序
　　给定一组数，个数为m，将下标n(n>=0&&n< m)和n+1的数进行比较，如果满足条件则交换两个数。然后继续比较下标n+1和n+2的数，并依次类推。一轮循环结束，必定能得出一个最值。然后将剩下的m-1个数按上述方法继续比较完成排序。
　　冒泡核心：紧抓相邻元素的交换。
　　稳定排序

**tip：**假定对1，2，3，4，5排序。如果使用上述算法，计算机仍然会走完每次循环，浪费时间。此时最好添加一个flag，当一轮循环中有数参与交换，则flag=1说明排序不规则需要下一次循环。如果flag=0，说明没有数需要交换，排序完成。使用flag可以节省时间。

## 选择排序
　　给定一组数，个数为m。任取一数作为标准值，与其他数进行比较。如果比该数要小(大)，则交换两个数。然后以这个新标准值继续和其他数比较。每轮循环必会选出一个最值。剩下的数继续循环，直至排序完毕。
　　相当于取3个数组：已排数(不定)、待排数(1)和未排数(不定)。每次将待排数和未排数的每个进行比较，选出一个最值放入已排数，直至结束。
　　稳定排序
　　
## 插入排序
　　给定一组数，个数为m。将第一个数认为是已排数，依次取之后的数和前面的已排数进行比较。
　　？？如果满足比较条件，将当前值和比较值进行交换，然后当前值(注意当前值的索引已经变化)继续和之前的数比较，直到移动到合适位置。
　　？？获取到合适的索引位置后，先将该索引位置及之后的数(但是在当前值之前的数)往后移，再讲当前值插入到该索引位置。
　　稳定排序

## 归并排序
　　给定一组数，个数为m。利用二分法将数组分成两部分，对分开的数组继续使用二分法递归，直到分开的数组只有一个元素。然后将分开的两个数组进行数据比较，将符合条件的元素添加到一个新的数组。新数组也将和另一个排好序的新数组比较。如此完成排序。
　　稳定排序
　　
## 快速排序
    以中值排序
　　1. 为何不使用中间index？要达到最优时间复杂度，需要保证找到的标准值恰好是中值(数学)。那数组个数/2, 拿中间index的值号了。理解出现了偏差，如果使用中间index，如何保证这个位置的值一定是中值。所以一般都以第一个和最后一个开始。
　　不稳定排序
