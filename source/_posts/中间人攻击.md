# 中间人攻击
* 一次正常RSA 加解密流程：用户发起连接请求，服务器发送公钥给客户端，客户端使用服务端公钥加密相关信息并发送给服务端。<!--more-->服务端使用私钥解密，获取信息进行验证及处理。
![rsa_authentication](https://thumbnail10.baidupcs.com/thumbnail/6bf7669a546bc64766d53acafb7eab79?fid=3174346189-250528-810165232695025&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Joo1EMuLO%2fJELdS4k8zs9xQGHTM%3d&expires=8h&chkbd=0&chkv=0&dp-logid=602324465192915813&dp-callid=0&time=1548514800&size=c1440_u900&quality=90&vuk=3174346189&ft=image&autopolicy=1)
* 中间人攻击：中间人截取用户验证请求，发送中间人公钥给客户端。客户端利用假公钥加密的信息就会被中间人解密。中间人拿到客户端信息再去和服务端交互。服务端返回的数据会先经过中间人再到用户，这样用户的数据就得不到安全保障。因为中间人可以修改用户数据。
![man_in_the_middle_attack](https://pan.baidu.com/s/1GMic1FK-0HDPBwiSw4aW9Q)

==总结一下就是：中间人对客户端是伪装服务端，对服务端伪装客户端==

#### 简单防护
* 防护 1：客户端将正常验证请求到的服务端公钥进行保存。之后发起请求时将服务端返回的公钥和本地进行匹配。匹配一致才交互。但是也有弊端，如果服务器确实更换了公钥，那么客户端将连接不上，此时需要删除客户端之前保存的公钥，这也要求服务端一定要及时通知客户端。

* 防护 2：上面的方法不能保证客户端拿到的公钥就是正确的。这时服务端可以将公钥进行一次 hash 并公布。因为数据的 hash 值是唯一的。因此客户端将拿到的公钥也进行 hash 一次，和服务器公布的 hash 比对，一致才交互。

* ··· 其他的防护再补充，想起就补充 !^_^!
