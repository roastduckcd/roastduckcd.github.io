<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AI之我见]]></title>
    <url>%2Farticle%2FAI%E4%B9%8B%E6%88%91%E8%A7%81.html</url>
    <content type="text"><![CDATA[今天看到了一篇文章。AI换头 我的第一反应是商机啊，反AI。不是反对AI，而是针对恶意使用AI出现的成果进行防护。比如你在网上看到了一段爱人的不雅视频，但实际上它是由AI合成的。目前来说AI还在发展，合成的结果肯定是有瑕疵的，只是我们的肉眼难以分辨。这时候如果能通过电脑分析发现这些瑕疵，我们就还能相信爱情。 不过本人目前技术储备不够，还实现不了这个功能。从计算机底层的角度随意瞎想了一下。首先，计算机是不能直接识别人类文化的，他有自己的机器语言。好比我们的汉字有字根一样，机器语言也有它的字根：0 和 1。是的，就只有这两个。0 和 1通过不同的排列组合，最终由计算机再翻译成人类能懂得语言或图像。 那么AI换头怎么做呢？下面一张图片，我们假设（实际上要远远复杂得多）两边的阿拉斯加雪橇狼的机器语言是：01001110，中间作者的头的机器语言是：11011100。现在要把作者的头替换成某个大美女，就是要把 11011100 这部分替换成大美女的头部：11100011。这一过程由AI采用一些列精细的算法完成。但现阶段AI仍在进步，它可能得出的是 11000011。第三个0可能由于算法的不完善没有替换掉，在这里我们很容易就发现出差异。实际上一张图片的数据是非常复杂的0和1排列，可能会出现很多这样的0没被替换掉。但是！这点差异可能就只是脸上的一个毛孔。人眼能发现吗？难吧！于是本来作者和作者的狗，变成了美女和作者的狗，美女的狗肯定不乐意了呀。 那怎么反AI呢？就是拿到美女的真实头像，然后去分析出这些差异，当这些差异达到某个阈值的时候，我们相对认为这是一张合成的图片。当然，这个过程必然也是由AI来完成。随着技术的进步，不良AI使用者会进一步减少差异的出现，这样就压缩了反AI的空间，导致不得不降低识别阈值，导致误判的增加。AI继续进步，直到理论上能完全替换，反AI将无法识别图片是否是合成的。 于是眼见也不一定为实！！！是否有些可怕？那怎么去看待AI呢？ 我想到一个大家非常熟悉的人：艾尔波特·爱因斯坦。史料记载，原子弹是德国率先研发的。核裂变产生的巨大能量是现今清洁能源的重要来源之一，可是我们也无法忘记广岛、长崎巨大的蘑菇云，还有切尔诺贝利荒凉的遗址。 史料记载，爱因斯坦后悔造出了原子弹。 我无法评价原子能，因为也许用过核电厂发出的电。 我也无法评价AI，我可能还要靠它找工作。 AI也一直在融进我们的生活。AI相机，AI翻译，AI汽车机器人···尽管有些只是营销用的噱头，但我们不可忽视AI的燎原之势。曾有人提问AI是否会取代人工作？我对这点持悲观态度，尽管科技公司大佬澄清不会出现这样的情况。我认为只是现在以及将来的有限时间内不会。AI算法会越来越完善，当它能完成人能做的事时，取代人进行工作是必然的。要知道，资本是逐利的，付款一次，就能使用终身。AI不要工资，效率比人工更高，老板不会放着钱不赚的。因此，一部分人的工作势必会丢掉，而对于一些底层人员，恐怕将是一次沉重的打击。 技术无罪，人有界。]]></content>
      <categories>
        <category>gossip</category>
        <category>个人随想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路10-纹理（下）]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF10-%E7%BA%B9%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89.html</url>
    <content type="text"><![CDATA[使用普通纹理可能产生的问题 闪烁问题 被渲染物体和使用的纹理相比很小 纹理采样区域的移动幅度和它在屏幕的大小不成比例 处于运动状态比较容易看到该现象 性能问题 加载过大的纹理并进行过滤，屏幕实际只显示很少的一段。纹理越大，性能影响越明显。 解决方案：使用更小的纹理。 新的问题 如果拉近物体，由于物体会被渲染的比原来更大，原来的纹理采样点不够。不得不对纹理进行拉伸，可能造成物体更模糊。 解决方案：使用 Mip 贴图。 MIP 贴图 MipMap: 多级渐远纹理。 多用在复杂场景，比如游戏等。在应用开发中较少涉及。 如果物体很远，产生的片元可能很少。而它却又有一张和近处物体同样高分辨率的纹理。在获取纹理时，GL可能需要跨越很大一段纹理才能取到片元坐标对应的纹理。这可能造成在小物体上产生不真实的感觉，同时这一部分高分辨率也浪费了内存空间，并且降低了性能。 Mip贴图纹理由一系列纹理图像组成，每个图像大小在(s,t)每个轴的方向上都缩小一半（前一个图像的1/4），直到最后一个图像为 1 * 1 的单元 。OpenGL 会使用一组新的过滤方式，为不同距离的物体选择出最合适的纹理。 12参数：GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3DglGenerateMipmaps(GL_TEXTURE_2D); 使用 只有 纹理参数中设置 的过滤方式 GL_TEXTURE_MIN_FILTER 为以下四种才可以生成 Mip 贴图。 GL_NEAREST_MIPMAP_NEAREST: 性能非常好，闪烁现象最弱 GL_LINEAR_MIPMAP_NEAREST: 常用于对游戏加速 GL_LINEAR_MIPMAP_LINEAR和GL_NEAREST_MIPMAP_LINEAR: 过滤器在 Mip 层之间进行了额外插值，以消除过滤痕迹 GL_LINEAR_MIPMAP_LINEAR 为三线性贴图，具有最高精度 函数原型 1void glGenerateMipmap(GLenum target); 为指定纹理对象生成Mipmap贴图。target 为纹理类型，一般取值GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D。纹理对象在绑定纹理.html#绑定纹理状态)时已经被指定。 各向异性过滤 当对一个几何图形进行纹理贴图，如果观察方向和纹理表面恰好垂直（各向同性过滤），那么能得到最好的效果。但是当从一个倾斜角度观察时，对纹理单元仍进行常规（各向同性过滤）采样，会导致一些纹理信息丢失，表现为图像模糊。 因此在纹理过滤时，还需要考虑观察角度，这种方式就叫各向异性过滤。 由于我们经常对物体使用仿射变换，间接改变观察方向，因此各向异性过滤应该一直应用到程序中。 使用步骤 获取支持的各向异性过滤的最大数量 12GLfloat fLargest;glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &amp;fLargest); 设置各向异性过滤数据 12345//设置纹理参数(各向异性过滤)glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAX_ANISOTROPY_EXT,fLargest) 􏰚// 恢复为各向同性过滤，1.0表示各向同性过滤glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 1.0f); 数值设置越大，沿最大变化方向（最强观察方向）所采样的纹理单元就越多。 设置该项纹理参数，会对性能有一定影响。但对现在硬件性能，其影响可以忽略。]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>纹理</tag>
        <tag>MipMap</tag>
        <tag>各向异性过滤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路9-纹理（上）]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF9-%E7%BA%B9%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89.html</url>
    <content type="text"><![CDATA[纹理即图像 包含原始bit数据的图片叫位图。由于位图占用空间大，因此通常经过一系列算法剔除不影响人眼观察的bit，这个过程叫压缩。常见png、jpg都属于压缩后的图片。 图片的存储字节数 = 图片宽度 图片高度 每个像素占用内存的字节数 图片就是一组RGBA颜色集合。 颜色值表示：RGBA 一个颜色通道占用 1 byte。 标注纹理文件 .tga: 以一个字节接一个字节存储。 其他压缩图片格式如 png、 jpg 也能作纹理。 纹理坐标 纹理坐标是作为0.0到1.0范围内的浮点值指定的。纹理坐标命名为s、t、r和q，支持从一维到三维纹理坐标，通常使用2维（s、t）。q 和 齐次坐标中的 w 一样，一般为 1。 纹理贴图左下角为原点(0,0)，向右为+x，向上为+y。但是实际上原点位置并不重要，贴图时纹理坐标可以不用和模型坐标一一对应，但是纹理坐标不能交叉映射。 可以类比装修贴墙纸，可以选择上下左右颠倒，但是一般不会把正面贴到墙上。 纹理使用流程􏰗􏰘􏲆􏲇分配纹理对象 1void glGenTextures(GLsizei n, GLuint *textTures); n: 纹理对象数量(图片数量) texTures: 纹理坐标数组，初始化时由纹理标识符填充。 绑定纹理状态 1void glBindTexture(GLenum target, GLunit texture); target: 纹理模式(GL_TEXTURE_1D、GL_TEXTURE_2D(常用)···) texture: 要绑定的纹理对象数组 加载纹理坐标（上面的纹理数组） 读取 tga 文件 1GLbyte *gltReadTGABits(const char *szFileName, GLint *iWidth, GLint *iHeight, GLint *iComponents, GLenum *eFormat); 函数实现 szFileName: 纹理文件名称 iWidth, iHeight: 文件宽度、高度 iComponents: GL_RGB, GL_RGBA, GL_LUMINANCE 中的一种 eFormat: GL_RGB, GL_BGRA, GL_BGR, GL_LUMINANCE中的一种 返回值: 指向图像数据的指针 从颜色缓存区内容作为像素图直接读取。OpenGL 无法直接将一个像素图绘制到颜色缓冲区中，但是可以使用下面的函数将颜色缓冲区的内容作为像素图直接读取。 1void glReadPixels(GLint x,GLint y,GLSizei width,GLSizei height, GLenum format, GLenum type,const void * pixels); x, y: 矩形左下⻆角的窗口坐标 width, height: 矩形的宽，高。以像素为单位 format: 指定pixels指向的数据元素的颜色布局。OpenGL 的像素颜色布局 type: 解释参数 pixels 指向的数据，告诉OpenGL 使用缓存区中的什么数据类型来存储颜⾊分量OpenGL像素数据类型。该函数从图形硬件中复制数据，通常通过总线传输到系统内存。在这种情况下，应用程序将被阻塞，直到内存传输完成。 pixels: 指向图形数据的指针 设置纹理参数 函数原型 12345// 浮点型void glTexParameterf(GLenum target,GLenum pname,GLFloat param);void glTexParameteri(GLenum target,GLenum pname,GLint param);void glTexParameterfv(GLenum target,GLenum pname,GLFloat *param);void glTexParameteriv(GLenum target,GLenum pname,GLint *param) target: 纹理模式(GL_TEXTURE_1D、GL_TEXTURE_2D(常用)···) pname: 要设置的纹理参数 param, *param: 纹理参数的值，可以是数组？ 参数一：设置纹理在 s、t r轴上的环绕方式。 纹理坐标表示(s, t, r, q) 对照笛卡尔坐标系 (x, y, z, w)。模型上纹理不能填满模型时显示的方式，类似平铺、复制等。 123glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); 对应图像 参数二：纹理过滤，影响颜色显示质量。 GL_NEAREST: 邻近过滤，选取离像素点最近的纹理。如果放大到一定程度，颜色有明显分界（像素方块）。 GL_LINEAR: 线性过滤，将像素点周围颜色混合后作为纹理。相同缩放程度下，线性过滤颜色更加平滑。但是性能消耗更多。 当一个纹理贴图被过滤时，GL使用纹理坐标判断一个几何片元对应纹理的什么地方。然后对紧邻该位置的纹理单元使用邻近或线性过滤。 综合性能和显示质量，一般纹理放大时选择线性过滤；纹理缩小时选择邻近过滤。 1234567891011 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); ``` * 最后4个选项只能在 `GL_TEXTURE_MIN_FILTER` 下生效。如果在 `GL_TEXTURE_MAG_FILTER` 下使用会产生`GL_INVALID_ENUM`类型的错误代码。 ![opengl_texture_filter_option](https://i.loli.net/2019/06/19/5d09c9337144259246.jpg)###### 参数三：对 Mipmap 层的限制* [Mipmap相关](http://roastduck.xyz/article/OpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF10-%E7%BA%B9%E7%90%86(%E4%B8%8B).html)* 对下一步[载入纹理](#载入纹理)中参数 level 的限制。* 设置 mip 贴图使用的基层和最大层。 // 设置 mip 最小使用哪层 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0); // 设置 mip 最多使用层数 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, n); // 在上面已经限制的基础上再进行限制，功能貌似重复 // 最小加载的mip层 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_LOD, n) // 最大加载的mip层 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LOD, n) 1234567891011##### 载入纹理* ```c++ void glTexImage1D(GLenum target,GLint level,GLint internalformat,GLsizei width,GLint border,GLenum format,GLenum type,void *data) // 常用 2D void glTexImage2D(GLenum target,GLint level,GLint internalformat,GLsizei width,GLsizei height,GLint border,GLenum format,GLenum type,void * data); void glTexImage3D(GLenum target,GLint level,GLint internalformat,GLSizei width,GLsizei height,GLsizei depth,GLint border,GLenum format,GLenum type,void *data); target: 纹理模式(GL_TEXTURE_1D、GL_TEXTURE_2D(常用)、GL_TEXTURE_3D···) level: 指定所加载的mip贴图层次，非mipmap纹理level设置为0，mipmap设置为mipmap纹理的层级（mipmap的图像数量）。 internalformat: 每个纹理单元中存储多少颜⾊成分。 指定了纹理存储在显存中的内部格式？ internalFormat用来指定OpenGL中纹理单元中的格式是什么样的，而参数中的后三个(format 、type、 data)是用来指定传输到OpenGL中纹理单元数据的格式是怎么样的。 后三个参数描述了图片在内存中的存储方式。 csxiaoshui OpenGL API 之 glTexImage2Dblog.csdn.net/csxiaoshui/article/details/27543615 链接最后的示例貌似有问题？ width, height, depth: 指加载纹理的宽度、⾼高度、深度。 这些值必须是 2 的整数次方。(OpenGL 旧版本要求，现在可以不是。但是开发者习惯使用以2的整数次⽅去设置这些参数。 border: 允许为纹理贴图指定一个边界宽度。2D中必须是0。 format: 每一个像素所包含的成分以及这些成分的顺序。OpenGL 的像素颜色布局 type : 每一个成分需要几个字节来表示。OpenGL像素数据类型 data : 实际指向的数据是什么 OpenGL APIglTexImage2D的详细说明 测试纹理对象是否有效 texture 如果被分配空间，则返回 true，否则为 false。 1GLboolean glIsTexture(GLuint texture); 程序退出时（glMainLoop()之后）删除绑定纹理对象 1void glDeleteTextures(GLsizei n,GLuint *textures); 其他函数 改变和恢复像素存储方式 1234// 改变void glPixelStorei(GLenum pname,GLint param)// 恢复void glPixelStoref(GLenum pname,GLfloat param) 参数1: 指定 OpenGL 如何从数据缓存区中解包图像 数据。GL_UNPACK_ALIGNMENT不进行字节对齐 参数2: 表示参数 GL_UNPACK_ALIGNMENT 设置的值。 GL_UNPACK_ALIGNMENT 指内存中每个像素行起点的排列请求，允许设置为1 (byte排列)、2(排列为偶数byte的⾏)、4(字word排列)、8(行从双字节边界开始) 缓冲区操作 改变这些像素操作的源。参数可以取GL_FRONT、GL_BACK、GL_LEFT、GL_RIGHT、GL_FRONT_LEFT、GL_FRONT_RIGHT、GL_BACK_LEFT、GL_BACK_RIGHT或者甚至是GL_NONE中的任意一个。 1234// 指定读取的缓存 glReadBuffer(mode);// 指定写⼊入的缓存glWriteBuffer(mode); 更新纹理 12345void glTexSubImage1D(GLenum target,GLint level,GLint xOffset,GLsizei width,GLenum format,GLenum type,const GLvoid *data);void glTexSubImage2D(GLenum target,GLint level,GLint xOffset,GLint yOffset,GLsizei width,GLsizei height,GLenum format,GLenum type,const GLvoid *data);void glTexSubImage3D(GLenum target,GLint level,GLint xOffset,GLint yOffset,GLint zOffset,GLsizei width,GLsizei height,GLsizei depth,Glenum type,const GLvoid * data) 替换纹理 替换一个纹理图像要比直接使用glTexImage系列函数重新加载一个新纹理快得多： 12345void glCopyTexSubImage1D(GLenum target,GLint level,GLint xoffset,GLint x,GLint y,GLsize width);void glCopyTexSubImage2D(GLenum target,GLint level,GLint xoffset,GLint yOffset,GLint x, GLint y,GLsizei width,GLsizei height)void glCopyTexSubImage3D(GLenum target,GLint level,GLint xoffset,GLint yOffset,GLint zOffset,GLint x,GLint y,GLsizei width,GLsizei height) 使⽤颜色缓存区加载数据,形成新的纹理使⽤。源缓冲区通过 glReadBuffer函数指定。 123void glCopyTexImage1D(GLenum target,GLint level,GLenum internalformt,GLint x,GLint y,GLsizei width,GLint border)void glCopyTexImage2D(GLenum target,GLint level,GLenum internalformt,GLint x,GLint y,GLsizei width,GLsizei height,GLint border) x, y, width, height: 指定读取颜色缓冲区的范围。 OpenGL 像素颜色布局 GL_RGB纹理读取数据且顺序为R、G、B。GL_BGRA纹理读取数据且顺序为B、G、R、A。 RGBA顺序转换12345678// R G B R G B// 0 1 2 3 4 5for(int i=0; i&lt;ImageSize; i+=3)&#123; GLbyte temp=pBits[i]; pBits[i]=pBits[i+2]; pBits[i+2]=temp;&#125;&gt; OpenGL 像素数据类型 GL_(UNSIGNED_)BYTE​: 指 R、G、B、A各占 1 byte。 GL_UNSIGNED_BYTE_3_2_2 根据 format 指定的颜色成分确定分量。比如 format 指定为 GL_RGB。 GL_UNSIGNED_BYTE_2_3_3_REV REV 表示反转。还是以 format 为 GL_RGB。 相关链接 http://www.it165.net/pro/html/201607/71996.html]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>纹理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路8-向量和矩阵]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF8-%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B5.html</url>
    <content type="text"><![CDATA[GLTools 提供的数学计算库：&quot;math3d.h&quot; 以下变量声明如不额外指出，都来自该库。 向量 向量：具有方向和大小，坐标表示为（x, y, z）（从原点出发）。 M3DVector3f：表示向量(x, y, z） M3DVector4f：表示向量(x, y, z, w)，w为x, y, z的缩放因子，通常为1.0。 12345678// 声明并初始化一个4维变量M3DVector4f vVectro= &#123;0.0f,0.0f,1.0f,1.0f&#125;;// 声明⼀一个三分量顶点数组M3DVector3f vVerts[] = &#123; -0.5f,0.0f,0.0f, 0.5f,0.0f,0.0f, 0.0f,0.5f,0.0f&#125;; 矩阵原理 由 m × n 个数排成的m行n列的数表称为m行n列的矩阵，简称m × n矩阵。 矩阵的转置：将矩阵逐行变成列，就矩阵的转置矩阵。 行矩阵矩阵和列矩阵。不同系统对矩阵存储的方式不一样。 行矩阵：逐行存储的矩阵, windows D3D 采用 $ \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \ 0&amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 \ x &amp; y &amp; z &amp; 1 \end{bmatrix}$ 列矩阵：逐列存储的矩阵, OpenGL 采用 $ \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; x \ 0&amp; 1 &amp; 0 &amp; y \ 0 &amp; 0 &amp; 1 &amp; z \ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}$ 行矩阵和列矩阵互为转置。 OpenGL中矩阵的行主序与列主序 OpenGL 中列矩阵表示 typedef float M3DMatrix33f[9]：3 * 3 矩阵 typedef float M3DMatrix33f[16]：4 * 4 矩阵（齐次坐标） 计算法则点乘 一个向量和它在另一个向量上的投影的长度，是标量（无方向）。 $\underset{a}{\rightarrow} \underset{b}{\rightarrow} = |a| |b| * cos(\Theta )$ u=(u1,u2,u3) v=(v1,v2,v3) $u * v = u_1v_1+u_2v_2+u_3v_3$ 函数形式: 结果由返回值接收 12345// 返回值范围 -1 ~ 1float m3dDotProduct3(const M3DVector3f u,const M3DVector3f v)// 返回两个向量间的弧度值float m3dGetAngleBetweenVector3(const M3DVector3f u,const M3DVector3f v) 向量的叉乘 结果是一个新的向量，称为向量积(法向量)，它垂直于相乘的a、b两向量所构成的平面。方向由右手法则得出。 如果a，b互相垂直，那么和叉乘得出的法向量就能构成一个三维坐标系统。 $\underset{a}{\rightarrow} \times \underset{b}{\rightarrow} = |a| |b| sin(\Theta )$，方向垂直向量a和b组成的平面。 u=(u1,u2,u3) v=(v1,v2,v3) $u \times v = ( u_2v_3 - v_2u_3 , u_3v_1 - v_3u_1, u_1v_2 - u_2v_1)$ 函数形式：结果通过参数指针传递 1void m3dCrossProduct3(M3DVector3f result, const M3DVector3f u, const M3DVector3f v) 矩阵乘法 第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才能进行。 计算规则就是矩阵a的第一行乘以矩阵b的第一列，各个元素对应相乘然后求和作为第一元素的值 矩阵是没有叉乘一说的。 matlab里矩阵叉乘表示的是构成矩阵的列向量分别做叉乘后所得列向量再组成的矩阵。例如（用matlab的格式） a1,a2,a3为三维列向量，b1,b2,b3为三维列向量 A = [a1,a2,a3]; B = [b1,b2,b3]; 那么 cross(A,B) 也即楼主说的A和B的叉乘结果为： [cross(a1,b1), cross(a2,b2), cross(a3,b3)] 别拦着我逃学 百度知道回答中的评论zhidao.baidu.com/question/154361626.html OpenGL 中的矩阵 OpenGL中的坐标变换都是通过矩阵运算完成的，与图形学的描述完全一致。要注意的是变换中的矩阵乘法是右乘。 变换术语 视图：观察者或摄像机的空间位置，对应视图矩阵 视图变换：移动观察者或摄像机来观察物体 实际开发者并不操作，只是为了方便理解。 模型：物体的空间位置，在场景中移动物体，对应模型矩阵 模型变换：操作模型和其中特定的对象，对模型进行仿射变换。由于矩阵乘法不遵守结合律，所以变换顺序不同，结果也不一样。 实际开发者并不操作，只是为了方便理解。 模型视图：描述视图和模型变换的二元性 模型视图变换：模型变换和视图变换在管线中的集合。由于两种变换是相对的，有时两种变换分别得到的效果是一样的（比如使看到的物体变小，可以将视图沿+z平移，或者将模型沿-z平移）。 由于模型对应的物体坐标系只针对某个物体模型本身，而视图针对所有的模型。所以视图变化会影响所有模型，而模型变换只影响自身。 开发者实际操作，对应的模型视图矩阵是同时对所有模型有效的。 投影：改变视景体大小或重新设置它的形状 投影变换：将经过模型视图变换后的3维顶点转换为2位坐标。这种投影定义了视景体并创建了裁剪平面。 两种投影方式：正交投影和透视投影 开发者实际操作。 视口：这是伪变化，只是对窗口上的最终输出进行缩放 视口变换：投影变换后的坐标转换到屏幕坐标系中。 关于几个变换矩阵的理论映射关系 顶点变换管线模型视图矩阵和投影矩阵由开发者传入，透视除法和视口变换由GL内部完成。 OpenGL 中的照相机和物体 使用 GLFrame 对象描述世界坐标系中的相机和物体。 GLFrame叫参考帧，其中存储了1个世界坐标点和2个世界坐标下的方向向量，也就是9个glFloat值，分别用来表示：当前位置点，向前方向向量，向上方向向量。 GLFrame可以表示世界坐标系中任意物体的位置与方向。无论是相机还是模型，都可以使用GLFrame来表示。对任意一个使用GLFrame来表示的物体而言，涉及到的坐标系有两个：永远不变的世界坐标系，针对于自身的物体坐标系(即绘图坐标系)。 超频化石鱼 OpenGL自定义相机与模型：GLFrameblog.csdn.net/fyyyr/article/details/79298664 123456789class GLFrame &#123; protected: // Where am I? 位置坐标 M3DVector3f vOrigin; // Where am I going? 前进方向，Z 轴方向 M3DVector3f vForward; // Which way is up? Y 轴方向 M3DVector3f vUp; &#125; Y轴向量和Z轴向量进行叉乘，得到X轴向量。 虽然都是 M3DVector3f 类型，但是 vOrigin 只表示一个坐标点。而 vForward 和 vUp 表示的是向量，有距离和方向（原点出发到该点）。 相机默认位于世界坐标系原点，观察方向为世界坐标系-Z，前进方向为 -Z，向上为世界坐标系+Y，向右为世界坐标系+X。相机本身坐标系垂直屏幕向右为+X，向上为+Y，屏幕相离为+Z（Z轴方向和世界坐标系相反）。一般绘制开始时将其远离物体，向世界坐标系+Z方向移动，即相机坐标系-Z方向移动。 1void GLFrame::GetCameraMatrix(M3DMatrix44f m,bool bRotationOnly = flase); 该函数就是将相机坐标系转换到世界坐标系。由于Z轴方向不一致，过程就是对相机先做一次旋转（Z轴的反转），再做一次平移（相机和世界坐标系是相对运动的，因此函数实现中会看到取负数）。 物体默认位于世界坐标系原点，与世界坐标系重合。 12// 用来生成模型矩阵void GLFrame::GetMatrix(M3DMatrix44f matrix, bool bRotationOnly = false) GLFrame 变换成矩阵时的对应位置，记住OpenGL中矩阵是列主序。 X轴方向向量由 Y 叉乘 Z 得到，T 表示平移即 vOrigin。 OpenGL 矩阵栈 为了方便管理和应用变换矩阵，通常使用矩阵栈 GLMatrixStack.h。顶点的变换（平移、缩放等）通过和栈顶的变换矩阵相乘实现。OpenGL 为模型视图矩阵和投影矩阵各维护一个矩阵堆栈。栈顶就是当前坐标变换矩阵，进入OpenGL管道的每个坐标(齐次坐标)都会先乘上这个矩阵，结果才是对应点在场景中的世界坐标。 入栈与出栈 以矩阵2为基础状态，物体A应用矩阵3变换。先复制矩阵2并压栈，以此保存原来状态，便于快速回到基础状态。然后矩阵2 矩阵3，得到最终变换矩阵，新矩阵会覆盖掉栈顶矩阵。物体A应用新的变换后，将当前栈顶矩阵出栈，恢复到基础状态。*压栈和出栈必须成对。 每次变换是以世界坐标系的原点为参考点（顶点数据以世界坐标系）进行。也就是要固定世界坐标系，使用模型视图变换来移动物体。 2）OpenGL物体建模实际上是分两步走的。第一步，在世界坐标系的原点位置绘制出该物体；第二步，通过modelview变换矩阵对世界坐标系原点处的物体进行仿射变换，将该物体移动到世界坐标系的目标位置处。 chriszeng87 OpenGL使用矩阵堆栈glpushMatrix的原因chriszeng87.iteye.com/blog/2125018 记住模型视图变换是全局有效的。如果我们换一个角度，从物体角度看，相当于世界坐标系变换了。物体A应用一个变换A后，世界坐标系变换；继续绘制物体B，B就被绘制在变换后的原点上。由于我们给出的变换B仍是以原世界坐标系为参照，现在对物体B应用变换B，实际上物体B应用的是变换A*变换B。因此每次变换后需要pop栈顶矩阵，恢复原来的世界坐标系。反过来说，以世界坐标系为参照，就是要恢复模型视图矩阵。？？ 如果不先复制栈顶其实也可以，保存新的变换矩阵，在恢复时求出新变换矩阵的逆矩阵，再乘回去，也能得到变换前的矩阵。但是吃力不讨好。 典型渲染循环 函数解析 初始化 12GLMatrixStack modelViewMatrix;GLMatrixStack projectionMatrix; 这里是 c++ 对象的隐式初始化，会自动调用下面的构造函数 12// 构造函数，默认栈深度64GLMatrixStack::GLMatrixStack(int iStackDepth = 64); 加载或重置栈顶矩阵。一般只使用 LoadIdentity，通常使用后面的 push。 123456789// 用单元矩阵重置栈顶矩阵void GLMatrixStack::LoadIdentity(void);// 用任意矩阵重置栈顶矩阵// 参数:4*4矩阵void GLMatrixStack::LoadMatrix(const M3DMatrix44f m);// 将 GLFame 转换为矩阵，再重置栈顶矩阵void GLMatrixStack::LoadMatrix(GLFrame &amp;frame); 入栈和出栈 1234567891011// 栈顶矩阵复制后，再重新放到栈顶（保存变换状态）void GLMatrixStack::PushMatrix(void);// 将矩阵压入栈顶void PushMatrix(const M3DMatrix44f mMatrix);// 将 GLFame 转换为矩阵，再压⼊栈顶void PushMatrix(GLFame &amp;frame);// 出栈(移除栈顶矩阵，恢复之前保存的变换状态) void GLMatrixStack::PopMatrix(void); 栈顶矩阵乘法 12345// 矩阵乘以栈顶矩阵，相乘结果覆盖原栈顶矩阵void GLMatrixStack::MultMatrix(const M3DMatrix44f);// 将 GLFame 转换为矩阵，再乘以栈顶矩阵，相乘结果覆盖原栈顶矩阵void GLMatrixStack::MultMatrix(GLFrame &amp;frame); 获取栈顶矩阵 1234// 栈顶矩阵作为返回值const M3DMatrix44f &amp; GLMatrixStack::GetMatrix(void);// 使用形参接收栈顶矩阵void GLMatrixStack::GetMatrix(M3DMatrix44f mMatrix); 仿射变换 1234567// 旋转 // 参数 angle 是传递的度数，不是弧度值void MatrixStack::Rotate(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);// 平移void MatrixStack::Translate(GLfloat x, GLfloat y, GLfloat z);// 缩放void MatrixStack::Scale(GLfloat x, GLfloat y, GLfloat z);]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>矩阵栈</tag>
        <tag>矩阵变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路7-混合]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF7-%E6%B7%B7%E5%90%88.html</url>
    <content type="text"><![CDATA[不开启混合时，新片元的颜色值只是简单替换颜色缓冲区的值；如果开启了深度测试，深度值小的片元颜色替换颜色缓冲区的值。 混合常⽤于实现在其他一些不透明的物体前面绘制一个透明物体的效果。模型使用了透明度时，一定要使用混合，否则颜色会不正常。代码？？ 像素颜色，先看深度值，再根据透明度使用混合方程式计算颜色。不透明应该不计算？ 混合和深度无关。计算的是像素点的颜色，最终放到颜色缓冲区。 关闭混合，透明度会失效。 混合能有限度的抗锯齿。 开启混合后，新片元颜色值和颜色缓冲区值默认按以下方程式混合。 $C_f = (C_s * S) + (C_d * D)$ （默认方程式） Cf : 最终计算参数的颜⾊ Cs : 源颜⾊，新片元的颜色值 Cd : 目标颜⾊，颜色缓冲区的颜色值 S : 源混合因⼦ D : 目标混合因⼦ 具体计算由 OpenGL 内部完成，开发者只需要指定函数参数选项。OpenGL会根据选项查表代入方程式求解。 其他混合方程式: 使用函数glbBlendEquation(GLenum mode)可以指定以下混合方程式。 $C_f = (C_s * S) + (C_d * D)$ 对应选项为 GL_FUNC_ADD $C_f = (C_s * S) - (C_d * D)$ 对应选项为 GL_FUNC_SUBSTRACT $C_f = (C_s * D) - (C_d * S)$ 对应选项为 GL_FUNC_REVERSE_SUBSTRACT $C_f = min(C_s, C_d)$ 对应选项为 GL_MIN $C_f = max(C_s, C_d)$ 对应选项为 GL_MAX 相关函数 12345678910111213141516171819// 开启混合glEnable(GL_BlEND)// 设置混合方程式，默认 GL_FUNC_ADDglbBlendEquation(GLenum mode)// 设置混合常量颜色，默认黑色glBlendColor(GLclampf red ,GLclampf green ,GLclampf blue ,GLclampf alpha );// 设置混合因⼦的一种方式，具体值需要查表调用函数// S : 源混合因⼦ // D : 目标混合因⼦glBlendFunc(GLenum S,GLenum D)// 设置混合因⼦更灵活的方式，具体值需要查表调用函数// strRGB : 源颜色的混合因⼦ // dstRGB : 目标颜色的混合因⼦// strAlpha : 源alpha的混合因子// dstAlpha : 目标alpha的混合因子glBlendFuncSeparate(GLenum strRGB,GLenum dstRGB ,GLenum strAlpha,GLenum dstAlpha) R、G、B、A 代表红绿蓝和alpha。 下标s、d代表源、目标。 下标c代表常量颜色，默认黑色。使用glBlendColor函数指定。 混合方程式计算示例 123456789101112下面通过一个常⻅的混合函数组合来说明问题:glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 如果颜色缓存区已经有一种颜色红色 Cd : (1.0f,0.0f,0.0f,0.0f)如果在这上面⽤一种alpha为0.6的蓝色 Cs : (0.0f,0.0f,1.0f,0.6f)S、D 的值根据参数查表S = 源alpha值 = 0.6fD = 1 - 源alpha值= 1-0.6f = 0.4f方程式Cf = (Cs * S) + (Cd * D) = (Blue * 0.6f) + (Red * 0.4f)]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>混合blend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路6-隐藏面消除和深度测试]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF6-%E9%9A%90%E8%97%8F%E9%9D%A2%E6%B6%88%E9%99%A4%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95.html</url>
    <content type="text"><![CDATA[隐藏面：观察者看不见的部分，比如电脑屏幕的背面，较近物体挡住的较远物体的部分。既然看不见，对于这部分的顶点数据，就没必要渲染，应该提早裁减以提高性能。这种操作就是隐藏面消除(Hidden surface elimination)。 消除隐藏面的几种方法 油画法 正背面剔除法 油画法(不使用) 先渲染离观察者较远的物体，再渲染较近的。需要先对物体距观察者距离进行排序，然后从最远的物体开始。 但是如果物体之间不能确定距离大小，比如交叉重叠的物体。这种情况油画法无法处理。同时油画法会处理一个物体所有顶点数据，没有对看不到的进行裁剪，性能上达不到最优。所以这种方式并没使用。 正背面剔除法 Face Culling相关原理 对于n面物体，某一时刻肯定有我们看不到的面，比如3维6面物体，某一时刻我们最多只能看到3个面。将这些看不到的面的数据剔除，能极大的提高渲染效率。 如何判断一个物体的正背面呢？ 在OpenGL中默认按逆时针环绕组成的面为正面，反之为背面。但是也可以通过函数指定正面环绕形式。 环绕：顶点顺序和顶点连线方向一致形成平面的方式。{a,b,c} 12// 指定哪种环绕方式为正面void glFrontFace(GLenum mode); mode参数为: GL_CW(顺时针), GL_CCW(逆时针),默认值:GL_CCW 同时我们还要注意观察点位置。因为对于同一个面，观察点在一侧假设看到的是逆时针，在另一侧观察则是顺时针。 确定好以上两点，OpenGL 会自行判断哪些点是正面，只对正面进行渲染。 相关函数1234567// 开启表面剔除void glEnable(GL_CULL_FACE);// 关闭表⾯剔除void glDisable(GL_CULL_FACE);// 用户选择剔除正⾯/背⾯，GL_FRONT, GL_BACK(默认), GL_FRONT_AND_BACK。void glCullFace(GL_BACK); front 和 back 是相对于摄像机，或者以人眼看向屏幕。 示例: 剔除正面？？的两种方式12345678// 直接指定glCullFace(GL_FRONT);// 间接指定// 指定顺时针环绕方式为正面glFrontFace(GL_CW);// 剔除远的背面glCullFace(GL_BACK); ![opengl_cull_front_two_ways](media/opengl_cull_front_two_ways.jpg) * `GL_FRONT` 指 NMPQ，`GL_BACK` 指 BADC。这是相对于摄像机镜头的，不会变动。 * 当使用默认环绕方式，NMPQ 为正面。正面和GL_FRONT重合。使用GL_FRONT。 * 当指定顺时针环绕为正面时，BADC为正面，NMPQ为背面。所以剔除GL_BACK。 深度测试相关原理 深度就是像素点在世界坐标Z轴上的绝对值，表示离摄像机的距离，深度越大，距离越远。注意深度是针对渲染区域的所有像素点，而不是物体顶点。 为什么使用深度？避免油画法需要固定物体渲染顺序的问题。油画法渲染必须先远后进，才能达到较近物体挡住较远物体的效果。使用了深度后，渲染顺序就不再重要。OpenGL 只会渲染深度值小的像素。 专门存储当前渲染区域像素深度值的内存区域叫深度缓冲区。只要存在深度缓冲区，当前像素的深度值就会被写入。可以使用函数 glDepthMask(GL_FALSE)来禁⽌写⼊。 深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后。现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。片段着色器通常开销都是很大的，所以我们应该尽可能少运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。···这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。cqltbe131421 opengl学习之路十六，深度测试blog.csdn.net/cqltbe131421/article/details/82906652 深度缓冲区(Depth Buffer)和颜色缓冲区(Color Buffer)是一一对应的。前者存储已绘制的像素的深度值，后者存储已绘制的像素的颜色。绘制像素之前，对于每个新的输入片元，将其深度值和深度缓冲区中存储的已绘制像素点的深度值比较，如果新的深度值小于缓冲区的，就会使用新片元信息替换掉深度缓冲区和颜色缓冲区的值，并且绘制出新像素。反之则会放弃新像素的信息，继续使用深度缓冲区和颜色缓冲区存储的值。这个过程就是深度测试。 这些过程都是在一轮渲染迭代中，图中分步进行表示的是不同物体顶点处理的先后顺序。 深度测试默认是关闭的。 深度值的计算 深度缓冲是由窗口系统自动创建的。深度值一般由16 bit、24 bit或32 bit表示。通常是24 bit。位数越多，精度越高。深度值范围一般为[0,1]。 一种计算方式 $depth=\frac{z - near}{far - near}$ z为坐标值；near为摄像机到近裁面距离；far为摄像机到远裁面距离；near&lt;z&lt;far。 当near和far确定时，深度值和Z值成正比关系。所有点的精度都是一样的。 但是现实生活中观察物体，越远的物体越模糊。我们能分辨眼前花朵纹路，不会去关心远处大楼上商标的笔画。因此越远的物体，精度可以降低，减少运算性能的消耗。 因此我们采用的方程是非线性的。 $depth = \frac{1/z - 1/near}{1/far - 1/near}$ 由上图可以直观看出非线性关系的走势。要注意深度值0.5的值并不代表着物体的z值是位于可视区域的中间。 深度测试的问题: Z-Fighting 预防为主，一般在大型OpenGL项目会碰到的多。 当深度值精确度很低时，容易引起ZFighting现象，表现为两个物体靠的很近时确定谁在前，谁在后时出现了歧义。···1.不要将两个物体靠的太近，避免渲染时三角形叠在一起。这种方式要求对场景中物体插入一个少量的偏移，那么就可能避免ZFighting现象。例如上面的立方体和平面问题中，将平面下移0.001f就可以解决这个问题。当然手动去插入这个小的偏移是要付出代价的。2.尽可能将近裁剪面设置得离观察者远一些。上面我们看到，在近裁剪平面附近，深度的精确度是很高的，因此尽可能让近裁剪面远一些的话，会使整个裁剪范围内的精确度变高一些。但是这种方式会使离观察者较近的物体被裁减掉，因此需要调试好裁剪面参数。3.使用更高位数的深度缓冲区，通常使用的深度缓冲区是24位的，现在有一些硬件使用使用32位的缓冲区，使精确度得到提高。 The fool OpenGL学习脚印：深度测试(depth testing)blog.csdn.net/wangdingqiaoit/article/details/5220660 什么事Z-fighting？由非线性图看出，深度0.5以后，Z值增大，对应的深度值会越来越靠近。受深度值精度（bit位）影响，当两个面很接近时，可能出现深度值相差很小甚至相等的情况，此时不能确定两个面的先后顺序，可能造成两个面相互交叉的情况（不确定先后，不知道用哪个面的颜色等信息）。 如何解决Z-fighting？插入偏移实现，OpenGL 自动实现。一般不用开启，影响性能。 第一步，启用多边形偏移 12345// 启⽤用Polygon Offset ⽅方式 // GL_POLYGON_OFFSET_POINT 对应光栅化模式: GL_POINT 点// GL_POLYGON_OFFSET_LINE 对应光栅化模式: GL_LINE 线// GL_POLYGON_OFFSET_FILL 对应光栅化模式: GL_FILL 面glEnable(GL_POLYGON_OFFSET_FILL) 第二步，计算偏移量（由OpenGL完成）$Offset = ( m factor ) + ( r units)$ m : 多边形的深度的斜率的最大值,理解⼀个多边形越是与近裁剪面平行,m 就越接近于0。就是深度值。 r : 能产生于窗口坐标系的深度值中可分辨的差异最小值.r 是由具体OpenGL 平台指定的⼀个常量. factor : units : offset大于0，模型离摄像机越远；offset小于0，模型离摄像机越近。 12glPolygonOffset(Glfloat factor,Glfloat units) 一般将 factor、units 设为-1,-1可满足要求。 第三部，关闭多边形偏移 1glDisable(GL_POLYGON_OFFSET_FILL) 相关函数 12345678910111213141516171819// 激活深度测试glEnable(GL_DEPTH_TEST)// 刷新深度缓冲区（每次渲染前都应该做一次，否则测试时会使用到上一次渲染存储的深度值）// 默认刷新使用最大值1glClear(GL_DEPTH_BUFFER_BIT)// 指定深度测试时比较方式，默认小于（新值比缓冲值）// GL_ALWAYS 不比较，直接通过// GL_NEVER 不比较，都不通过// GL_LESS 小于// GL_LEQUAL 小于等于// GL_EQUAL 等于// GL_GEQUAL 大于等于// GL_GREATER 大于// GL_NOTEQUAL 不等于glDepthFunc(GLEnum mode);// 禁⽌写⼊深度缓冲区（一般不用吧）glDepthMask(GL_FALSE) 参考链接 OpenGL中的深度、深度缓存、深度测试及保存成图片 深度测试 OpenGL学习脚印：深度测试(depth testing) Depth Testing 几种测试]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>渲染技巧</tag>
        <tag>隐藏面消除</tag>
        <tag>深度测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路5-渲染管线-代码实现]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF5-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[Github 代码仓 渲染流程概述 渲染管线的大概流程看这 流程虽然有好几步，但是开发者真正可操作的很少。尤其是固定管线：准备好顶点（纹理等）数据，指定着色器，打开一些功能和测试开关，最后交换缓冲区。顶点坐标和片元的着色处理由OpenGL内部完成；包括图元装配、光栅化等都不要开发者干预。 即便是可编程管线，开发者也就是要自己写顶点和片元着色器。其他流程还是一样的。 当然简单只是宏观上的。 渲染窗口 OpenGL 并没有自己的窗口系统，需要依赖操作系统。GLUT 库就是一套封装了主流操作系统窗口交互的工具库，但是它只适合学习和开发简单的OpenGL应用。Github tag : 20190523-2-A main.cpp 1234567891011121314151617181920212223242526272829303132void prepareToRender(int argc, char *argv[]) &#123; // 设置工作空间，默认可执行文件目录 gltSetWorkingDirectory(argv[0]); // 初始化窗口交互工具 glutInit(&amp;argc, argv); // 创建窗口 glutInitWindowSize(800, 600); glutCreateWindow("base primitive"); // 检查api可用性, 初始化上下文 GLenum state = glewInit(); if (GLEW_OK != state) &#123; printf("api 不支持！\n"); &#125; &#125;void render(void) &#123;&#125;void registerCallback(void) &#123; // 注册渲染回调 glutDisplayFunc(render);&#125;int main(int argc, char *argv[]) &#123; prepareToRender(argc, argv); registerCallback(); // 开启监听循环 glutMainLoop(); return 0;&#125; 顶点数据（两种方式） 第一种是一个个点的传入。同时这种方式使用的是最简单的固定管线，只需要传入数据就可以渲染。但是短处显而易见，如果数据很多将是一场灾难，而且很难出复杂的效果。Github tag : 20190523-2-B 1234567891011121314151617181920void simplistPipeline(void) &#123; // 设置裁减区域范围 glOrtho(-10.0, 10.0, -10.0, 10.0, -10, 10); // 指定渲染图形的颜色 glColor4f(1, 0, 0, 1); // 设置点的大小 glPointSize(5); // 设定图元样式为点，注意点的图元样式只有GL_POINTS。另一个GL_POINT即便只有一个点也无效。 glBegin(GL_POINTS); glVertex3f(3, 0, 0); glVertex3f(0, 3, 0); glVertex3f(0, 0, 3); // 随glBegin配套出现 glEnd(); // 强制刷新缓冲区 glFlush(); // 交换缓冲区 // glutSwapBuffers();&#125; 上面的裁减区域如果不设置，默认范围(-1,1)，x,y,z都是。 我们重点使用 GLBatch 处理数据。 Github tag : 20190523-2-C main.cpp 1234567891011121314151617// 这是全局变量 GLBatch pointBatch;void setupVertexData() &#123; GLfloat vertexes[] = &#123; 0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5, &#125;; glPointSize(5); // 指定渲染的图元方式和顶点数量 pointBatch.Begin(GL_POINTS, 3); // 复制顶点数据，处理成向量顶点的形式 pointBatch.CopyVertexData3f(vertexes); // 结束处理，和begin成套 pointBatch.End();&#125; 指定点的大小可以通过glPointSize函数。也可以在使用GLSL语言自定义着色器的时候，对内部变量 gl_PointSize赋值，但前提是必须激活选项glEnable(GL_PROGRAM_POINT_SIZE)。一旦该选项被激活，glPointSize函数将会失效。 使用固定管线着色器 关于着色器种类看这 由于我们暂时只画点，这里选择使用GLT_GLT_SHADER_IDENTITY。 首先初始化着色器管理类。我们在 prepareToRender 函数中 glewinit() 之后添加代码。一定要在 glewinit()之后初始化着色器。着色器的状态由渲染上下文管理，先有上下文，状态才能被管理。 main.cpp1234// 这是全局变量GLShaderManager shaderManager;// 添加到 glewinit 之后shaderManager.InitializeStockShaders(); 由于不同图形需要不同着色器，我们需要能在渲染过程中改变着色器种类。因此选择在渲染回调中指定。 渲染回调时机 窗口frame改变时，系统自动触发 开发者手动调用 在render函数中添加。 1234// 红色GLfloat rgbaColor[] = &#123;1,0,0,1&#125;;// 指定着色器shaderManager.UseStockShader(GLT_SHADER_IDENTITY, rgbaColor); 平面着色器需要的两个参数。 开始渲染和交换缓冲区 在 render函数最后添加两句 1234// 开始绘制pointBatch.Draw();// 交换缓冲区glutSwapBuffers(); 从这里能推断出 GLBatch 是顶点传送的通道，从原始数据到最后片元都由它来管理。 关于缓冲区交换 刷新颜色缓冲区 运行程序，运气好应该能看到3个正方形的红点。正方形是因为像素点。不过多半看到的类似这样 这是因为显卡是随时在使用的，缓冲区里随时都有数据。因此每次渲染之前我们都应该先刷新缓冲区。在 render函数开始的地方 Github tag : 20190523-2-D 12// 刷新颜色缓冲区，为了防止之前的颜色信息影响本次渲染glClear(GL_COLOR_BUFFER_BIT); 另外还有三个缓冲区 GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT | GL_ACCUM_BUFFER_BIT深度、模板、累加器缓冲区，每次渲染前都应该先刷新。 再运行就没问题了。默认窗口背景色是浅灰色，要更改可以在prepareToRender中添加下面这句 1glClearColor(1, 1, 0, 1); 该函数仅指明使用什么颜色来刷新颜色缓冲区，因此该函数必须在glClear之前调用。虽然有个clear单词，但笔者认为叫刷新更合适。]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>固定管线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路2-坐标系及投影方式]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF2-%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%8A%E6%8A%95%E5%BD%B1%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[坐标系 OpenGL: 你不知道的左右手坐标系 OpenGL 中实际计算时使用的都是齐次坐标(x,y,z,w)，w 为缩放因子，通常为1。x,y,z值通过除以w，来进⾏行行缩放。 标准化设备坐标(normalized device coordinates NDC)也叫归一化坐标 x,y,z范围为[-1,1]的坐标系。左手坐标系。 OpenGL 推荐使用NDC作为着色器数据，但是习惯上我们会自定义坐标范围。因此通常在顶点着色器中将坐标标准化，再进行下一步。 OpengGL坐标系 世界坐标系：以屏幕中心为原点，屏幕指向观察者为+Z 轴的右手坐标系。 物体坐标系（模型坐标系，绘图坐标系）：以物体某点为原点形成的三位直角坐标系。该坐标系与物体绑定，随物体变换而变换。不同物体有其自己的物体坐标系，并且相互独立。绘图刚开始，该坐标系和世界坐标系轴平行，但是经过变换后，物体坐标系将会变化。 惯性坐标系：以物体坐标系原点为原点，坐标轴平行于世界坐标系坐标轴的坐标系。该坐标系是为了简化世界和物体坐标系的变换。物体坐标系变换到惯性坐标系，由于共原点，只需要进行旋转；惯性坐标系到世界坐标系只需要平移。 摄像机坐标系 以摄像机为原点，以摄像机观察方向为+Z，摄像机向上为+Y，向右为+X，采用左手坐标系。渲染管线会将世界坐标转换成摄像机坐标，裁减掉视景体以外的坐标，剩下的进入后续计算。该坐标系和屏幕坐标系类似，但是屏幕坐标系是二维的，摄像机坐标系是三维的。 屏幕坐标系 屏幕的二维坐标系。iOS中视图的坐标系以左上角为原点，X轴向右、Y轴向下为正。macOS中视图以左下角为原点，X轴向右、Y轴向上为正。 投影方式 投影指的是将三维模型转换到二维视口的方式。 正交投影：类似于用一束平行光照射物体得到的投影，这种方式得到的投影不管离摄像机远近，都是等大的。 透视投影：类似于用点光源照射物体得到的投影，这种方式得到的投影离摄像机越远投影越小。透视投影符合真实世界人眼看物体，离眼睛越近物体的看上去越大。 PQ 为我们观察结果所在的视平面。物体和摄像机连线在视平面相交于A、B两点，很明显AQ&gt;BQ。这就是透视投影远小近大的原因。梯形PQNM或PQTR为可视区域，只有该区域内的模型能透视到视平面PQ。因此透视投影需要指定远、近裁剪面距离。 实际投影是一个三维立体图形，该立体区域称为视锥体（视景体）。摄像机位于椎体顶点E，截面1被称为近裁剪面，截面2被称为远裁剪面。这两个平面之间的棱台即可视区域，凡是可视区域边界以外的模型都将被裁减掉。 透视投影的目的就是将裁减空间转换为标准化设备坐标。转换后，近裁剪面与XY轴平面平行，Z轴垂直于中心沿观察方向为正。x,y,z范围都是[-1,1]。 透视投影原理和实现 透视投影详解透视投影目的部分，近裁剪面右上角应该映射到立方体右上角。 窗口、视口、裁减区域 窗口：系统提供的显示区域。 视口：窗口中实际用于显示图形的平面区域。使用glViewPort(x,y,width,height)指定，一般都将x,y设为0，即从原点开始的一块宽width，高height的区域。 裁减区域：远近裁剪面组成的一个几何棱台区域（透视投影）或长方体（正交投影），只有该区域内的模型会投影到屏幕。超出区域都将被裁减。 在窗口看到的渲染内容需要视口和裁减区域共同确定。把视口类比为摄像机镜头，它能拍到的是裁减区域内物体模型。 视口能看到整个裁减区域。视口看的是裁减区域，裁减区域放置模型，视口看到模型。 glViewport()函数和glOrtho()函数的理解 矩阵变换 参与变换的几个坐标系统 局部空间(Local Space，Object Space) 世界空间(World Space) 摄像机空间(Camera Space，Eye Space，View Space) 裁剪空间(Clip Space) 屏幕空间(Screen Space) 3D模型坐标转换到屏幕2D坐标过程 3位坐标变换是通过平移、旋转、缩放、反转这几个操作完成，我们将这几个动作综合成一个变换矩阵。三种坐标变换分别对应：模型矩阵、视图矩阵、投影矩阵。 物体坐标 * 模型变换矩阵 =&gt; 世界坐标 * 视图(摄像机)变换矩阵 =&gt; 摄像机坐标 * 投影矩阵 =&gt; 裁减坐标赋值给顶点着色器中的gl_Position变量，自动对裁减坐标做透视除法 =&gt; NDC 坐标，通过视口变换 =&gt; 屏幕坐标。这个过程都是在顶点着色器中完成。 模型变换、视图变换和投影变换由开发者进行自定义；透视除法、视口变换则由OpenGL内部完成。 用一个公式来标识物体坐标到裁减坐标。注意OpenGL矩阵乘法采用左乘（从右向左）法则。 Mclip = Mproj · Mview · Mmodel · Mlocal OpeGL坐标系统 坐标变换原理]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>坐标系</tag>
        <tag>投影和矩阵变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路4-mac环境搭建及简单渲染]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF4-mac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%AE%80%E5%8D%95%E6%B8%B2%E6%9F%93.html</url>
    <content type="text"><![CDATA[搭建环境 下面配置好的环境可以备份，每次写代码时复制一份。或者自定义一个 Xcode 模板。这是笔者的代码仓,模板的 tag 是 OpenGL_template。模板下载后, 放在~/Library/Developer/Xcode/Templates/Project Templates下。如果编译报头文件错误，可能要在Build Settings中修改PublicOpenGLHeaderPath为$(SRCROOT)/你的工程名。然后如图使用 git clone 克隆或下载一个仓库单个文件夹 开始搭建环境。创建一个 mac cocoa app。删除不需要的文件。 编译报缺少 xxx.entitlements 的错。 添加 OpenGL.framework 和 GLUT.framework。 在弹出的窗口中搜索上面两个库添加即可。 创建 main.cpp 文件（选择 macos c++ file，不需要main.hpp）。 将 include 文件夹拖入项目。这里面有着色器容器类等。记住勾选 copy item if needed。 include在这 修改头文件搜索路径 在 main.cpp 中添加代码，应该能够编译通过了。 1234567891011#include &quot;GLTools.h&quot;#ifdef __APPLE__#include &lt;glut/glut.h&gt; // mac 下引入 glut 库#else#define FREEGLUT_STATIC // windows 或 linux 的引入方式，宏必须要定义#include &lt;GL/glut.h&gt; #endifint main(int argc, char *argv[]) &#123;&#125; 显示窗口 先试试绘制一个基本的窗口。在main函数中添加代码，别忘了回调函数。 1234567891011121314151617void render(void) &#123;&#125;int main(int argc, char *argv[]) &#123; //初始化GLUT库，参数为 main 函数形参 glutInit(&amp;argc, argv); // 初始化窗口大小、标题 glutInitWindowSize(800, 600); glutCreateWindow(&quot;base primitive&quot;); // 注册显示回调：屏幕变化或者主动渲染触发自定义函数 glutDisplayFunc(render); // 开启 GLUT loop 监听消息，类似 runloop glutMainLoop(); return 0;&#125; 使用默认坐标系渲染三角形 渲染最基本的图元, 具体代码就不贴了, 看我的Github，tag为 20190523-1-A 12345678910111213141516171819202122232425262728293031323334353637// 据说是 Resource 文件夹，实际仍是可执行文件路径// 初始化GLUT库，参数为 main 函数形参// 初始化显示模式 // 初始化窗口大小、标题// 注册回调函数// 1. 注册重塑回调：窗口 frame 改变则触发自定义函数 // 2. 注册显示回调：屏幕变化或者主动渲染触发自定义函数（图形需要发生变化，就要重新渲染）// 3. 注册键盘输入回调：键盘输入触发自定义函数// 字母、数字等ASCII码能标识的键位// 4. 注册特殊键位输入回调：键盘输入触发自定义函数// 方向键，F功能键等// 初始化GLEW库，检查 api 是否可用 // 设置渲染环境// 1.1 设置背景色// 1.2 初始化着色管理器// 1.3 设置图形顶点数组：三角形，一位数组形式// 1.4 使用批处理处理顶点数据// 1.4.1 开始：设定图元类型，顶点数量// 1.4.2 复制顶点数据// 1.4.3 结束// 开启 GLUT loop 监听消息，类似 runloop 使用自定义坐标 渲染复杂滴滴的图形, Github代码，tag为 20190523-1-B main.cpp main函数 1234567// 初始化GLUT库，参数为 main 函数形参// 初始化窗口大小、标题// 注册渲染回调，窗口更新则调用// 开启GLUT loop main.cpp 渲染回调123456789101112131415161718// 1.1 设置背景色// 1.2 清空颜色、深度、模板换缓冲区// 1.3 设置颜色// 1.4 设置裁减区域 glOrtho// 1.5 开始渲染 glbegin primitive mode glew.h// 不同mode需要重新begin end// 1.6 设置顶点（正方形，圆形，）glVertex2f : (x, y)glVertex3f : (x, y, z)// 1.7 结束渲染// 1.8 刷新缓冲区]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>mac-OpenGL环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路3-渲染架构及固定管线着色器]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF3-%E6%B8%B2%E6%9F%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF%E7%9D%80%E8%89%B2%E5%99%A8.html</url>
    <content type="text"><![CDATA[渲染架构The architecture of OpenGL is based on a client-server model. An application program written to use the OpenGL API is the “client” and runs on the CPU. The implementation of the OpenGL graphics engine (including the GLSL shader programs you will write) is the “server” and runs on the GPU. Geometry and many other types of attributes are stored in buffers called Vertx Buffer Objects (or VBOs). These buffers are allocated on the GPU and filled by your CPU program. OpenGL 是基于CS模型的架构。C端指的是使用了OpenGL API的应用程序，是运行在CPU上的。S端指的是OpenGL图形引擎的实现，包括自定义着色器，是运行在GPU上的。图形的几何数据等属性存储在顶点缓冲区对象（VBO）中。这些缓冲区存在于GPU上（显存）但是由CPU填充数据。 James R. MilleCPU-GPU Cooperation 这里的客户端、服务端和网络请求中代表的实体不同，但是思想都一样。开发者调用相应OpenGL API。CPU执行API就相当于发送请求，请求的参数就是顶点、纹理等数据，这些数据一开始都在内存中，由CPU从内存写入显存缓冲区。服务端即GPU使用相应着色器对收到的数据进行处理，最后渲染到屏幕上或者传回内存。服务端中开发者能操作的是顶点和片元着色器，这两者计算由GPU完成。 Attributes: 属性 通常存储一些经常发生变化的值，比如存储顶点坐标、颜色值、纹理坐标、光照、法线等属性。 属性值会应用到每一个顶点，通常使用4个元素来描述一个属性值。比如坐标（x,y,z,w），当然我们不一定4个元素都使用。缺省时，(x,y,z)默认为0，w默认为1，这种缺省方式对颜色值等其他属性一样存在。 属性值只能传到顶点着色器，不能直接传递到片元着色器。 Uniforms: 统一值 通常存储一些要应用到所有属性的值。它可以改变，但是他的变化不是针对某一个属性，而是整个图形而言。比如图形旋转由图形顶点数据*旋转矩阵。顶点数据肯定很多，它们的旋转肯定都是一样的即都是乘以同一个旋转矩阵，这个旋转矩阵就可以使用Uniform来传递。类似的还有平移矩阵、缩放矩阵等。 这个过程一般发生在顶点着色器。 可以同时使用多个不同形式的统一值。比如同时对图形旋转和变换颜色。 Texture: 纹理值，即图片，需要使用位图。但是一般不会传递到顶点着色器，而是由片元着色器根据片元纹理坐标获取颜色。 Position and Outs: 这两个都是渲染管线内部变量，开发者是不能干预的。可以不用管。 它们同时在顶点着色器和片元着色器声明。作为顶点着色器的输出，其值可以是常量或片元之间的插值？。片元着色器中响应的输入变量会接收这两个值。 渲染管线（流水线）一般流程 渲染管线的定义可以看这 在OpenGL进⾏绘制的时候，⾸先由顶点着⾊器对传入的顶点数据进行运算，对原始顶点附加纹理坐标、进行坐标变换等操作。顶点着色器输出的数据再通过图元装配，将顶点转换为基本图元。接着会对图元进行裁切，因为视口之外的数据没必要进行渲染。剩下的数据进行光栅化，以图元范围内的像素点进行映射，生成相应的片元。最后，将片元数据传⼊片元着⾊器中进行运算。片元着⾊器会对栅格化数据中的每一个像素进行运算，并决定像素的颜⾊和深度值。经深度、Alpha等测试后和帧缓冲区（屏幕缓冲区？）对应像素颜色进行混合，最后成像。 https://blog.csdn.net/u014587123/article/details/80460758 http://www.cnblogs.com/liangliangh/p/4116164.html 固定管线着色器 可编程管线中我们可以自定义顶点着色器和片元着色器的实现方式。 固定管线则是使用参数指定系统着色器，下面这些着色器可以看成是系统实现好的顶点和片元着色器“组合”后的产物。 函数原型 1GLShaderManager::UseStockShader(GLT_STOCK_SHADER nShaderID, ...) 第一个参数为着色器类型，一共有10种着色器选项。每种着色器需要的参数个数是不一样的。 单元着色器 : GLT_SHADER_IDENTITY 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_IDENTITY, GLfloat vColor[4]); 参数2：一维RGBA颜色数组。 在默认坐标系（-1，1）中以指定颜色渲染图形。 平面着色器 : GLT_SHADER_FLAT 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_FLAT, GLfloat mvp[16], GLfloat vColor[4]); 参数2：4*4图形变换矩阵。 参数3：一维RGBA颜色数组。 渲染的图形需要应用旋转、平移等模型变换或者投影变换等矩阵。如果要同时应用两种变换，需要开发者自行计算两种变换矩阵的结果。 上色着色器 : GLT_SHADER_SHADED 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_SHADED,GLfloat mvp[16]); 参数2：4*4图形变换矩阵。 变换同平面着色器一样，不同的是会自动平滑着色。 默认光源着色器 : GLT_SHADER_DEFAULT_LIGHT 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_DEFAULT_LIGHT, GLfloat mvMatrix[16], GLfloat pMatrix[16], GLfloat vColor[4]); 参数2：4*4模型变换矩阵。 参数3：4*4投影变换矩阵。 参数4：一维RGBA颜色数组。 默认光源模拟太阳光线，发出的是平行光。会使图形产生阴影和光照效果，参数2或参数3之一设置为单元矩阵，就同平面着色器一样。同时应用两种变换，不需要开发者单独计算。 点光源着色器 : GLT_SHADER_POINT_LIGHT_DIFF 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_POINT_LIGHT_DIEF, GLfloat mvMatrix[16], GLfloat pMatrix[16], GLfloat vLightPos[3], GLfloat vColor[4]); 参数2：4*4模型变换矩阵。 参数3：4*4投影变换矩阵。 参数4：点光源位置(x,y,z)。 参数5：一维RGBA颜色数组，漫反射颜色。 变换同默认光源着色器类似，但是光源的位置是待定的。 纹理替换着色器 : GLT_SHADER_TEXTURE_REPLACE 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_TEXTURE_REPLACE, GLfloat mvMatrix[16], GLint nTextureUnit); 参数2：4*4模型变换矩阵。 参数3：纹理单元。 可以对图形应用模型或投影变换（虽然参数是mv，但是投影变换也是16矩阵）。变换后的图形使用纹理单元进行颜色填充。 纹理调整着色器 : GLT_SHADER_TEXTURE_MODULATE 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_TEXTURE_MODULATE, GLfloat mvMatrix[16], GLfloat vColor[4], GLint nTextureUnit); 参数2：4*4模型变换矩阵。 参数3：一维RGBA颜色数组。 参数4：纹理单元。 可以对图形应用模型或投影变换（虽然参数是mv，但是投影变换也是16矩阵）。将参数3提供的颜色和纹理的颜色混合（相乘），变换后的图形使用混合色进行颜色填充。 纹理点光源着色器 : GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_TEXTURE_POINT_LIGHT_DIFF, G Lfloat mvMatrix[16], GLfloat pMatrix[16], GLfloat vLightPos[3], GLfloat vBaseColor[4], GLint nTextureUnit); 参数2：4*4模型变换矩阵。 参数3：4*4投影变换矩阵。 参数4：点光源位置（x,y,z）。 参数5：一维RGBA颜色数组。 参数6：纹理单元。 可以对图形应用模型或投影变换。将参数5提供的颜色和纹理的颜色混合（相乘），变换后的图形使用混合色进行颜色填充，并且使用漫反射照明进行调整（矩阵相乘）。 以下两个暂未查到相关资料 着色器 : GLT_SHADER_TEXTURE_RECT_REPLACE？ 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_TEXTURE_RECT_REPLACE, ); 着色器 : GLT_SHADER_LAST？ 函数原型 1GLShaderManager::UseStockShader(GLT_SHADER_LAST, );]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>固定管线</tag>
        <tag>OpenGL</tag>
        <tag>渲染架构</tag>
        <tag>着色器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习之路1-部分术语]]></title>
    <url>%2Farticle%2FOpenGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF1-%E9%83%A8%E5%88%86%E6%9C%AF%E8%AF%AD.html</url>
    <content type="text"><![CDATA[3D物体：任何物体，其几何形状都是由三角形组成的。构成一个平面最少需要3个点。 GPU 处理大量运算。 context 上下文 状态机：管理许多对象，对象声明周期内的状态和动作。触发条件，状态机执行相应动作，改变对象的状态，直到对象销毁。 context：管理视觉对象，对象有颜色、位置等状态。外部输入，执行响应修改动作，改变当前状态。 切换上下文？耗费较多性能。可以在不同线程中创建不同上下文，他们共享纹理和缓冲区。不同线程进行不同的渲染功能。 render 渲染 将视觉数据通过GPU或CPU运算后转换成3D图像的操作。 primitive 图元 OpenGL 或 OpenGL ES中构成3D图像的基本单位。 OpenGL 中是：点(Pont)、线(Line)、三角形(Triangle)、四边形(Quad)、多边形(Ploygon)。 OpenGL ES 中是：点(Pont)、线(Line)、三角形(Triangle)。 点是最基本图元。 顶点、 图元、片元、像素的含义 几种基本图元 GL_POINTS: 顶点只以点的形式渲染，不聚合成其他图形。 GL_LINES: 每隔两个顶点连成一条线段。 GL_LINE_STRIP: 每两个相邻顶点连成一条线段。 GL_LINE_LOOP: GL_LINE_STRIP的基础上，尾首两个顶点再连线，组成闭合图形。 GL_TRIANGLES: 每隔3个顶点连成一个三角形。 GL_TRIANGLE_STRIP: 每3个相邻顶点连成一个三角形(除前两个点外，每个点与前面两个点组成三角形)。 GL_TRIANGLE_FAN: 以第一个顶点为圆心，之后每隔两个顶点和圆心组成三角形，形成一个扇形三角形组。 环绕 顶点顺序和顶点间连线方向一致的组成图元的方式就叫做环绕。比如从顶点数组 V 中获取 V0,V1,V2三个点，按照0、1、2顺序连接顶点的方式即环绕。 默认按逆时针环绕得到的多边形为图形正面。 默认按顺时针环绕得到的多边形为图形反面。 可以通过 glFrontFace(GL_CW)指定正面。 GL_CW 顺时针环绕为正面。 GL_CCW 逆时针环绕为正面。 vetex、vetex array、vetex buffer 顶点、顶点数组、顶点缓冲区 顶点就是一个位置数据。顶点数组有GPU处理。 一个3D图像顶点数据的集合就是顶点数组。点是最基本的图元，刚开始绘制简单图形时，我们都是先绘制点，然后连线。当图形复杂时，我们就需要多次调用顶点函数，耗时费力。使用顶点数组可以一次搞定。 顶点数组可以存储在内存中，但是GPU访问内存肯定没有GPU访问自己的显存快。为了更高的性能，我们通常将其存储在显存中，使用的这部分显存就叫顶点缓冲区。 https://blog.csdn.net/u012501459/article/details/12945153 pipeline 管线，渲染流水线 OpenGL 渲染流程。GPU在处理数据的时候是有一定顺序的，就像画图是先点后线再及面，这个顺序是不能打破的。它描述的是接收一组3D坐标，转换为2D坐标，然后将2D坐标转换为可视图像的整个过程。 固定管线：早起版本封装好的渲染流程 api，调用这些api就可以完成相应功能。开发者设置固定的参数（比如光照模式，纹理模式），就好比OC API中的NSOption选项。因此功能相对有限，不能满足每一个应用场景。 processing pipeline 可编程管线：由于固定管线的缺陷，OpenGL开放了部分模块供开发者自定义，一般来说就是顶点着色器和片元（片段、像素）着色器。 http://www.songho.ca/opengl/gl_pipeline.html shader 着色器 实现图像渲染的一个程序，类比成一个函数吧。输入数据经过着色器处理后才能被下一阶段程序使用。 可以使用 GLSL语言（OpenGL Shading Language）自定义着色器，需要自行编译和链接，由于着色器需要大量调用，它是在显卡GPU是执行的。 https://www.cnblogs.com/leeplogs/p/7339097.html vertex shader 顶点着色器(可编程) 处理每一个顶点的变换（旋转、平移、投影等），需要计算的顶点属性主要包括坐标变换、顶点光照、法线等等。变换的工作包括三个部分，模型变换、视图变换和投影变换。将gl_Vertex变换为gl_Position，通过将gl_Vertex乘上gl_ModelViewMatrix矩阵可以将其变换到摄像机空间（又称Eye空间或摄像机坐标系），而乘上gl_ModelViewProjectionMatrix矩阵可以将顶点数据变换到齐次裁剪空间，此时即得到了gl_Position。 自身坐标到归一化坐标（0，1坐标系）的运算也在这里。 并行执行 fragment shader 片元(片段)着色器(可编程) 处理图形中每一个像素颜色的计算和填充，处理光、阴影、遮挡、环境等等对物体表面的影响。 并行执行 windows DiretX 中叫做像素着色器。但是片元和像素并不是一样的，片元包含一个点和它相关信息（颜色、纹理等）。片段可以理解为像素的原型，但绝对不是指一大片像素）。片段是包含位置，颜色，深度，纹理坐标等属性的数据结构。片段可能会最终成为图像上的像素。片段是通过检查原始图元和和屏幕像素是否相交来生成的。如果一个片段与一个基元相交，但不与它的任何顶点相交，那么它的属性必须通过顶点之间的属性插值来计算得出。 nikoong,blog.csdn.net/nikoong/article/details/79776873 以下两个了解其作用即可，开发者一般不操作。 GeometryShader ⼏何着⾊器 为了可移植性，最新的WebGL和OpenGL ES标准不在支持几何着色器，开发移动应用和web应用请不要使用几何着色器。 TessellationShader 曲面细分着⾊器 细分曲面着色器是可选的，它操作的不是点、线、三角形基本图元 Primitive Assembly 图元装配 将顶点着色器的数据转换为基本图元 rasterization 光栅化，像素化 将图元数学信息及其颜色映射为屏幕对应的像素点和填充该像素的颜色。 光栅化就是把顶点数据转换为片元的过程。⽚元中的每⼀一个元素对应于帧缓冲区中的⼀一个像素。 光栅化其实是一种将几何图元变为二维图像的过程。该过程包含了两部分 的⼯作。第一部分⼯工作:决定窗口坐标中的哪些整型栅格区域被基本图元占用;第二部分工作:分配⼀个颜⾊色值和⼀个深度值到各个区域。光栅化过程产生的是片元. texture 纹理 就是一张图片，但是位图格式。使用纹理只需要得到图形顶点在纹理中的坐标，然后将这部分纹理填充到图形。就好比填图，我们可以用笔慢慢描，也可以直接扔张图片进去。 https://blog.csdn.net/qq21497936/article/details/79184344#commentBox https://blog.csdn.net/dcrmg/article/details/53180369#commentBox blending 混合 片元着色器处理后的数据，会对所有像素？经过一系列测试（Alpha、Depth测试等），满足测试的像素的颜色会和帧缓冲区的颜色进行混合。混合算法可以使用预定义，也可以自定义。 可以使用片元着色器或者混合方程式。 matrix 矩阵变换矩阵 使图形发生平移、旋转等变化的矩阵 投影矩阵 将3D坐标转换为屏幕使用的2D坐标。 渲染上屏/交换缓冲区 原始数据经过着色器处理、测试混合等流程后形成最终显示数据，这些数据再映射到程序窗口上成像，保存最终数据的显存部分就是渲染缓冲区（个人理解）。 如果一个窗口对应一个缓冲区，当屏幕刷新时，GPU正在往缓冲区写数据，就会造成屏幕上一帧和下一帧共存的问题。因此，OpenGL至少有两个缓冲区。直接映射到屏幕的缓冲区称为为屏幕缓冲区，另一个称为离屏缓冲区（名字是相对的，不变的是位置）。屏幕缓冲区映射到屏幕时，GPU将计算的下一帧数据写入离屏缓冲区，然后交换两个缓冲区。之前的屏幕缓冲区变为离屏缓冲区，离屏变为屏幕，实现图像显示。 如果GPU计算离屏buffer的速度快于屏幕刷新率。可能出现上一帧映射了一部分数据到屏幕，此时缓冲区交换，上一帧未映射的数据被下一帧替换。屏幕继续刷新，映射了下一帧到屏幕。由于刷新是从上到下，从左到右逐行进行，画面会产生撕裂。因此执行交换一般会等待屏幕刷新完成的信号，这个信号就是垂直同步信号。 但这样一来，GPU写入离屏buffer后，需要等待垂直同步信号，GPU就产生了空闲。两次刷新之间和buffer交换都需要消耗一点时间，可能造成延迟的现象。因此又引入了三重缓冲技术，额外再增加了一个离屏缓冲区。 http://mini.eastday.com/mobile/180309010002602.html# OpenGL 头文件 &lt;glut/glut.h&gt; mac系统下使用如上形式，windows 和 linux 系统需要使用freeglut的静态库，并且添加一个宏。 123456#ifdef __APPLE__#include &lt;GLUT/GLUT.h&gt; // mac下居然不区分大小写#else#define FREEGLUT_STATIC // 一定要添加宏#include &lt;GL/glut.h&gt;#endif 负责处理和底层操作系统的交互以及I/O操作。适合学习OpenGL和开发简单的OpenGL应用程序。GLUT并不是一个功能全面的工具包所以大型应用程序需要复杂的用户界面最好使用本机窗口系统工具包。 百度百科 GLUTGLUT &quot;glew.h&quot; 长话短说，就是因为windows对opengl的支持不好，为了不使用软模拟的opengl，需要从显卡厂家的驱动里抽取opengl的实现，而glew方便了这个过程。只需要调用一下glewInit就可以使用gl*函数了。 -wbp- glew库的使用要点 以及 典型错误blog.csdn.net/a_txpt_001/article/details/40356793 GLEW能自动识别你的平台所支持的全部OpenGL高级扩展涵数。也就是说，只要包含一个glew.h头文件，你就能使用gl, glu, glext, wgl, glx的全部函数[0]。 他山之金 GLEW库安装和初始化blog.csdn.net/u010281174/article/details/45848003 &quot;GLTools.h&quot; 封装了OpenGL工具函数库、OpenGL实用工具库以及一些其他的常用函数，一般来说引入该文件足以。 &quot;GLBatch.h&quot; 顶点数据处理类。它可以传输顶点/法线/纹理/颜⾊数据到顶点着色器中。 &quot;GLShaderManager.h&quot; 着色器管理类，创建并管理自定义着色器，同时也提供一组固定管线存储着色器，能进行一些基本渲染操作。 &quot;GLFrame.h&quot; 矩阵工具类。表示位置，需要设置vOrigin, vForward ,vUp。GLFrame可以表示世界坐标系中任意物体的位置与方向。无论是相机还是模型，都可以使用GLFrame来表示。详解 &quot;GLMatrixStack.h&quot; 矩阵栈帧类。可以加载单元矩阵/矩阵相乘/缩放/平移/旋转等操作。压栈/出栈用来保存变换前的模型举证。 &quot;GLFrustum.h&quot; 矩阵视锥体类，跟摄像机相关。视锥体就是以摄像机为顶点的一个四棱锥，描述视野范围。快速设置正投影、透视投影矩阵。完成坐标由3D到2D的转换。 &quot;GLGeometryTransform.h&quot; 几何变换类。在代码中传输视图矩阵/投影矩阵/视图投影变换矩阵等。处理矩阵的叉乘、变换等。 &quot;math3d.h&quot; 3D数学类。 OpenGL 部分函数参考 https://www.cnblogs.com/1024Planet/p/5764646.html#_label03]]></content>
      <categories>
        <category>图形处理</category>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的爱情观]]></title>
    <url>%2Farticle%2F%E6%88%91%E7%9A%84%E7%88%B1%E6%83%85%E8%A7%82.html</url>
    <content type="text"><![CDATA[为什么要寻找她？ 大学时候有一个室友，为了女友一点一点的抠自己的生活费，周末跑出去兼职，跟我们吐槽费钱。抛开勤工俭学，如果以我的观点来看，我不欣赏这段爱情。女方没见过几次，我不清楚。但至少我的同学是有痛苦产生的。当然这些都是以我的角度评价。在我同学来看，也许这种痛苦也是他的爱情，至少他的爱情是大于痛苦的。 说回我自己的爱情观吧。 为什么要寻找她呢？为什么要结婚呢？ 以上一辈的观点：不孝有三，无后为大；所以她只是一个生育工具吗？如果我是女人，我宁愿一个人乐享一生，也不要将自己的子宫去满足那过时的愚孝。之所以过时，因为这仍然是几千几万年的动物繁衍行为。自然界除人以外的物种，大多又分成小的种群。为了种群的延续，繁衍是必然行为，雄性和雌性的选择也是不多的。但在人类社会，哪里还有什么种群之分。整个社会延续，繁衍仍是必然；但下降到个体，选择的范围已是整个物种。如果非要有后，领养有何不可？甚至于一个侮辱女性的词汇：代孕。 还有种说法是老来有伴。但要我说，其实是为了填补内心的空虚。退休之前，我们有工作。就算业余生活再贫乏，还有工作可以填补和吐槽。一旦退休，没有业余爱好，就只剩下空洞。这时候有个人，哪怕不说话。一起做做家务，洗菜做饭也能过一天。但是我现在对退休生活能想到好多活动。旅游，我还没真正旅游过呢；我还喜欢做菜；我也喜欢代码···现在已经有很多老年人活得有声有色，身边有个人陪伴，一起享受生活是锦上添花，但不是必须有她。 再有就是性。这应该是动物本能，动物叫发情，我们人叫思春。就个人体验而言，这还真是无可避免。关于这点，我只能说有需求就有市场。虽然没去过，但是这个想法已让我失去评价她们的资格。再说狠点，人是不满足的，不然怎么会总有人出轨。有了她，我只能有她，如何去体验万种风情呢。但如果是为了性，我绝不会也绝不能让她走近我。 说到出轨，这是我最厌恶的行为之一。想要寻找刺激或者新感情，却又没有信心拿下，所以这边不敢放下，那边又要留点牵绊。美其名曰还有感情，其实是为了避险的借口。这种避险行为不知是生而有之还是后天习得，在我看来还能理解原谅但这段感情不可继续。除此之外的出轨就是贱。如果你已经对其他人有感觉，为何不遵从自己的心？即便现任泪流满面，也要勇敢的负起责任对她/他说不。 我只想选择爱情，我不知道她什么样。但我宁愿穷尽一生去寻找她、等待她，即便最终成了一个你们眼中的孤独的人。]]></content>
      <categories>
        <category>gossip</category>
        <category>个人随想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AliyunSTS策略]]></title>
    <url>%2Farticle%2FAliyunSTS%E7%AD%96%E7%95%A5.html</url>
    <content type="text"><![CDATA[简单概述 Demo 最近在使用阿里 OSS，需要通过使用 AccessKeyId/ AccessKeySecret 来进行请求验证。这两个字符串有3种级别。 阿里账号级别：可以访问账号中所有的云资源。 RAM角色级别：创建一个 RAM 角色，赋予指定资源的访问权限。该角色下创建的 AccessKeyId/ AccessKeySecret 只能访问指定的资源。 STS 临时访问凭证：使用 RAM 角色的 AccessKeyId/ AccessKeySecret 获取临时的 AccessKeyId/ AccessKeySecret 和 SecurityToken。在受限时间内访问指定资源。有效期在 15min ~ 1h 之间。 访问阿里 URL 时，需要使用 AccessKeyId/ AccessKeySecret 对 URL 的部分字段进行签名。访问控制 处于安全原因，阿里推荐使用 STS 凭证。STS临时授权访问OSS STS 必须要创建 RAM 角色。 创建 RAM 角色下的 AccessKeyId/ AccessKeySecret 使用 RAM 角色下的 Id 和 Secret 通过 AssumeRole API获取临时凭证(Id,Secret和SecurityToken)。这一步阿里推荐(放弃了 OSSStsTokenCredentialProvider类)后端来做，移动端通过后端接口直接拿到临时凭证。原因是避免 Id 和 Secret 放在移动端被逆向出来。 再使用临时凭证访问 OSS STS API参考Aliyun访问控制 STS api 上面提到 STS 逻辑应该后端来做。如果非要前端或移动端处理，阿里也提供了 API endpoint 笔者开通的是杭州的服务 sts.cn-hangzhou.aliyuncs.com。这里查询 http method 可以是 GET 或 POST。这里使用 GET。 parameter 参数有公共参数和AssumeRole接口参数。 形成参数字典1234567891011121314151617181920212223242526272829303132333435- (NSDictionary *)commonParameter &#123; NSMutableDictionary *mDic = [NSMutableDictionary dictionary]; mDic[@"Format"] = @"JSON"; mDic[@"Version"] = @"2015-04-01"; mDic[@"SignatureMethod"] = @"HMAC-SHA1"; mDic[@"SignatureVersion"] = @"1.0"; // 8601标准UTC: YYYY-MM-ddThh:mm:ssZ mDic[@"Timestamp"] = [NSDate get8601UTC]; // 时间戳作随机数 mDic[@"SignatureNonce"] = [NSDate getTimeStamp]; mDic[@"AccessKeyId"] = AccessKeyId; return [mDic copy];&#125;- (NSDictionary *)assumeRoleParameter &#123; NSMutableDictionary *mDic = [NSMutableDictionary dictionary]; mDic[@"Action"] = @"AssumeRole"; mDic[@"RoleArn"] = @"acs:ram::166435498213570:role/roastduck"; mDic[@"RoleSessionName"] = @"InjectMWeb"; // 临时token的权限, 缺省则为角色指定的所有权限// NSDictionary *policyDic = @&#123;@"Statement":@[@&#123;@"Action":@"oss:*",@"Effect":@"Allow",@"Resource": @"*"&#125;],@"Version": @"1"&#125;;// mDic[@"Policy"] = [self dictToJsonString:policyDic]; // 临时 token 生命周期,单位:秒, 15min ~ 1h，默认 1h// mDic[@"DurationSeconds"] = @3600; return [mDic copy];&#125; SignatureNonce是唯一随机字符串，所以笔者使用了时间戳。 上面 NSDate的两个方法是笔者自己写的分类。 RoleArn 可以在角色管理中查看。 RoleSessionName 根据你的需求来。 sign 签名步骤 签名时，参数字典中不能有 Signature 字段，这个最后赋值。 对字典排序，排序方式为字典序（英文字母顺序）。由于 NSDictionary 没有排序的方法。因此笔者是对 allKeys进行排序，然后遍历数组，根据排好序的 key 获取对应的 object。 对字典key排序1234567- (NSArray *)ascKeysInParameterDic:(NSDictionary *)parameterDic &#123; NSArray *sortedKeys = [parameterDic.allKeys sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123; return [obj1 compare:obj2 options:NSLiteralSearch]; &#125;]; return sortedKeys;&#125; 排好序的数组 123456789101112&lt;__NSArrayI 0x60000260cfc0&gt;( AccessKeyId, Action, Format, RoleArn, RoleSessionName, SignatureMethod, SignatureNonce, SignatureVersion, Timestamp, Version) 按排好序的key获取object, 并对 key 和 value 分别进行 URL 编码。然后用 = 将两者连接：URLEncode(key)=URLEncode(value)。最后用 &amp; 将每对 URLEncode(key)=URLEncode(value) 连接。编码规则参照签名步骤中 1 - ii。 Ali 指定编码方式123456789101112131415161718192021222324- (NSString *)encodeURLParameterString:(NSString *)originString &#123; NSRange lowerChars = NSMakeRange((unsigned int)'a', 26); NSMutableCharacterSet *lowerCharsSet = [NSMutableCharacterSet characterSetWithRange:lowerChars]; NSRange upperChars = NSMakeRange((unsigned int)'A', 26); NSMutableCharacterSet *upperCharsSet = [NSMutableCharacterSet characterSetWithRange:upperChars]; // range.location need unicode value NSRange numChars = NSMakeRange(48, 10); NSMutableCharacterSet *numCharsSet = [NSMutableCharacterSet characterSetWithRange:numChars]; NSMutableCharacterSet *specialSet = [NSMutableCharacterSet characterSetWithCharactersInString:@"-_.~"]; [specialSet formUnionWithCharacterSet:lowerCharsSet]; [specialSet formUnionWithCharacterSet:upperCharsSet]; [specialSet formUnionWithCharacterSet:numCharsSet]; NSString *encodedString = [originString stringByAddingPercentEncodingWithAllowedCharacters:specialSet]; encodedString = [encodedString stringByReplacingOccurrencesOfString:@"+" withString:@"%20"]; return encodedString;&#125; iOS-URL编码 将上面的 encodedString 按照 HTTPMethod+&amp;+URLENCODE(/)+&amp;+encodedString 再拼接即得到待签名字符串。 1NSString *URLStringToSign = [NSString stringWithFormat:@"%@&amp;%@&amp;%@", @"GET", [self encodeURLParameterString:@"/"], encodedString]; 对 URLStringToSign 计算 HMAC-SHA1 值。AccessKeySecret+&amp; 作为 HMAC 需要的 hmac-key。并且对计算后的原始数据进行 base64 编码。 签名1234567891011121314151617#import &lt;CommonCrypto/CommonCrypto.h&gt;NSString *key = [NSString stringWithFormat:@"%@&amp;", AccessKeySecret];// 取得二进制数据NSData *encodeKey = [key dataUsingEncoding:NSUTF8StringEncoding];NSData *data = [URLStringToSign dataUsingEncoding:NSUTF8StringEncoding];unsigned char hmac[CC_SHA1_DIGEST_LENGTH];// 系统函数CCHmac(kCCHmacAlgSHA1, [encodeKey bytes], encodeKey.length, [data bytes], data.length, &amp;hmac);NSData *originData = [NSData dataWithBytes:hmac length:CC_SHA1_DIGEST_LENGTH];// HMAC计算返回原始二进制数据后进行Base64编码NSString *signature = [originData base64EncodedStringWithOptions:0]; 这里计算 Base64 一定是使用原始数据，也就是 hmac的二进制。 千万不要将 hmac 转为 NSString 再进行 base64 将 Signature 字段添加到参数字典。再按照 key=value 的形式拼接到 https://sts.cn-hangzhou.aliyuncs.com/?后面。]]></content>
      <categories>
        <category>iOS</category>
        <category>踩的坑</category>
      </categories>
      <tags>
        <tag>Aliyun</tag>
        <tag>STS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算hamc再进行base64编码的弯路]]></title>
    <url>%2Farticle%2F%E8%AE%A1%E7%AE%97hamc%E5%86%8D%E8%BF%9B%E8%A1%8Cbase64%E7%BC%96%E7%A0%81%E7%9A%84%E5%BC%AF%E8%B7%AF.html</url>
    <content type="text"><![CDATA[签名阿里STS URL接口的时候，需要先进行 HMAC，然后对结果再进行 base64 编码。 笔者的做法：计算出 HMAC 值，然后借用了网上的方法将得到的原始值按ASCII值输出成了另一个字符串，然后再转成 NSData 进行 base64 编码。 原始二进制数据以ASCII值保存为NSString1234567- (NSString *)stringFromBytes:(uint8_t *)bytes length:(int)length &#123; NSMutableString *strM = [NSMutableString string]; for (int i = 0; i &lt; length; i++) &#123; [strM appendFormat:@"%02x", bytes[i]]; &#125; return [strM copy];&#125; 123456NSString *originDataToString = [self stringFromBytes:hmac length:CC_SHA1_DIGEST_LENGTH];// 此时的 data 是一个长得像原始数据ASCII值的字符串的二进制数据，查看二进制数据实际已经是不同的ASCII值了。NSData *data = [originDataToString dataUsingEncoding:NSUTF8StringEncoding];// 得到的编码根本不是原始数据的NSString *signature = [data base64EncodedStringWithOptions:0]; 事实上对计算出的 HMAC 值是不能取 NSString的。 12// 返回值为 nil[[NSString alloc] initWithData:originData encoding:NSUTF8StringEncoding] 正确的做法：计算出 HMAC 值，对原始字节数据直接转为 NSData，进行 base64 编码。 123NSData *originData = [NSData dataWithBytes:hmac length:CC_SHA1_DIGEST_LENGTH];// HMAC计算返回原始二进制数据后进行Base64编码NSString *signature = [originData base64EncodedStringWithOptions:0];]]></content>
      <categories>
        <category>iOS</category>
        <category>踩的坑</category>
      </categories>
      <tags>
        <tag>踩的坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-URL编码]]></title>
    <url>%2Farticle%2FiOS-URL%E7%BC%96%E7%A0%81.html</url>
    <content type="text"><![CDATA[iOS9.0 后 URL 字符串编码的方法 -[NSString stringByAddingPercentEncodingWithAllowedCharacters:]。 参数类型为 NSCharacterSet，通过该参数指定不需要进行 URL 编码的字符 1234567// 注意: \ 带有转义字符NSString *string = @&quot;abc123*&amp;+=#%&lt;&gt;[\]&#123;&#125;`|&quot;;NSCharacterSet *set1 = [NSCharacterSet characterSetWithCharactersInString:@&quot;abc*&amp;]&#123;&#125;&quot;];NSString *encoded1 = [string stringByAddingPercentEncodingWithAllowedCharacters:set1];// 结果, 为方便观察添加了两个空格abc %31%32%33 *&amp; %2B%3D%23%25%3C%3E%5B%5C ]&#123;&#125; %60%7C 类方法集成了部分在 URL 编码时用到的字符串。URL 示例: http://username:password@www.example.com/index.php?key1=value1#jumpLink。 URLUserAllowedCharacterSet “#%/:&lt;&gt;?@[]^` 之外的所有字符，编码位置为 username URLPasswordAllowedCharacterSet “#%/:&lt;&gt;?@[]^`{|} 之外的所有字符，编码位置为 password URLHostAllowedCharacterSet #”%/&lt;&gt;?@\^`{|} 之外的所有字符，编码位置为 www.example.com URLPathAllowedCharacterSet “#%;&lt;&gt;?[]^`{|} 之外的所有字符，编码位置为 /index.php URLQueryAllowedCharacterSet “#%&lt;&gt;[]^`{|} 之外的所有字符，编码位置为 key1=value1 URLFragmentAllowedCharacterSet “#%&lt;&gt;[]^`{|} 之外的所有字符，编码位置为 jumpLink 举个例子 123456// 注意: \&quot; 和 \\ 带有转义字符NSString *string = @&quot;abc123*&amp;+=\&quot;#%&lt;&gt;[\]^`&#123;|&#125;&quot;;NSCharacterSet *set2 = [NSCharacterSet URLQueryAllowedCharacterSet];NSString *encoded2 = [string stringByAddingPercentEncodingWithAllowedCharacters:set2];// 结果: 为方便观察添加了两个空格abc123*&amp;+= %22%23%25%3C%3E%5B%5C%5D%5E%60%7B%7C%7D 再多说一句吧，以 URLQueryAllowedCharacterSet 为例。该类方法的效果是对 “#%&lt;&gt;[]^`{|} 进行编码，但是该方法的返回值其实是 “#%&lt;&gt;[]^`{|} 在所有URL编码字符中的补集。 手动创建验证一下1234567891011// query 要编码的字符NSString *query = @"\"#%&lt;&gt;[\]^`&#123;|&#125;";NSCharacterSet *set3 = [NSCharacterSet characterSetWithCharactersInString:query];// 取补集NSCharacterSet *invertSet3 = set3.invertedSet;// 补集中的字符不进行编码NSString *encoded3 = [string stringByAddingPercentEncodingWithAllowedCharacters:invertSet3]; if ([encoded2 isEqualToString:encoded3]) &#123; NSLog(@"结果相同");&#125; 补充几个方法 1234567891011// 取集合补集 NSMutableCharacterSet: NSCharacterSet@property (readonly, copy) NSCharacterSet *invertedSet;// 取并集 NSMutableCharacterSet- (void)formUnionWithCharacterSet:(NSCharacterSet *)otherSet;// 取交集 NSMutableCharacterSet- (void)formIntersectionWithCharacterSet:(NSCharacterSet *)otherSet;// 取补集 NSMutableCharacterSet- (void)invert;]]></content>
      <categories>
        <category>iOS</category>
        <category>踩的坑</category>
      </categories>
      <tags>
        <tag>URL编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac开发时遇到的TIP]]></title>
    <url>%2Farticle%2FMac%E5%BC%80%E5%8F%91%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84TIP.html</url>
    <content type="text"><![CDATA[macOS 使用右手坐标系，z 轴由屏幕指向我们，坐标原点在左下角。NSButton 修改背景色 使用 layer 的 CGColor 使用纯色图片 使用 NSButtonCell 的背景色。NSButton 继承自 NScontrol，主要负责事件响应，与之配套的 NSButtonCell 负责界面显示。NSButtonCell 是 NSbutton 的属性。但是如果直接 button.cell是不能设置 cell 背景色的。原因在于 cell 的声明@property (nullable, strong) __kindof NSCell *cell;。也就是说 cell 可以是 NSCell 及其子类。但是呢，NSCell 本身是没有背景色属性的，我们需要先设置好 NSButtonCell，再赋值给 NSButton 的 cell 属性即可。继承关系：NSButtonCell &lt; NSActionCell &lt; NSCell。 1234567891011121314// 使用 layerbutton.wantsLayer = YES;button.layer.backgroundColor = [NSColor redColor].CGColor;// 使用图片[button setImage:[[NSBundle mainBundle] imageForResource:@&quot;240.png&quot;]];aliOSSButton.imagePosition = NSImageBelow;// 使用 NSButtonCellNSButtonCell *cell = [[NSButtonCell alloc] initTextCell:@&quot;lksjdf&quot;];cell.backgroundColor = [NSColor lightGrayColor];button.cell = cell;// NSButton 有部分属性和 cell 可以互相覆盖。推荐这些视图设置都在 NSButtonCell 上完成。// button.title = @&quot;anniu&quot;;]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>NSButton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向实战录三-DYLD-INSERT-LIBRARIES]]></title>
    <url>%2Farticle%2F%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E5%BD%95%E4%B8%89-DYLD-INSERT-LIBRARIES.html</url>
    <content type="text"><![CDATA[逆向的几种方式 直接修改汇编 插入动态库 修改 MachO LoadCommand:insert_dylib 使用 DYLD_INSERT_LIBRARIES 环境变量 可执行文件不一定非要是使用源代码编译链接后生成的，一个拥有执行权限的 shell 脚本，也是可以的。 webfrog,iosre.com/t/macos-app-app/10976 MWeb逆向：汇编MWeb逆向：MonkeyDevMWeb 逆向：DYLD_INSET_LIBRARIES 使用 DYLD_INSET_LIBRARIES 破解 新建一个 macOS 动态库项目 MWebInject 引入 libsubstitute 动态库，我们要使用 MSHook 系列函数。安装了 MonkeyDev 后，该动态库可以在 /opt/MonkeyDev/MFrameworks下找到。 123456~ cd /opt/MonkeyDev/MFrameworks~ ls-rwxr-xr-x 1 root wheel 65032 Apr 2 14:48 libsubstitute.dylib-rw-r--r-- 1 root wheel 15771 Apr 2 14:48 substrate.h 将这两个文件都引入到 HookDevMateKit 中。在动态库.m 文件中加入上一篇中绕过试用逻辑的代码。 MWebHook.m12345678910111213141516171819202122232425262728293031323334353637383940414243#import "substrate.h"#include &lt;mach-o/dyld.h&gt;#include &lt;dlfcn.h&gt; // 全局变量intptr_t g_slide; // 每个镜像添加之后的回调static void _callback_for_add_image(const struct mach_header *header, intptr_t slide) &#123; Dl_info image_info; int result = dladdr(header, &amp;image_info); if (result == 0) &#123; NSLog(@"load mach_header failed"); return; &#125; // info.plist 中获取可执行文件名 NSString *execName = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleExecutable"]; // 获取当前的可执行文件路径, bundle即.app文件 // 建议先 show package contents 看下路径，比如这里还要添加 Contents/MacOS NSString *execPath = [[[NSBundle mainBundle] bundlePath] stringByAppendingFormat:@"/Contents/MacOS/%@", execName]; // 调用 MSHookFunction 前，打印看看。需要打开 console.app // NSLog(@"RD===%s", image_info.dli_fname); if (strcmp([execPath UTF8String], image_info.dli_fname) == 0) &#123; // 保存模块偏移基地址的值 g_slide = slide; // NSLog(@"RD===%ld", g_slide); &#125;&#125; // 接收原来的 IMPstatic int (*origin_sub254ab0)(int); // 实现新的函数，我们需要他返回 1static int hook_sub254ab0(int arg0)&#123; return 1;&#125;static void __attribute__((constructor)) initialize(void) &#123; // 注册回调 _dyld_register_func_for_add_image(_callback_for_add_image); MSHookFunction((void *)(0x100254ab0 + g_slide), (void *)hook_sub254ab0, (void **)&amp;origin_sub254ab0);&#125; 编译，在项目中的 Products 下生成 libMWebInject.dylib。然后 show in finder，将动态库拷贝到桌面上。 这时候打开终端，来到桌面路径下测试。首先将 libsubstitute.dylib 拷贝到 /Applications/MWeb.app/Contents/MacOS/ 路径下，至于为什么吗？ 可以看到 libMWebInject.dylib 中已经指定，感觉将其改为和 Inject 动态库处于同一路径好些，免得拷贝。不过笔者在 xcode 中没找到怎么改！！！ @executable_path@executable_path 拷贝好后，终端执行 1DYLD_INSERT_LIBRARIES=libMWebInject.dylib /Applications/MWeb.app/Contents/MacOS/MWeb 不出意外，MWeb 已经运行，而且没有 update error 的提示框。 由此可以推测出 update error 的出现是由于对可执行文件或整个 app 的完整性校验。而使用 DYLD_INSERT_LIBRARIES 动态注入并没有改变原 app(直接启动 MWeb，可以看到试用框又出现了)。而前面两篇文章破解后的 app 都改变了可执行文件，直接使用不会出现试用框。 总结 一旦更新 MWeb，新的可执行文件会覆盖掉我们破解过的。又要重新破解一次才行。使用汇编破解的方式，需要全程重来。使用动态注入的方式，对于 sub_xxxx 的函数，如果地址变化则要重新破解，但只要改几个数字就好；对于 hook 的方法名，只要 MWeb 没有改变名字，动态库就可以长期有效。 三篇文章破解方式 修改汇编 MonkeyDev 通过 IMP 交换实现对原方法或函数的修改，然后编译成动态库。通过修改可执行文件的 LoadCommand 加载动态库。 编译动态库思路和 MonkeyDev 相同。加载动态库是通过 DYLD_INSERT_LIBRARIES 动态注入。 framework 是一个动态库，不能直接执行。使用 DYLD_INSERT_LIBRARIES 会报 exec format error 。 创建一个 app 实现自动注入 参考链接 使用 DYLD_INSERT_LIBRARIES， 每次都要去命令行太不友好。我们可以编写一个脚本实现自动化，并且将其包装成 App 的方式使用。 新建一个文件夹，并命名为 MWeb.app（名字随意，笔者平常使用 Alfred，MWeb 用习惯了。为了不和原App 名冲突，我将原来的重命名 NMWeb.app）。然后 show package contents 进入。 创建 Frameworks 文件夹，并将 libMWebInject.dylib 和 libsubstitute.dylib（不是必须的，如果选择不拷贝，脚本文件修改相应路径或者手动拷贝） 拷贝进来。 创建 MacOS 文件夹，在里面新建一个脚本文件，名字和之前新建的 app 同名，同时不要有 .sh 后缀。用 sublime text 打开输入下面的脚本 123456789101112#!/bin/sh// 获取当前脚本文件的目录的父目录，也就是 Contents 目录绝对路径CurrentAppPath=$(cd $(dirname $0) &amp;&amp; cd .. &amp;&amp; pwd)// 检测可执行文件目录中是否有 libsubstitute 动态库，没有则复制过去一个substitute_path=/Applications/MWeb.app/Contents/MacOS/libsubstitute.dylibif [ ! -e substitute_path ]; then cp $&#123;CurrentAppPath&#125;/Frameworks/libsubstitute.dylib /Applications/MWeb.app/Contents/MacOS/fi// 注入动态库DYLD_INSERT_LIBRARIES=$&#123;CurrentAppPath&#125;/Frameworks/libMWebInject.dylib /Applications/MWeb.app/Contents/MacOS/MWeb 保存后，给脚本文件添加当前用户的可执行权限 12// 再次提醒，这里 MWeb 就是我们创建的脚本。改这个名字只是笔者的习惯chmod u+x MWeb 在脚本 app/Contents 下新建一个 info.plist 文件, 内容如下 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;LSUIElement&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 也可以用 xcode 新建一个 现在可以使用脚本 app 自动破解了。 恢复符号表 我们下载的 APP 一般都是删除符号表的，这样不仅增加一点逆向成本，APP 体积也更小。而且逆向总要去 hook 方法。 restore-symbol路径1./restore-symbol /Applications/MWeb.app/Contents/MacOS/MWeb -o MWeb 可以看到恢复后的可执行文件变大了。然后将新的可执行文件替换原来的。发现启动应用没有任何反应。 使用 MonkeyDev 的 monkeyparser，它已经集成了 restore-symbol，在 /opt/MonkeyDev/Tools/mpack.sh中可以看到相关命令。在注入前会自动恢复符号表以及去签名步骤。 恢复符号表之后，再启动app，可能启动不了。因为可执行文件被修改，签名遭到破坏。app中可能对签名信息作了验证。 安装了 MonkeyDev 后可以使用如下命了去掉签名。其实就是用strip命令去删除了MachO中签名的信息。 1monkeyparser strip -t MWeb -o MWeb-unsigned Xcode LLDB 调试 Xcode 随便新建一个 MacOS 项目。Debug - Attach To Process - 选中要附加的 APP。Xcode 上方状态栏显示 Running xxx 后，使用 Xcode Debug View Hierarchy断住 APP。 接下来使用 bt all打印 APP 所有在使用线程的堆栈。 使用 image list | grep xxx来查看指定可执行文件的模块地址。 xxx 必须是完整可执行文件名。 这种方式有个缺点，附加时 App 已经启动了。对于 AppDelegate 的方法我们调试不了。 Mac App 的界面调试 上面 Xcode 的 Debug View Hierarchy Interface Inspector App，收费工具，可以自行破解。]]></content>
      <categories>
        <category>iOS</category>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向实战录二MWeb-substitute]]></title>
    <url>%2Farticle%2F%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E5%BD%95%E4%BA%8CMWeb-substitute.html</url>
    <content type="text"><![CDATA[在逆向实战录一中我们使用直接修改汇编的方式破解，这篇采用注入 libsubstitute.dylib 来 hook 那两个方法。 MWeb逆向：汇编MWeb逆向：MonkeyDevMWeb 逆向：DYLD_INSET_LIBRARIES 准备 本文使用 MonkeyDev 创建动态库项目。 项目中默认是 hook QQ 消息撤回功能的代码，可以直接删掉。 绕过试用框 上篇文章我们我们使用汇编 ret 了一个 sub_1000xxxx 的函数返回值，来改变 if 进程，从而绕过试用验证。 由于该函数属于三方库 DevMateKit，在 MWeb 的 MachO 中没有它的符号表，所以 hopper 以该函数在 MachO 中的偏移地址表示。在 hopper 和 MachoOView 中对比，在 MachOView 中可能因为解析问题导致指令变化。 既然没有符号，我们就不能通过 MSHookMessageEx 去 hook 该函数。怎么办呢？看这里 MWebHook.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import "MWebHook.h"#import "substrate.h"#include &lt;mach-o/dyld.h&gt;#include &lt;dlfcn.h&gt;// 全局变量intptr_t g_slide;// 每个镜像添加之后的回调static void _callback_for_add_image(const struct mach_header *header, intptr_t slide) &#123; Dl_info image_info; int result = dladdr(header, &amp;image_info); if (result == 0) &#123; NSLog(@"load mach_header failed"); return; &#125; // info.plist 中获取可执行文件名 NSString *execName = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleExecutable"]; // 获取当前的可执行文件路径, bundle即.app文件 // 建议先 show package contents 看下路径，比如这里还要添加 Contents/MacOS NSString *execPath = [[[NSBundle mainBundle] bundlePath] stringByAppendingFormat:@"/Contents/MacOS/%@", execName]; // 调用 MSHookFunction 前，打印看看。需要打开 console.app// NSLog(@"RD===%s", image_info.dli_fname); if (strcmp([execPath UTF8String], image_info.dli_fname) == 0) &#123; // 保存模块偏移基地址的值 g_slide = slide;// NSLog(@"RD===%ld", g_slide); &#125;&#125;// 接收原来的 IMPstatic int (*origin_sub254ab0)(int);// 实现新的函数，我们需要他返回 1static int hook_sub254ab0(int arg0)&#123; return 1;&#125;static void __attribute__((constructor)) initialize(void) &#123; // 注册回调 _dyld_register_func_for_add_image(_callback_for_add_image); // 内存中的真实地址为：MachO 偏移地址 + ASLR MSHookFunction((void *)(0x100254ab0 + g_slide), (void *)hook_sub254ab0, (void **)&amp;origin_sub254ab0);&#125; 编译后，MWeb 运行已经绕过试用框。剩下 update error 的警告框。 绕过 update error 提示 在逆向一中，我们修改方法 - checkIfConfiguredProperly ，直接 ret；或 + bundleAtURLIsCodeSigned的汇编，使其返回 1。既然看到方法有符号存在，~~ 那就简单了。 ~~ 不简单啊，因为方法在 framework 中，需要去 hook DevMateKit。需要另外建一个项目。 这里选择 hook 上一级方法 - [DM_SUUpdater checkIfConfiguredProperly]。 在 MWebHook.m 中添加以下代码 MWebHook.m1234567891011121314151617@class DM_SUUpdater; // 函数指针static void (*origin_checkIfConfiguredProperly)(void *, void *);static void hook_checkIfConfiguredProperly(void * self, void * _cmd) &#123;&#125;static void __attribute__((constructor)) initialize(void) &#123; // 注册回调 _dyld_register_func_for_add_image(_callback_for_add_image); MSHookFunction((void *)(0x100254ab0 + g_slide), (void *)hook_sub254ab0, (void **)&amp;origin_sub254ab0); // 添加 hook 消息 MSHookMessageEx(objc_getClass("DM_SUUpdater"), @selector(checkIfConfiguredProperly), (IMP)&amp;hook_checkIfConfiguredProperly, (IMP*)&amp;origin_checkIfConfiguredProperly);&#125; 编译后成功绕过 update error。将项目下 TargeApp 目录中的 MWeb.app 复制到 /Applications 就可以像其他软件正常使用了。 笔者也试过 hook 另一个方法+ bundleAtURLIsCodeSigned，但是 substitute 提示找不到符号。其实在 hopper 中搜索，发现两个方法都搜不到，为什么上一个方法却能 hook 呢？ 在 Strings 区域中搜索两个方法的类，发现DM_SUUpdater以一个属性或 ivar 存在，而DM_SUCodeSigningVerifier搜索不到。 个人推测：既然以属性存在，那么一定要引用头文件。头文件的方法就暴露给 MWeb 了。]]></content>
      <categories>
        <category>iOS</category>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检查源文件编译后的o文件大小]]></title>
    <url>%2Farticle%2F%E6%A3%80%E6%9F%A5%E6%BA%90%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84o%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F.html</url>
    <content type="text"><![CDATA[检查下编译后各文件编译后.o文件大小 在target - Build Settings中搜索Write Link Map File，设置为 YES。编译后会在Path to Link Map File指定的路径中生成一个 txt 文件。 通常路径为~/Library/Developer/Xcode/DerivedData/XXXX-fybqffuoxlmezedpfbtfqqtbmdjr/Build/Intermediates.noindex/XXXX.build/Debug-iphonesimulator/XXXX.build/，如果用真机编译，则在Debug-iphoneos路径下。 该文件列出了项目编译的中间文件和引用的库文件等路径信息、 MachO 文件代码段和数据段的信息。 首列为分区起始地址，然后是分区大小，段名，分区名。 Symbols 之后就是代码段和数据段具体数据，这里的信息和 Sections 是对应的。比如 text 区从 0x1000019B0 开始，其大小为 0x00122F71。0x1000019B0 + 0x00122F71 = 0x100124921。那么 stubs 区起始地址为 0x100124921 + 0x1 = 0x100124922。 列举具体数据信息时，布局方式和上面大致相同。首列为起始地址，数据大小，文件编号（编号相同说明处于同一文件），数据标识（比如方法名，函数名，类名等等） 文件最后是 Dead Stripped Symbols。这里列出了未使用的代码，这部分在生成可执行文件时不会被加入，以免浪费空间（apple dead strip your code）。需要注意的是这里列举的是每个文件中未使用的，所以有可能你会看到相同的代码出现多次或者出现在上面的代码段。要知道是哪个文件未引用，根据前面的文件编号到上面代码段和数据段即可找到。 源文件生成的 .o 等文件位置 ~/Library/Developer/Xcode/DerivedDamta/XXXX-fybqffuoxlmezedpfbtfqqtbmdjr/Build/Intermediates.noindex/XXXX.build/Debug-iphonesimulator/XXXX.build/Objects-normal/x86_64 笔者这里使用的是模拟器。 看了这一半天，这家伙又什么用呢？ 分析每个文件生成代码段的大小。因为苹果对上架的app有大小限制，代码段超过100M就不允许上架。 有了上面的数据，我们就有调整的依据了。如何调整可以参考爱奇艺这篇实践。 另外加一个组件化。 重命名 section，有点耍小聪明的感觉，不过只要能过省就行。]]></content>
      <categories>
        <category>工具</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用过的Linux命令(持续更新)]]></title>
    <url>%2Farticle%2F%E7%94%A8%E8%BF%87%E7%9A%84Linux%E5%91%BD%E4%BB%A4(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0).html</url>
    <content type="text"><![CDATA[记录一些用过的 shell 命令 echo 输出变量值处理特殊字符 echo $var 和 echo &quot;$var&quot; 区别： 如果是echo $var，输出结果为一行，没有换行符 如果是echo &quot;$var&quot;，显示转义字符。输出结果为多行，有换行符 输出到文件 echo 123 &gt; rd.txt 覆盖写入 echo 123 &gt;&gt; rd.txt 追加写入 sed 命令https://blog.csdn.net/weixin_41579863/article/details/79695379https://blog.csdn.net/xj626852095/article/details/26101273 sed -n &#39;m, np&#39; filename：读取文件 filename 中第 m ~ n 行。 sed 删除时 -n 必须在 -i 之前sed -i -n &#39;/~/d&#39; .zsh_history sed: RE error: illegal byte sequence date 获取当期日期 直接使用，返回标准时间格式 自定义格式，根据需求调整。 12格式：2019-4-3 13:34:33date &quot;+%Y-%m-%d %H:%M:%S&quot; 自定义格式中的变量, 区分大小写。 变量 表述 D 完整日期, 04/22/19 Y 四位年份, 2019 y 两位年份, 19 m 数字月份, 4 h 英文简写月份, Apr d 天 H 24小时时钟 M 分钟 S 秒钟 a 英文简写星期, Mon. tips 在.bash_profile或.zshrc 12export LC_CTYPE=C export LANG=C 添加后可能导致zsh终端按 tab 键时，重复出现终端输入，而且删不掉。因此需要在用完后注释掉该语句。]]></content>
      <categories>
        <category>工具</category>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本]]></title>
    <url>%2Farticle%2FShell%E8%84%9A%E6%9C%AC.html</url>
    <content type="text"><![CDATA[将各类命令预先放入到一个文本文件中，方便一次性执行的一个脚本文件。本文仅列出笔者使用者遇到的 shell tip或语法。所以命令不是很去全，读者可以自行搜索关键字。推荐菜鸟Linux教程 Shell 查看当前 PC 使用的所有 Shell：cat /etc/shells 切换 shell：chsh -s 上面查到的Shell路径 Shell 执行方式 sh 标准后缀.sh 执行命令 bash、zsh、source、./ source FileName：在当前shell环境中读取并执行FileName中的命令特点：命令可以强行让一个脚本去立即影响当前的环境（一般用于加载配置文件）。该命令会强制执行脚本中的全部命令,而忽略文件的权限。 bash FileName 、 $zsh FileName：重新建立一个子shell，在子shell中执行脚本里面的句子。 ./FileName：读取并执行文件中的命令。但有一个前提，脚本文件需要有可执行权限。 tips shell 对空格的使用很严格。比如变量赋值 t=$(pwd)不需要；if [ &quot;string&quot; == $var ]则前后都要。 输入时，输入信息与提示信息保持在同一行。输入的信息被当成字符串处理（这是笔者使用得出的结论，不保证正确···） 12echo -n 提示信息` # `-n`表示不换行 read 变量 如果-n命令不生效，就将命令中的echo替换为/bin/echo。 直接使用 read 选项 1read -p 提示信息 变量: # read 时将提示信息输出 数学表达式需要加关键字 expr 3 + 2。操作符前后必须有空格 不另开 shell 调用另一个脚本，并传递参数 first.sh1source path/second.sh 参数1 参数2··· second.sh1// 使用 $1,$2,$3,$5···$9,$&#123;10&#125;,$&#123;11&#125;···接收参数 调用另一个 shell 的三种方式 语法变量可以直接声明，但是访问必须要在前面加 $ 定义 12a = 20b = $a 读取变量时推荐使用 ${var} 的方式，这样能更直观的区分变量范围。 12345rain=&quot;cargo&quot;// 试比较下面语句echo &quot;hi, $&#123;rain&#125;boat&quot;echo &quot;hi, $rainboat 相关链接 用变量保存命令运行结果 $(command) 1234# 赋值t=$(git status | grep master)# 输出变量的值echo $t 控制语句 if 判断语句格式 https://www.cnblogs.com/aaronLinux/p/7074725.html 12345678910# 中括号两边必须有空格, 比较符号两边也必须有空格if [ xx == yy ]; then do something elif [ aa == bb ]; then do something else do somethingfi | if [ -z xxx ] | 判断 xxx 为空 | | --- | --- | | -a | 与 | | -o | 或 | | ！ | 非 | while 语句 1234// 无限循环while [ true ]; do do somethingdone case 语句(其他语言的 switch), ;;前可以有多条语句。每个条目的换行不是必须的，但是能提高代码可读性。 12345678index=0case $index in 0 ) sed -i &quot;&quot; -e &quot;s/同级tag1/$tag/&quot; $fullpath echo &quot;test&quot; ;; 1 ) sed -i &quot;&quot; -e &quot;s/同级tag2/$tag/&quot; $fullpath ;;esac 函数 所有函数在使用前必须定义。所以必须将函数放在脚本开始部分。函数调用直接使用函数名。 1234567891011// 函数定义function funName()&#123; echo &quot;参数不用形参，使用 $1 获取第一个参数&quot; echo &quot;参数不用形参，使用 $2 获取第二个参数&quot; echo &quot;参数不用形参，使用 $3 获取第三个参数&quot; echo &quot;参数不用形参，使用 $&#123;10&#125; 获取第十个参数&quot; echo &quot;参数不用形参，使用 $&#123;11&#125; 获取第十一个参数&quot; return $($1+$&#123;11&#125;)&#125;// 函数调用funName 参数1,参数2,参数3···参数10,参数11, 1. 可以带`function fun()` 定义，也可以直接`fun()` 定义,不用任何形参。 2. 可以 return 。如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255) 3. 当形参个数n &lt; 10时,使用`$n`来获取参数。当 n &gt;= 10时，需要使用`${n}`来获取参数。 4. 如果传递的参数中含有空格, 一般都是字符串吧，记得要用双引号，否则会认为有多个参数。因为 shell 是以空格来区分参数个数的。 5. 处理参数的特殊字符： | $# | 获取传递到脚本的参数个数 | | --- | --- | | $* | 以一个单字符串显示所有向脚本传递的参数 | | $$ | 获取当前运行脚本的进程PID | | $! | 获取后台运行的最后一个进程的PID | | $@ | 与$*相同，但是输出时加引号，并在引号中返回每个参数 | | $- | 显示Shell使用的当前选项，与set命令功能相同。 | | $? | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |]]></content>
      <categories>
        <category>工具</category>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编与机器码]]></title>
    <url>%2Farticle%2F%E6%B1%87%E7%BC%96%E4%B8%8E%E6%9C%BA%E5%99%A8%E7%A0%81.html</url>
    <content type="text"><![CDATA[在逆向实战录一中提到过修改汇编导致机器码的改变。部分机器码覆盖了原有的机器码，进而导致了下一条汇编的改变，甚至可能影响程序流程。那么汇编和机器码到底是怎样转换的呢？ 由于上一篇是 Mac 逆向，所以用到的是 intel 的 x86-64 架构指令。 指令和机器码对照需要查询 intel 手册，本篇使用的是这个。 最新手册看这里 IA32 MODE 下 x86-64 的机器码结构 翻到手册 2.1 章节 指令结构从右到左 — 低位到高位 Opcode: 是必需的，我们看到的 mov，jne 等操作码是它的一部分。一条机器码需要操作码(Opcode)和操作数(Operand)类型共同确定。有时候还需要 ModR/M 的 Reg/Opcode 3个 bit 作为补充。 ModR/M: 用于寄存器间接寻址和寄存器相对寻址。它包含3个部分。 Mod 和 R/M：两者共5bit，形成32种组合：8种寄存器模式(Mod 为 11)和24中地址寻址模式。有时候也会用于补充描述操作码。当作为寄存器时，使用的是32位；配合 prefix REX.R 使用64位。 Reg/Opcode: 该部分要么指定寄存器编号，要么作为主操作码的补充。至于何时二选一会在主操作码中指定。当作为寄存器时，使用的是32位；配合 prefix REX.R 使用64位。 查看 2.1.3 章节 table 2-2 在表格中 note 1 的情况需要使用 SIB 部分。SIB 用于基址加变址寻址或比例加变址寻址。 Scale：比例因子 Index：指定变址寄存器编号。这里使用的是32位；配合 prefix REX.X 使用64位。 Base：指定基址寄存器编号。当作为寄存器时，使用的是32位；配合 prefix REX.B 使用64位。 prefixes: 指令前缀，它的作用有两个：指定特殊的编码方式，一共分成四组，具体的可以参看手册 2.1.1 部分。本文仅关注第二种方式，用于对 Opcode 的扩展。32位有8个寄存器，3个 bit 刚好够用；现在64位有16个寄存器，需要4个 bit 来表示：原有的3个 bit 加上 REX.R bit。2.2.1.2 章节 table 2-4 前4 bit 固定不变，后面4 bit需要根据查表或根据使用的寄存器宽度置 1或0。 根据上面写一个完整指令 mov qword [rax + rcx * 8 + 0x11223344], 0x12345678 qword: 相当于一个说明符，表示后面的寄存器或内存要读取 4字（8个字节，64bit）的数据。同样的还有 dword（双字，4个字节），word（字，2个字节），byte（1个字节） 对应指令解释：Opcode [base + index * scale + displacement], immediate指令中的部分标识 查表我们会看到一些通用标识，来代表一类操作数。比如 /r、ib、r/m8等，接下来我们列举一些常用的。这些都可以在 3.1.1 章节找到。 Opcode 列中的标识。3.1.1.1 章节 /r：ModR/M 位中包含有一个寄存器操作数和一个寄存器或内存操作数。 REX.W（R、X、B）：指定 REX prefix 中使用的 bit。 /digit：digit 为0~7，ModR/M 中的 Reg/Opcode 用于主操作码的补充，在表中对应顶部单元格的倒数第二行。 ib、iw、id、io: 立即数的宽度（位数），一次为单字节(byte)，字(双字节，word)，双字(dword)，四字(qword)。 rb、rw、rd、ro：Opcode的低 3 bit 用于表示寄存器，且不使用 ModR/M。如果是64位，则需要 REX.B补充表示。 Instruction 列中的部分标识。3.1.1.3 章节 r8/16/32/64：不同宽度的寄存器，64位需要 REX.R位支持。 r/m8/16/32/64：寄存器或内存中不同宽度的操作数，64位寄存器需要 REX.R位支持。和上面一条对比，笔者个人理解上一条表示寄存器直接寻址，该条表示寄存器相对寻址。不知道是否正确··· imm8/16/32/64：不同宽度的立即数 m8/16/32/64：内存中不同宽度的操作数 moffs8/16/32/64：内存偏移，真正的物理地址需要段基地址+偏移得到。不使用ModR/M。笔者在这里有点蒙圈，因为实际的编码和笔者查出来的不同。比如 mov 指令中 mov al, moffs8的 Opcode 是 A0。笔者查找 mov al, [0x6]却是 8A 开头。不知道偏移指令是否是这样写的？读者朋友请告知一下，谢谢！ 举例解释，如有分析错误请留言指出。 逆向实战录一中对栈寄存器的赋值操作mov byte [rbp + var_50], al，后面删除线中的错误操作mov byte [rbp + var_50], 0x1（var_50就是0x50）。接下来依据机器码解释修改汇编为什么导致后续指令改变的原因。 mov byte [rbp - 0x50], al 初步分析：mov 指令；byte 表示后面内容只取 8 bit；目的操作数是基址寄存器相对寻址；源操作数是寄存器直接寻址；displacement 0x50 只有 8 bit； al 低8位寄存器。 mov 指令在 4.3 章节，善用搜索。一整页 pdf 表格，依据操作数的不同类型，给出了 mov 的不同 Opcode 。由于我们这里 byte 限定了只取8 bit 的数据，al 也是8bit 寄存器。我们找到 由于实际用不到64位寄存器，因此选择第一条。因此 Opcode 为 88。第二条 * 提示64位下该条指令不能使用AH、BH、CH、DH 4个单字节寄存器。 Opcode 列含有 /r，接下来查看 ModR/M 部分。目的操作数寄存器相对寻址，并且 displacement 为 8 bit。因此在 table 2-2 ModR/M 表中对应找到[EBP]+disp8一行。Mod 为 01， R/M 为 101。源操作数为 al，在表中顶部单元格 r8 一行找到第一列。行列交叉处得到 ModR/M 为 45。 displacement -0x50 直接嵌在最后。要注意这里是负数，需要找0x50的补码表示。displacement 为 B0 所以整个机器码为 88 45 BO。 mov byte [rbp - 0x50], 0x1 现在源操作数为立即数。在 mov 指令下找到 Opcode 为 C6 接下来看 ModR/M 。目的操作数不变，还是找到[EBP]+disp8一行。然后在上面指令中 C6 后面跟着/0 ib。ib 表示立即数，这里就是 0x1。/0 需要在 ModR/M 顶部单元格 /digit 中找，0就是第一列。行列交叉得到 45。 displacement 在 immediate 前面。所以整个机器码为 C6 45 B0 01。 将两条机器码对比，后一条笔者修改的多出了一个字节，而这个字节将后面指令的机器码覆盖了，变相修改了下一条指令。改变了寄存器之间的赋值。 因此逆向时修改汇编除非是 ret 整个函数，否则在不改变原有赋值的情况下直接修改指令：要么找到一条指令满足逆向需求，同时不能增加或减少字节数，要么就一直修改到底。尤其是对笔者这种刚入门的，是挺抓脑的。所以还是借助 MonkeyDev、substrate 等工具 hook 函数好一些。 相关链接 https://blog.csdn.net/cosmoslife/article/details/7631923 https://www.cnblogs.com/guocai/archive/2012/10/18/2730048.html https://blog.csdn.net/winsenjiansbomber/article/details/27253577 https://blog.csdn.net/u011555996/article/details/80264855 https://bbs.pediy.com/thread-191802.htm]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>机器码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发-优化]]></title>
    <url>%2Farticle%2FiOS%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91-%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[由于蓝牙广播或扫描时，使用的是设备信号。而设备信号也用于WIFI等其他功能。同时信号强度又会影响电池使用。为减小影响，需要最小化对信号的使用。？？ 能否在同一设备上打开两个中心设备角色或外围设备角色 本机作为中心设备角色开发优化1. 尽量减少扫描时间 中心设备开启扫描后不会自动停止。所以我们需要匹配到合适设备时主动停止。123if 匹配到需要的外围设备 &#123; [self.centralManager stopScan];&#125; 同时在开始扫描时除非特殊情况（如需要根据信号强度来连接设备）不对已发现设备重复扫描。12// 因为该key默认是NO，所以可以将 options 设为 nil[self.centralManager scanForPeripheralsWithServices:nil options:@&#123;CBCentralManagerScanOptionAllowDuplicatesKey: [NSNumber numberWithBool:NO]&#125;]; 2. 通过UUID来获取 因为一个外围设备有多个服务，一个服务又有多个特征，而一般我们只需要一部分服务或特征。所以我们在获取服务或特征时，通过UUID仅得到我们需要的即可。123456// nil 会搜索所有服务，但是耗时耗能，所以尽量传入服务uuid// 获取服务[peripheral discoverServices:数组&lt;CBUUID *&gt;];// 获取指定服务的特征[peripheral discoverCharacteristics:数组&lt;CBUUID *&gt; forService:service]; 3. 使用订阅的方式读取值 一次值读取就是一次交互，就要通过信号。如果一个特征的值可能变化可能不变时，就需要不停调用readValueForCharacteristic:方法。当一段时间内保持不变，使用readValueForCharacteristic:方法就会造成不必要的数据交互从而消耗电池。 如何避免呢？最好就是当特征的值变化时，外围设备通知相应的中心设备，中心设备收到通知在去读取值。 如何做到？使用订阅。1234// 不是所有特征值都可订阅，最好判断一下if (characteristic.properties &amp; CBCharacteristicPropertyNotify) &#123; [peripheral setNotifyValue:YES forCharacteristic:characteristic];&#125; 4. 过河就拆桥 为减少信号的使用，当中心设备订阅的特征不再发送通知后（CBPeripheral对象的isNotifying属性）或者 我们已经拿到所有需要的数据后，应该及时取消订阅然后断开和外围设备的连接。12// 为每一个订阅过的特征 设置 值 为 NO[peripheral setNotifyValue:NO forCharacteristic:characteristic]; 12// 断开连接[self.centralManager cancelPeripheralConnection:self.peripheral];]]></content>
      <categories>
        <category>iOS</category>
        <category>功能开发</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发-后台处理]]></title>
    <url>%2Farticle%2FiOS%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91-%E5%90%8E%E5%8F%B0%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[1. 进入后台时启用提示（app未声明后台模式）如果app没有对后台进行处理，那么进入后台时应该提示用户，提升app可用使用connectPeripheral: options:的options提示系统是否进行提醒。 123456// 连接已经建立，app被挂起，系统是否显示提示框，默认为NOCBConnectPeripheralOptionNotifyOnConnectionKey// app和外围设备断连时，app被挂起，系统是否显示提示框CBConnectPeripheralOptionNotifyOnDisconnectionKey// 收到外围设备通知时进入后台，系统是否为所有通知显示提示框CBConnectPeripheralOptionNotifyOnNotificationKey 2. 如果需要app进入后台后蓝牙仍能继续工作，只需要在info.plist中进行声明即可。只需在info.plist中点击右键，选择show raw keys/values即可切换。两个key可以同时存在。这样我们就能在后台和平常一样使用蓝牙大多数蓝牙服务。但是也有不同： 中心设备 调用scanForPeripheralsWithServices: options:时不会重复扫描相同设备。即便在options中声明了CBCentralManagerScanOptionAllowDuplicatesKey。 如果有多个app都在使用蓝牙，会导致扫描时间增多，影响发现外围设备的效率。 外围设备 广播时只会广播uuid，忽略CBAdvertisementDataLocalNameKey 包含UUID的数组不会通过广播包广播，而是通过一个特殊的“溢出”包，并且它只能被iOS设备发现。 如果有多个app都在使用蓝牙，广播频率会增加。 提醒 提供界面让用户决定什么时候处理蓝牙事件。 一旦app在后台被唤醒，只有10s时间来处理事件。否则可能被系统干掉。 不能用于唤醒app，却执行与蓝牙无关的任务。 3. app被干掉后重新恢复蓝牙 使用状态保存中心设备可保留： 扫描选项和正在扫描的服务 已连接和正在连接的外围设备 订阅过的特征 外围设备可保留： 正在广播的数据 发布到设备数据库的服务和特征 订阅特征的值得中心设备4. 使用 第一次初始化时添加用于恢复的唯一标识 1234// 中心设备self.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:@&#123;CBCentralManagerOptionRestoreIdentifierKey: @&quot;uniqueIDForCentral&quot;&#125;];// 外围设备self.peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:@&#123;CBPeripheralManagerOptionRestoreIdentifierKey: @&quot;uniqueIDForPeripheral&#125;]; app重新加载后，根据恢复标识重新初始化重新恢复标识可以在didFinishLaunchingWithOptions:中获得 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 中心设备恢复标识 NSArray *centralBluetoothRestoreID = launchOptions[UIApplicationLaunchOptionsBluetoothCentralsKey]; // 外围设备恢复标识 NSArray *peripheralBluetoothRestoreID = launchOptions[UIApplicationLaunchOptionsBluetoothPeripheralsKey]; return YES;&#125; 实现代理方法```// 中心设备 (void)centralManager:(CBCentralManager )central willRestoreState:(NSDictionary&lt;NSString ,id&gt; *)dict {}// 外围设备 (void)peripheralManager:(CBPeripheralManager )peripheral willRestoreState:(NSDictionary&lt;NSString , id&gt; *)dict {}```中心设备字典中包含的3个key： CBCentralManagerRestoredStatePeripheralsKey: app结束时所有已连接和正在连接的外围设备NSArray&lt;CBPeripheral *&gt; CBCentralManagerRestoredStateScanServicesKey: app结束时正在扫描的服务的UUIDNSArray&lt;CBUUID *&gt; CBCentralManagerRestoredStateScanOptionsKey: app结束时扫描外围设备时使用的选项NSDictionary 外围设备包含2个key： CBPeripheralManagerRestoredStateServicesKey: app结束时所有已发布的服务NSArray&lt;CBMutableService *&gt; CBPeripheralManagerRestoredStateAdvertisementDataKey: app结束时广播数据时正在使用的选项NSDictionary 跟踪manager初始化进程]]></content>
      <categories>
        <category>iOS</category>
        <category>功能开发</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向实战录一]]></title>
    <url>%2Farticle%2F%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%E5%BD%95%E4%B8%80.html</url>
    <content type="text"><![CDATA[本篇记录一下在 Mac 上逆向某付费 APP 的过程。仅与读者探讨技术，请勿将逆向后的 APP 商用。请支持正版！ MWeb逆向：汇编MWeb逆向：MonkeyDevMWeb 逆向：DYLD_INSET_LIBRARIES 工具准备 Xcode: 附加进程动态调试，UI 调试 restore-symbol: 符号表恢复 Hopper Disassembler 或 IDA: 静态调试，Hopper 在 Mac 上方便点，另外 Hopper 会对伪代码自行优化，可能忽略一些代码。推荐 Windows IDA，伪代码更详细。 思路 暴力模式：遇到拦路虎，分析出大概位置，然后 Hopper 定位，在对应代码段中直接 ret 掉函数或者直接修改寄存器值绕过检测。这种方式不推荐，也许会影响正常使用；而且产生的崩溃信息仍然被记录···。但是本篇采用这种方式，因为来得快啊！ 优雅模式：分析出中断函数的上层逻辑，比如上图_appTrackingState，猜测会有一个if或switch语句，我们就在这之前将其值修改为其他值；再甚者，分析出_appTrackingState的是如何被赋值的，然后去 hook 相应函数。 hopper 开始暴力破解 打开界面 很明显，第一步肯定是要绕过这个试用界面。试用界面和主界面几乎是同时出现的，因此推断处理逻辑在applicationWillFinish或applicationDidFinish中。其次，查看一下菜单栏，发现一些主要菜单都被禁用了。这也是我们需要绕过的一步。 Hopper 对刚才新的可执行文件进行分析。 在 DidFinish 中我们看到以下字段 -[AppDelegate applicationDidFinishLaunching:]12345678910rbx = @selector(setIsDisableAllUI:); _objc_msgSend(r13, rbx); if (sub_100253020(0x0) != 0x0) &#123; _objc_msgSend(r13, rbx); &#125; else &#123; intrinsic_movsd(xmm0, *0x1003715c0); [DevMateKit setupTimeTrial:r13 withTimeInterval:rcx]; &#125; [r13 updateMWebLicenseInfoUI:0x0]; setIsDisableAllUI:，应该是菜单禁用的逻辑。 其中r13 = self。这里需要注意，给出的objc_msgSend只给了两个参数（self，_cmd）。但是setIsDisableAllUI:有一个冒号，所以还需要一个参数，但是 hopper ···给优化了？。好吧，自己查看汇编分析寄存器咯。 %rax 作为函数返回值使用。 %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。 Endv, https://www.cnblogs.com/endv/p/4110798.html,X86-64寄存器和栈帧 obj_msgSend函数的第一、二个参数是self和_cmd。然后才是方法参数，也就是在寄存器 rdx 中。来到汇编 框出来的部分就是在传参，按照上面寄存器顺序 0x1 传到 edx，也就是 rdx 的低32位。那么第三个参数为 1 r13 传到 rdi。第一个参数为 self rbx 传到 rsi，最上面一句 rbx 存储的是方法的编号。第二个参数为 @selector(setIsDisableAllUI:) 接下来调用 objc_msgSend 发消息，也就是 [self setIsDisableAllUI:YES] 然后异或（同0异1）操作将 edi 赋值为 0，作为 if 条件中 sub_100253020函数的参数。edi 即 rdi 的低32位。其实这句也可以用 mov edi, 0x0，但是异或操作性能更好。 调用 sub_100253020 函数，获取返回值后和 0 进行比较。 左边对 edx 寄存器进行异或置0，那么整个左边其实就是 [self setIsDisableAllUI:NO] 因此整个逻辑： 先将 UI 禁用，然后调用 sub_100253020 函数验证 APP 激活状态。 有效激活，激活所有 UI。 无效，使用第三方 DevMateKit 走试用步骤，显示使用界面。 一下子就将两个步骤给逮到了。破解思路就是让函数 sub_100253020 返回 YES（1）。 如果用 IDA, 不用分析汇编，一目了然 ··· 接下来 hook sub_100253020 函数。这里选择直接定位(Hopper 中直接双击即可)，然后修改返回值为1。alt + a添加图中两句即可。然后生成新的二进制文件去替换。 接下打开 APP，激活窗口已经被绕过了。但是还有个 update error的窗口，直接点击 ok 已经可以使用软件了。第一直觉应该是个 Alert 窗口，但是在 AppDelegate 的几个入口函数中并没看到。绝望中直接百度了下 insecure update error。居然有现成的解决办法^_^。 其实这个校验三方是集成在另一个第三方框架 DevMateKit中。过程就是找啊找啊找··· Hopper 打开动态库的二进制文件(xxx.app/Contents/Frmaeworks/DevMateKit.framework/Versions/A/DevMateKit), Strings 中搜索 insecure update error。 在字符串上点击右键，选择 reference to address 0xxxxxx，弹出的窗口中选择引用地址，GO，会跳转到引用该字符串的地方。 跳转后，在高亮的代码上继续右键，GO，来到引用字符串的函数中 该方法返回值是 void 类型，所以其实可以直接将该方法给 ret 掉，生成新的动态库MachO文件替换原来的。本文结束···。 我们要 “ 操作的就是 var_50 和 rax=var_58 ” 的值，对应的汇编代码 var_50 和 var_58 是一个 offset，在该段汇编的开头可以查到具体的值为 -80(十六进制的50) 和 -88(十六进制的58)。因此我们实际操作的是 rbp - offset 指向的地址中的值。var_50等变量是 hopper 提供的，修改汇编时不能直接使用。需要使用对应的值，16进制或10进制都可。 现在我们要回溯之前的汇编代码，尽量得出 rbp - var_50和rbp - bar_58中是个什么值。 先看 var_50，最近的赋值 mov byte [rbp + var_50], al。al 是 rax 的低 8 位。也就是将 rax 的低 8位 赋值到 rbp - 80指向的地址的低8位。接下来再回溯看 rax 的值即可。 结合上面伪代码图中蓝色框图, var_50 应该是个 bool 值。 这里笔者有两种思路：第一种因为最后是拿 rbp + var_50 中的值比较，因此我们可以直接将 0x1 传进去 。第二种是去修改 al 即某个函数的返回值，需要去追溯最近调用的函数。 按照第一种思路将汇编改为 mov byte [rbp - 80], 0x1。修改后，由于对应指令的机器码长度不一样，新的机器码覆盖掉后面的机器码，造成后续汇编指令被意外修改，影响程序流程。解决方案是找到一句汇编，保证原来逻辑的同时，机器码保持原来的字节数。笔者自己也是汇编新手，感觉很难啊！至于汇编和机器码的转换会在后续文章推出。 这里笔者最后选择了思路二。al 即 rax 中的值是方法 bundleAtURLIsCodeSigned:的返回值。直接修改汇编令该方法返回 0x1。 然后生成新的动态库 MachO 文件进行替换后，MWeb 可以运行了。 根据上面伪代码红色框中，var_58 应该是个字符串，因此不能为空。要注意的是，qword 表示要读取64位。 和 var50 思路相同，这里 rax 存放的是 @selector(publicDSAKey) 的返回值，因此找到该方法，直接往 rax 里放个字符串。对应的汇编lea rax, qword [0x90822]; &quot;Insecure update error!&quot;，lea 也可以使用 mov。这里传到 rax 的是字符串的地址。笔者在数据段里随便找了字符串，然后 MWeb 崩溃了。本来猜测对 key 做了校验，后来笔者随便试了下mov rax, 0x1； ret；居然成功了--!。这个地方需要进一步分析汇编代码，有兴趣的读者可以再试试。 相关链接 一篇文章走进Mac逆向的世界 最简单的Hopper Disassembler玩转Mac逆向 macOS 逆向之生成动态注入 APP X86-64寄存器和栈帧]]></content>
      <categories>
        <category>iOS</category>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[碎碎念]]></title>
    <url>%2Farticle%2F%E7%A2%8E%E7%A2%8E%E5%BF%B5.html</url>
    <content type="text"><![CDATA[记录在写技术博客时想到的杂谈。 不要老是想着一次性就能把文章写好。比如你现在看的 Runtime，Apple 积蓄了十几年的东西。一个技术点你花个几小时就能了解完不太现实的。你应该先想到什么就写什么，然后多看看其他的博客，取长补短。再多看几遍源码，看着看着熟悉了。每次看出些新的东西，熟悉写过的知识。一点一点积累，每次尝试站在全局的角度回顾一下。]]></content>
      <categories>
        <category>gossip</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Runtime三类的结构]]></title>
    <url>%2Farticle%2FRuntime%E4%B8%89%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[在 Runteim一 中我们已经看到过类的结构体 Object.mm1typedef struct objc_class *Class; objc-rutime-new.h12345678910111213struct objc_class : objc_object &#123; // Class ISA; // 继承的 isa；8 bytes Class superclass; // 父类；8 bytes cache_t cache; // 方法缓存；16 bytes class_data_bits_t bits; // 包含类数据的地址 class_rw_t *data() &#123; return bits.data(); &#125; void setData(class_rw_t *newData) &#123; bits.setData(newData); // 省略一大波&#125; cache 方法缓存 方法缓存另讲。这里只看看其成员 objc-runtime-new.h12345678typedef uint32_t mask_t;struct cache_t &#123; struct bucket_t *_buckets; // 8 bytes mask_t _mask; // 4 bytes mask_t _occupied; // 4 bytes //省略函数&#125; 得出该结构体大小 16 bytes，后面我们推断内存地址用。 123456789struct bucket_t &#123;private:#if __arm64__ MethodCacheIMP _imp; // 8 bytes 方法实现 cache_key_t _key; // 8 bytes 方法编号#else cache_key_t _key; MethodCacheIMP _imp;#endif 用一个结构体将方法编号和对应的实现互相绑定。ARM64下方法实现在内存中靠前存放，其他架构靠后存放。为什么？ 成员变量 bits 其实 bits 并不能直接得到类数据，还需要和一个 MASK 进行运算。 先看一下结构体成员确定内存大小 objc-runtime-new.h123456typedef unsigned long uintptr_t;struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;&#125; 64 位下 long 占 8 bytes。也就是结构体的大小。综合一下得出objc_class在内存中占 40 bytes。之后验证我们需要根据字节数进行偏移。 获取类的数据：objc_class::data()，该函数又调用了class_data_bits_t::data() objc-runtime-new.h12345678910#if !__LP64__ #define FAST_DATA_MASK 0xfffffffc // ARM64#elif 1 #define FAST_DATA_MASK 0x00007ffffffffff8 // X86_64 下和 ISA_MASK 一样的#else#endifclass_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 类的可读可写数据 函数最终返回一个结构体指针，这个结构体中就是真正的数据。这里面的数据是可读写的。 const 离谁近就修饰的谁 objc-runtime-new.h123456789101112131415struct class_rw_t &#123; uint32_t flags; // uint32_t version; // 版本号 const class_ro_t *ro; // 只读数据 method_array_t methods; // 方法列表 property_array_t properties;// 属性列表 protocol_array_t protocols; // 协议列表 Class firstSubclass; // 当前类的首个子类 Class nextSiblingClass; // 姊妹类（当前类和这个继承自同一个类） char *demangledName; //类的符号名&#125; 数据中我们重点关注 ro, methods, properties，protocols。 首先 LLDB 调试一下，验证内存是否如此分布。调试还是在 X86_64 环境下进行。验证代码在文末 类的只读数据 ro 结构体定义 objc-runtime-new.h12345678910111213141516171819202122struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; // 存储实例成员的起始内存偏移 uint32_t instanceSize; // 实例成员大小#ifdef __LP64__ uint32_t reserved; // 保留字段，ARM64下没有#endif const uint8_t * ivarLayout; // type-encoding ？ const char * name; // 类名 method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; // 实例成员列表 const uint8_t * weakIvarLayout; // weak 修饰的成员 property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;; 从这里能得出为什么我们不能在分类添加成员变量的原因。分类加载时，主类已经初始化完毕。实例成员列表 *ivars 有 const修饰，因此一旦初始化就不能再被更改。属性列表不是只读的，因此分类可以添加属性。但是不能生成成员变量，当然也不会有 setter 和 getter 方法。 baseProperties 在 class_ro_t中是一个指针变量。由于 ro 只读，因此该指针变量不可被修改，但是其内容应该是能修改的。 ro的内存分布 细心的读者可能已经发现，rw和ro中的方法列表、属性列表和协议列表地址都是相同。笔者没弄明白为什么要这么设计？？？ method_list_t、ivar_list_t和property_list_t 都是继承自模板结构体` objc-runtime-new.h123456789101112131415161718192021222324template &lt;typename Element, typename List, uint32_t FlagMask&gt;struct entsize_list_tt &#123; // entsize_list_tt 的大小:flag // method_list_t: 低2位为 flag，高14位为大小 flagMasK 为 0x3 // ivar和 property list: 4个字节都表示大小 flagMasK 为 0x0 uint32_t entsizeAndFlags; uint32_t count; // 方法/成员/属性的数量 Element first; // 第一个方法/成员/属性的数据 uint32_t entsize() const &#123; return entsizeAndFlags &amp; ~FlagMask; &#125; // 普通打印结构体只能查看第一个元素，对于其他的我们通过调用 get(int)获取。其算法就是在首元素的基础上进行偏移 。 Element&amp; getOrEnd(uint32_t i) const &#123; assert(i &lt;= count); return *(Element *)((uint8_t *)&amp;first + i*entsize()); &#125; Element&amp; get(uint32_t i) const &#123; assert(i &lt; count); return getOrEnd(i); &#125;&#125; 与之相近的还有class_rw_t中的method_array_t、property_array_t和protocol_array_t，但它们是继承自模板类 1234567template &lt;typename Element, typename List&gt;class list_array_tt &#123; struct array_t &#123; uint32_t count; List* lists[0]; &#125;&#125; 其中的 Element 和 List 是泛型，前者继承时会替换为对应的结构体类型，后者会对应替换为method_list_t、ivar_list_t和property_list_t。 objc-runtime-new.h12345678910111213141516171819struct method_t &#123; SEL name; // 方法名 const char *types; // type-encoding MethodListIMP imp; // 方法实现&#125;struct ivar_t &#123; int32_t *offset; // 相对于偏移 const char *name; // 实例变量名 const char *type; // 变量类型 // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; // 对齐 uint32_t size; // 占用内存大小&#125;struct property_t &#123; const char *name; // 属性名 const char *attributes; // 属性类型，type-encoding&#125;; 查看一下 method list并遍历出所有方法名 ![method_list_t](https://i.loli.net/2019/03/22/5c93e11b3a388.jpg) 遍历出的方法列表中并没有未实现的方法，同时类方法也没有出现。类方法应该出现在元类中。关于类方法其实[上一篇文章翻译的倒数第二段](http://roastduck.xyz/article/Runtime%E4%BA%8C%E5%AF%B9%E8%B1%A1-%E7%B1%BB%E5%AF%B9%E8%B1%A1-%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1.html)已有提及。感兴趣的读者可以自行尝试。 调试代码Person.h1234567891011121314@interface Person : NSObject @property (nonatomic, copy) NSString *name;@property (nonatomic, assign) int age; // 实现- (void)run:(NSInteger)distance;+ (void)walk; // 不实现- (void)sing;+ (void)eat;@end Person.m1234@implementation Person&#123; NSString *address; bool sex;&#125; main.m1234567Person *p = [Person alloc];p.name = @"songyang";p.age = 20;[p run:100];[Person walk];]]></content>
      <categories>
        <category>iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime二对象-类对象-元类对象]]></title>
    <url>%2Farticle%2FRuntime%E4%BA%8C%E5%AF%B9%E8%B1%A1-%E7%B1%BB%E5%AF%B9%E8%B1%A1-%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[先上原文翻译 OC 是一门基于类的面向对象语言。每个对象都是某一个类的实例；对象的联合体成员变量isa指向它的类。类描述了对象的状态：占用内存大小、成员类型和布局；还描述了对象的行为：对象能响应的方法和已经实现的实例方法。？ 类的方法列表保存了实例方法以及对象能响应的方法。向实例对象发送消息的过程，就是调用objc_msgSend函数去查实例对象的类(或父类)方法列表，匹配成功则调用。 每个 OC 类也是一个对象，也有 isa和其他数据成员以及响应的方法。调用类方法，比如[NSObject alloc]，就是在向类对象发送消息。 既然类也是对象，那它一定是其他某个类的实例，我们称之为元类。正如类描述了实例对象的信息，元类描述的是类对象的信息。注意，元类的方法列表存放的是类方法，由类对象调用。向类(元类的实例)发送消息，objc_msgSend会去查找元类(或父元类)的方法列表，匹配成功则调用。元类代表类对象描述了类方法，类代表实例对象描述了实例方法。 元类对象呢？元类的元类并且一直持续？当然不是。某一元类是根类的元类的实例；根源类的元类是它本身。isa走位链在根源类这里结束：实例-&gt;类-&gt;元类-&gt;根元类-&gt;根元类自己。元类对象的 isa 指向并不重要，因为我们不会向元类对象发送消息。 相比而言，元类的父类更为重要。元类的父类走位链和类的父类走位链是相互独立的，所以类方法的继承和实例方法的继承也互相独立。根元类的父类是根类，所以类对象能响应根类的实例方法。结论：和其他对象一样，类对象是根类的实例(或子类)。 是不是二晕二晕的？一起来理一下。记住，向对象发送消息时，方法查找起始点是对象isa指向的类，然后是父类链。实例方法定义在类中，类方法定义在元类和根类(不是根元类)中。 在一些计算机语言科学理论中，类和元类的继承关系更加自由，比如更进一步的元类链，任一元类能实例化多个类。OC 使用元类的目的是存储类方法，但同时又想隐藏元类。比如，[NSObject class]和[NSObject self]等价，但前者理论上应该返回NSObject-&gt;isa指向的元类。OC 根据实际情况做了很多妥协，比如这里就限制了类的schema（应该是想说明 NSObject 指向自己，这里实在不知道怎么翻译），以免NSObject太元类了。 祭图，再说一遍 isa走位：object_getClass(实例) -&gt; object_getClass(类) -&gt; object_getClass(元类) -&gt; object_getClass(根元类) -&gt; object_getClass(根元类)。 isa 最终指向根元类。 superclass走位：[实例 class] -&gt; [类 superclass] -&gt; [父类 superclass] -&gt; [根类 superclass] -&gt; nil。 superclass 最终指向 nil。 根元类的父类指向根类，最后指向 nil。 isa 走位验证Person.h 123456@interface Person : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) int age;@end ViewController.m1Person *p = [Person alloc]; 所有对象都是objc_object结构体，有一个 isa成员。所有类对象都是objc_class结构体，继承自objc_object。所以第一个 8 字节就是 isa。OBJECTIVE2 后的 isa不仅包含类的地址，其 bit 位还存储有其他信息。因此需要 &amp; 0xffffffff8。详细看这 shiftcls 字段 po 命令：打印类型 p/x将结果以 16 进制显示 x 读取内存中的值 除了上面的lldb调试，也可以使用 object_getClass(Class)函数验证。 父类指针走位 objc_class继承自objc_object，默认第一个为 isa，第二个 8 bytes 才是 superclass。该成员直接就表示的父类地址。]]></content>
      <categories>
        <category>iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>isa</tag>
        <tag>superclass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-non-pointer-isa]]></title>
    <url>%2Farticle%2FiOS-non-pointer-isa.html</url>
    <content type="text"><![CDATA[目前 Apple 无论是 iOS 还是 macOS 都只支持 64 位。但是呢，又没有完全使用 64 位虚拟地址。比如 ARM64 上目前使用33位作为对象地址，X86_64 使用 44 位。为了提升app 运行效率和减少内存消耗，Runtime 利用剩余的 bit 存储一些对象的信息，比如 retain count 或 是否有弱引用指向。 在 ARM64 上，Objective-C 对象的 isa 字段不再是指针，而是一个联合体。 objc-private.h12345678910union isa_t &#123; Class cls; // struct objc_class * uintptr_t bits; // unsigned long #if defined(ISA_BITFIELD) struct &#123; // 64位的 结构体位域 ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125; 里面定义了一个类指针，一个结构体位域，一个统一描述所有位的 bits 成员。他们都是8个字节。获取对象的 isa 时，使用object_getClass而不是objc-&gt;isa，除非你能确定 isa 中bit 位除了类对象地址不含其它意义。 重点看看位域中的 bit 含义 isa.h_ARM6412345678910#define ISA_BITFIELD uintptr_t nonpointer : 1; // 当前 isa 被用作指针还是联合体 uintptr_t has_assoc : 1; // 是否有其他引用指向该对象 uintptr_t has_cxx_dtor : 1; // 是否有析构函数 uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ uintptr_t magic : 6; // 区分对象是否已经初始化：arm64上为 0x16，x86_64上为 0x3b uintptr_t weakly_referenced : 1; // 是否有 weak 修饰引用指向该对象 uintptr_t deallocating : 1; // 是否正在被释放 uintptr_t has_sidetable_rc : 1; // 引用计数进位，将多出的计数存储到 refcount 中 uintptr_t extra_rc : 19 // 存储引用计数。如果 extra_rc = 3, 那么retain_count = 4。如果溢出，has_sidetable_rc 置 1。 nonpointer（第0位）: 为0时，联合体中存储的内容仅代表一个类对象指针，其他 bit 位不作额外用途。为1时，就可以根据位域中对应的字段获取额外存储的信息。 has_assoc（第1位）: 该对象是否关联其他对象(含有属性之类的)。该 bit 位在调用 objc_setAssociatedObject函数时置为1。 has_cxx_dtor（第2位）: 是否有自定义的析构函数。对象没有析构函数释放更快？？？ shiftcls（第3~35位）: 类对象地址。为什么33位? 在 isa 初始化的时候赋值，newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;。为什么右移 3 位？OC 对象的存储是 8 字节对齐，也就意味着对象地址的后三位一定是 0。既然这3位是定值，那为什么要浪费3个 bit 来存储呢。当我们需要取类对象地址的时候，读出该位域字段，然后在左移3位即可得到原地址。但是这不就有两个步骤了吗！优化一下：shiftcls之后不正好有 3 bit 吗，我把第 0~36位都读出来，同时将后3位置0不也一样。这就是为什么ISA()函数 objc-object.h1234#define ISA_MASK 0x0000000ffffffff8Class ISA() &#123; return (Class)(isa.bits &amp; ISA_MASK);&#125; 一个16进制数搞定两个步骤，OC 对内存的优化可见一斑。 has_sidetable_rc和extra_rc MRC 下调用 - retainCount方法获取引用计数 NSObject.mm123- (NSUInteger)retainCount &#123; return ((id)self)-&gt;rootRetainCount();&#125; objc-object.h123456789101112// 代码省略很多inline uintptr_t objc_object::rootRetainCount()&#123; isa_t bits = LoadExclusive(&amp;isa.bits); if (bits.nonpointer) &#123; uintptr_t rc = 1 + bits.extra_rc; if (bits.has_sidetable_rc) &#123; rc += sidetable_getExtraRC_nolock(); &#125; return rc; &#125;&#125; 这两个都是跟存储引用计数相关的。extra_rc虽说存储引用计数，但是真正获取到的要在它的基础上加 1.（为什么？需要查它的赋值）如果 bits.has_sidetable_rc 位为1，需要再加上额外存储的引用计数。 先说结论，如果引用计数太大，extra_rc不能存储，has_sidetable_rc置 1 ，多出的引用计数使用 struct SideTables中的RefcountMap refcnts;引用计数“表”存储。由于 Runtime 源码是 X86_64 架构的，所以这里只在 mac 下验证。 objc_object.h123456789101112131415id objc_object::rootRetain(bool tryRetain, bool handleOverflow)&#123; isa_t oldisa; isa_t newisa; do &#123; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc++ if (slowpath(carry)) &#123; newisa.has_sidetable_rc = true; &#125; &#125;&#125; addc内部的函数实现看不到，只能手动调试。has_sidetable_rc的赋值只有这一个地方。carry == 1时才能进入 if 语句。因此我们就验证 carry 什么时候为1即可。这里是强行修改 extra_rc 字段，跳出函数后程序是会崩溃。 注意这里应该在do 语句之前修改 isa.extra_rc，而不是临时变量的。 先修改 extra_rc为0xFE即254，此时的retainCount就该为 255，还未溢出，因此 carry = 0。接下来修改extra_rc为0xFF，此时retainCount为256，已经溢出，因此carry = 1。此时由于 handleOverflow为false, rootRetain会重新被调用并将handleOverflow置为 true。然后将has_sidetable_rc = true; 参考链接 http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html https://github.com/Draveness/Analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md]]></content>
      <categories>
        <category>iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>isa</tag>
        <tag>non-pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发-本机作为外围设备角色开发]]></title>
    <url>%2Farticle%2FiOS%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91-%E6%9C%AC%E6%9C%BA%E4%BD%9C%E4%B8%BA%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87%E8%A7%92%E8%89%B2%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[本机作为服务提供者。 CBPeripheralManager对象表示外围设备（当前提供服务的app）。用于发布和广播服务，响应中心设备发来的读写请求。CBCentral对象表示中心设备。我们需要处理它发过来的request。 CBPeripheralManagerDelegate协议1. 创建外围设备管理对象12345678/* @param options 一个字典值 * 用于在实例化时，蓝牙断开是否提示用户，默认为NO * CBPeripheralManagerOptionShowPowerAlertKey : NSNumber Bool * 用于唯一标识外围设备对象的字符串 : NSString * (16位或32位或者是蓝牙技术联盟规定的16位标识) * CBPeripheralManagerOptionRestoreIdentifierKey */self.peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil]; 创建好后调用代理方法检查蓝牙状态123456/** * 成功实例化一个外围设备对象时调用，确定设备是否支持蓝牙以及是否可用 */- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral &#123; // 判断状态&#125; 状态参数具体查看相关概念章节中的CBManagerState部分 2. 创建特征12345678910111213/** 创建一个特征 */- (CBMutableCharacteristic *)createCharacteristicWithUUID:(CBUUID *)uuid &#123; CBMutableCharacteristic *characteristic = [[CBMutableCharacteristic alloc] initWithType:uuid properties: CBCharacteristicPropertyRead | CBCharacteristicPropertyWrite value:[@&quot;songyang&quot; dataUsingEncoding:NSUTF8StringEncoding] permissions:CBAttributePermissionsReadable]; return characteristic;&#125; UUID：特征的唯一标识，UUID相关请参看相关概念章节properties：特征的属性，具体查看相关概念章节中的CBCharacteristicProperties部分value：特征的值，如果在此处设置了值，那么值会被缓存并且properties和ermissions被设为只读。如果需要值可写或者值能动态变化，就需要实例化时置value为nil。permissions：特征的值的权限。具体查看相关概念章节中的CBAttributePermissions部分。 Tip：两个特征的建议配置 订阅方式能使中心设备以较节能的方式获取值，这样外围设备也能做到在需要的时候才响应请求。所以苹果鼓励使用CBCharacteristicPropertyNotify。 为了保证安全，建议使用CBCharacteristicPropertyNotifyEncryptionRequired或者CBCharacteristicPropertyIndicateEncryptionRequired，只允许受信任设备交互，尤其是特征的值能被写入的情况。这样才会在链接时看到是否允许配对的界面框???。 另外要记得保持一致。总不能properties设了只读，然后pemissions又设成可写吧。3. 创建服务123456789101112/** 创建一个服务 @param uuid 唯一标识 param primary YES为主服务，用于描述一个设备的主要功能。主服务可以被其他服务引用。 NO为次要服务,用于描述一个被它引用的其他服务的相关功能 如计步器主要服务是记录步数，次要服务可以是记录时间，距离等。 */- (CBMutableService *)createServiceWithUUID:(CBUUID *)uuid &#123; CBMutableService *service = [[CBMutableService alloc] initWithType:uuid primary:YES]; return service;&#125; 将服务和特征进行关联12// 一个服务可以有多个特征service.characteristics = @[characteristic]; 4. 发布服务12345/** 发布服务 * 一旦发布服务，服务和它的特征会被缓存，服务不能再被修改 */[self.peripheralManager addService:service]; 添加服务后调用代理123- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error &#123; // 处理后续或错误&#125; 5. 向外广播服务 123456789/** 广播部分服务和特征。 */- (void)adviseServices:(NSArray *)services &#123; for (CBMutableService *service in services) &#123; // 广播数据 [self.peripheralManager startAdvertising:@&#123;CBAdvertisementDataServiceUUIDsKey :@[service.UUID]&#125;]; &#125;&#125; startAdvertising:的参数advertisementData是一个字典值，其中包含要广播出去的数据和它对应的key。需要注意的iOS中这些数据不仅对大小有限制，数据内容也有。比如广告包中虽然可以包含外围设备的很多信息，但是iOS中只能传递以下两个：123// CBPeripheralManager 仅支持两个key:* `CBAdvertisementDataLocalNameKey` : value = 服务名称* `CBAdvertisementDataServiceUUIDsKey` : value = 服务UUID数组 对于大小限制，一个广告包为31个字节，除去必要的2个字节作为头信息（数据段的长度和类型），剩下的为数据段。如果app正在运行，以上两个key代表的信息大小限制为28个字节；如果大小不够，在响应包中还能额外使用10个字节，但是仅能用于传递服务名字。 不符合已分配空间的UUID会加入一个特殊的“溢出”包，该类型数据包只能被iOS设备扫描？？？（此处还需填坑）。如果app在后台运行，则只能通过“溢出”包广播服务的UUID。 蓝牙数据包格式：Bluetooth 4.0 specification, Volume 3, Part C, Section 11参考链接:https://www.cnblogs.com/smart-mutouren/p/5882038.html开始广播服务后，会调用代理123- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error &#123; // 处理后续或错误&#125; 接下来就是等待中心设备扫描和连接。当连接建立后，就可以收到中心设备的请求并开始处理（通过代理方法）。 一旦链接建立，外围设备就不需要再广播广播包。因为设备间可以直接进行数据交互（交互方式？？？）。此时为了节省电量，应该及时停止广播：1[self.peripheralManager stopAdvertising]; Tip： 什么时候需要广播广播包？需要和中心设备连接的时候，如果有需要，甚至可以在创建好CBPeripheralManager对象后就开始广播。不过扮演外围角色的app并没有探测其他设备的方式，而用户是能直接知道的。所以最好提供一个界面让用户自己选择是否startAdvitising:。 发布服务和广播服务都必须在powered on状态下进行。 如果此时app进入后台，而我们又没有进行后台处理，广播会停止。 6. 响应中心设备发来的读写请求响应读取请求(两种方式) 中心设备调用readValueForCharacteristic发送读取请求，外围设备收到后，会调用代理 1234567891011121314151617181920/** 收到读取数据的请求 @param request 读数据的请求，已被包装过（CBATTRequest对象） */- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request &#123; // 根据请求中的信息进行响应 // 确认请求的特征UUID是否存在 if ([request.characteristic.UUID isEqual:self.characteristic.UUID]) &#123; &#125; // 检查读取的偏移量(从哪开始读)是否超出本地数据长度 if (request.offset &gt; self.characteristic.value.length) &#123; // 超出则返回越界错误 [self.eripheralManager respondToRequest:request withResult:CBATTErrorInvalidOffset]; return; &#125; // 从请求的偏移量开始读取之后的数据 request.value = [self.characteristic.value subdataWithRange:NSMakeRange(request.offset, self.characteristic.value.length - request.offset)]; // 更新请求的值后，向中心设备回传请求结果（必须调用，成功则返回数据，失败返回错误） [self.peripheralManager respondToRequest:request withResult:CBATTErrorSuccess];&#125; 中心设备通过订阅方式读取数据 1234567891011121314151617181920212223242526/** 收到中心设备(setNotifyValue:YES forCharacteristic:)调用该代理 */- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic &#123; // 修改特征值 // centrals 为nil，表示向所有订阅了的中心设备发通知。当然也可以通过数组指定通知 // 当发送通知的队列不足时，该方法返回NO；此时进入等待，当有可用队列时会触发代理peripheralManagerIsReadyToUpdateSubscribers: BOOL didSendValue = [myPeripheralManager updateValue:updatedValue forCharacteristic:characteristic onSubscribedCentrals:nil]; if (!didSendValue) &#123; // 将未发送的特征保存，之后重新发送 [self.shouldSendArray addObject:characteristic]; &#125;&#125;/** 有可用队列时，调用该代理继续发送通知 */- (void)peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)peripheral &#123; BOOL didSendValue = [self.peripheralManager updateValue:updatedValue forCharacteristic:characteristic onSubscribedCentrals:nil];&#125;/** 收到中心设备(setNotifyValue:NO forCharacteristic:)取消订阅特征的请求 */- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic &#123;&#125; 响应写入请求收到该请求，调用代理123456789101112/** 收到中心设备写入数据的请求 @param requests 写数据的请求，已被包装过。注意这里是数组，可能包含多个写请求 */- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests &#123; // 确认权限后，能写则写。写的时候也需要考虑偏移量 myCharacteristic.value = request.value; // 如果所有请求都被完成，回传写入成功。随便取一个request // 如果数组中有任意一个请求完成失败，那么后续请求都不用再响应。直接将失败的原因回传 // 该方法必须调用 [self.peripheralManager respondToRequest:requests.firstObject withResult:CBATTErrorSuccess];&#125; 7. 调试问题笔者在设备调试时，曾一直卡在以下问题上。现填坑如下： XPC Connection invalid CBPeripheralManager对象需要被全局持有（使用属性）。如果你将Manager封装在B类中，然后在C类中使用；那么C类也需要全局持有B类。原因是CBPeripheralManager对象（包括CBCentralManager对象）是异步创建的，创建成局部对象会很快被释放。参考链接：@蒋小飞http://www.jianshu.com/p/ec659ffcacfe的“编码”部分。 设备不支持（state：unsupported） 这个一方面可能是你的设备真的不支持BLE（通过你的设备信息去了解），另一方面可能是项目配置问题。 笔者使用mac app项目作为外部设备，然后用真机作为中心设备。运行mac app时一直出现以上两个问题。解决如下：（运行环境macOS 10.13，xcode 9.2 beta）Targets-&gt;Capabilities中勾选]]></content>
      <categories>
        <category>iOS</category>
        <category>功能开发</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发-本机作为中心设备角色开发]]></title>
    <url>%2Farticle%2FiOS%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91-%E6%9C%AC%E6%9C%BA%E4%BD%9C%E4%B8%BA%E4%B8%AD%E5%BF%83%E8%AE%BE%E5%A4%87%E8%A7%92%E8%89%B2%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[顾名思义，就是本机搜索其他蓝牙设备进行读写。CBCentralManager对象表示中心设备，用于管理已发现和已连接的外围设备。包括发现外围设备、发起连接、断开连接。CBPeripheral对象表示外围设备。我们要获取数据就需要处理CBPeripheral对象中的服务(CBService)和特征(CBCharacteristic)![中心设备角色][1] CBCentralManagerDelegate协议部分1. 创建中心设备管理对象123dispatch_queue_t queue = dispatch_get_global_queue(0, 0);// queue 可以为nil，就在主线程中工作self.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:queue options:nil]; 创建对象后会调用下面的代理方法，可以在其中检查蓝牙的状态1234567891011121314151617/** 创建好中心设备对象后的回调，确定设备是否支持蓝牙以及是否可用 * @constant CBManagerStateUnknown 未知状态，立即刷新. * @constant CBManagerStateResetting 重置蓝牙，链接暂时断开，立即刷新. * @constant CBManagerStateUnsupported 设备不支持蓝牙4.0 . * @constant CBManagerStateUnauthorized 应用尚未被授权. * @constant CBManagerStatePoweredOff 蓝牙处于关闭状态. * @constant CBManagerStatePoweredOn 蓝牙处于开启状态. */- (void)centralManagerDidUpdateState:(CBCentralManager *)central &#123; // NS_ENUM形式的枚举，使用 == 判断 if (CBManagerStatePoweredOn == central.state) &#123; // do something 可以开始扫描什么的 [self.centralManager scanForPeripheralsWithServices:nil options:nil] &#125;&#125; 2. 搜寻外围设备12// 搜索给定UUID服务的外围设备，nil表示搜索所有的[self.centralManager scanForPeripheralsWithServices:nil options:nil]; options是一个字典，指定两个选项 CBCentralManagerScanOptionAllowDuplicatesKey：默认为NO(需要用NSNumber包装)，表示不会重复扫描已发现蓝牙设备，否则会增加耗电。但是笔者在实现时没发现有什么不同，都在不停扫。o(╯□╰) 关闭蓝牙重新连接就满足要求了 o(╯□╰)o CBCentralManagerScanOptionSolicitedServiceUUIDsKey：value是一个包含指定UUID服务的数组。 当扫描到一个外围设备时，触发代理。提升peripheral为属性以便之后继续使用。1234567891011121314151617181920212223242526272829/** 搜寻到外围设备时调用，发现一个调用一次 @param advertisementData 扫描时收到的广告包 @param RSSI 信号强度，一个负数 */- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI &#123; switch (peripheral.state) &#123; case CBPeripheralStateDisconnected: NSLog(@&quot;链接断开&quot;); break; case CBPeripheralStateConnecting: NSLog(@&quot;链接ing&quot;); break; case CBPeripheralStateConnected: NSLog(@&quot;链接建立&quot;); // 找到想要链接的设备时，应该终止搜索以节省电量。 [self.centralManager stopScan]; break; case CBPeripheralStateDisconnecting: NSLog(@&quot;链接正在断开&quot;); break; default: break; &#125; // 连接设备 [self.centralManager connectPeripheral:peripheral options:nil];&#125; Tip： 除非特殊情况（如需要根据信号强度来连接设备等）不对已发现设备重复扫描。123456// 因为该key默认是NO，所以可以将 options 设为 nil[self.centralManager scanForPeripheralsWithServices:nil options:@&#123;CBCentralManagerScanOptionAllowDuplicatesKey: [NSNumber numberWithBool:NO]&#125;];``` * 由于中心设备开启扫描后不会自动停止，所以苹果推荐在匹配到合适设备时主动停止。可以通过`CBPeripheral`的属性`name`或者`identifier(NSUUID *)`来确定我们需要的设备。一旦确定就可以调用`[self.centralManager stopScan]`终止扫描。### 3. 连接外围设备 // 连接设备[self.centralManager connectPeripheral:peripheral options:nil];1遵循协议`CBPeripheralDelegate`，实现对数据的读写 /* 链接外围设备成功时调用，此时可以开始对外围设备进行读写了 / (void)centralManager:(CBCentralManager )central didConnectPeripheral:(CBPeripheral )peripheral { // 设定外围设备的代理 peripheral.delegate = self; [peripheral discoverServices:nil];}123## CBPeripheralDelegate协议部分### 4. 获取外围设备可用服务 // nil 会搜索所有服务[peripheral discoverServices:nil]1成功发现服务时，调用代理 (void)peripheral:(CBPeripheral )peripheral didDiscoverServices:(NSError )error { // 所有可用服务都包含在其中 for (CBService *service in peripheral.services) { // 180A 表示 Device infomation if ([service.UUID.UUIDString isEqualToString:@&quot;180A&quot;]) { [peripheral discoverCharacteristics:nil forService:service]; } }}1### 5. 获取服务的特征 // 获取指定服务的特征, nil 获取所有[peripheral discoverCharacteristics:nil forService:service]1获取成功后，调用代理 /* 发现特征时调用，调用一次 / (void)peripheral:(CBPeripheral )peripheral didDiscoverCharacteristicsForService:(CBService )service error:(NSError )error { // 包含所有特征 for (CBCharacteristic characteristic in service.characteristics) { // 读取特征值 }}1`Tip`：因为一个外围设备有多个服务，一个服务又有多个特征，而一般我们只需要一部分服务或特征。所以我们在获取服务或特征时，通过UUID仅得到我们需要的即可。 // nil 会搜索所有服务，但是耗时耗能，所以尽量传入服务uuid// 获取服务[peripheral discoverServices:数组]; // 获取指定服务的特征[peripheral discoverCharacteristics:数组 forService:service];12### 6. 读写操作特征中就含有我们需要读写的数据。注意不是所有特征值都可读写，依赖于外围设备对特征的配置。通过`CBCharacteristic`的属性`properties`是否包含以下枚举值来判断是否可读写。这是一个`CBCharacteristicProperties`类型的枚举，`NS_OPTIONS`表示枚举值可以组合。 typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) { // 特征的值通过特征的描述符被广播出去 CBCharacteristicPropertyBroadcast = 0x01, // 可读 CBCharacteristicPropertyRead = 0x02, // 可写，外围设备不会回传写入是否成功 CBCharacteristicPropertyWriteWithoutResponse = 0x04, // 可写，外围设备告知中心设备写入是否成功，然后CBPeripheral调用相应代理 CBCharacteristicPropertyWrite = 0x08, // 可订阅,中心设备是否收到通知不会告知外围设备 CBCharacteristicPropertyNotify = 0x10, // 可订阅,中心设备是否收到通知会告知外围设备，然后CBCentral调用相应代理 CBCharacteristicPropertyIndicate = 0x20, // 写入不成功时不会回传错误？？ CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, // 可以在特征的属性描述符中添加额外的特征属性 CBCharacteristicPropertyExtendedProperties = 0x80, // 只能订阅受信任设备广播的特征的值，不会告知外围设备是否收到通知 CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(10_9, 6_0) = 0x100, // 只能订阅受信任设备广播的特征的值，会告知外围设备是否收到通知 CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(10_9, 6_0) = 0x200};1234##### 读操作通过直接读取或订阅的方式获取特征的值。* 直接读取 // NS_OPTIONS形式的枚举，使用 &amp; 判断是否包含if (characteristic.properties &amp; CBCharacteristicPropertyRead) { [peripheral readValueForCharacteristic:characteristic];}12345* 通过订阅的方式(推荐)，类似观察者 一次值读取就是一次交互，就要使用设备信号。如果一个特征的值可能变化可能不变时，直接读取就需要不停调用`readValueForCharacteristic:`方法。当一段时间内数据保持不变，使用`readValueForCharacteristic:`方法就会造成不必要的数据交互从而消耗电池。 如何避免呢？最好就是当特征的值变化时，外围设备通知相应的中心设备，中心设备收到通知在去读取值。 如何做到？使用订阅。 // 动态变化值使用通知订阅更高效// 外围设备特征的值改变时，发出通知，订阅了该特征值的中心设备收到通知后更新值// 不是所有特征值都可订阅，最好判断一下if (characteristic.properties &amp; CBCharacteristicPropertyNotify) { [peripheral setNotifyValue:YES forCharacteristic:characteristic];}1启用订阅后，调用代理 /* 外围设备收到启用或停止通知请求后会调用 / (void)peripheral:(CBPeripheral )peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic )characteristic error:(NSError *)error { }12读取或订阅的特征的值改变后，调用代理 /* 特征值改变时调用, 两种读取方式都要走该代理 @param error 读取特征值失败时 / (void)peripheral:(CBPeripheral )peripheral didUpdateValueForCharacteristic:(CBCharacteristic )characteristic error:(NSError )error { // 得到特征值 NSData data = characteristic.value; NSString *str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];}1234##### 写操作写入数据时以二进制数据操作，需要使用`NSData`包装。一个特征是否可写入及写入方式，可通过`properties`是否包含`CBCharacteristicPropertyWriteWithoutResponse`或`CBCharacteristicPropertyWrite`确定。 if (characteristic.properties &amp; CBCharacteristicPropertyWrite) { [peripheral writeValue:data forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse]; }1`CBCharacteristicWriteWithResponse`和`CBCharacteristicWriteWithoutResponse`，前者写入数据后调用下面的代理方法，告知我们写入是否成功。后者不会调用。 /* 使用 CBCharacteristicWriteWithResponse 写入方式才调用该代理方法 写入失败，则会通过error提示错误信息 / (void)peripheral:(CBPeripheral )peripheral didWriteValueForCharacteristic:(CBCharacteristic )characteristic error:(NSError *)error { }123456### 7. 断开连接由于蓝牙广播或扫描时，使用的是设备信号。而设备信号也用于WIFI等其他功能。同时信号强度又会影响电池使用。为减小影响，需要最小化对信号的使用。当中心设备订阅的特征不再发送通知后（`CBPeripheral`对象的`isNotifying`属性）或者 我们已经拿到所有需要的数据后，应该及时取消订阅然后断开和外围设备的连接。 // 为每一个订阅过的特征 设置 值 为 NO[peripheral setNotifyValue:NO forCharacteristic:characteristic];123```// 仅断开当前app与外围设备的连接，不会关闭蓝牙。因为可能有其他app也在使用蓝牙[self.centralManager cancelPeripheralConnection:self.peripheral]; 断开连接后，调用代理12345- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error &#123; NSLog(@&quot;disconnect error: %@&quot;, error.userInfo); // 异常断开，可以做重连&#125; 8. 重新连接有三种重新获取外围设备的方式： 所需外围设备仅和本地app断连，但并未和中心设备断开连接，则应使用服务(CBUUID *)尝试获取CBPeripheral。成功 array 就不为空，从中选择需要的 peripheral。否则尝试后面两种方法。 1NSArray *array = [central retrieveConnectedPeripheralsWithServices:数组&lt;CBUUID *&gt;]; 本机保存(NSUserDefault等)着连接过的外围设备的(identifier(NSUUID*)，通过它尝试获取CBPeripheral。成功 array 就不为空，从中选择需要的 peripheral。否则尝试重新扫描。 1NSArray *array = [central retrievePeripheralsWithIdentifiers:数组&lt;NSUUID *&gt;]; 通过以上方式都未能重新连接，就只有重新扫描scanForPeripheralsWithServices: options: 之后调用代理centralManager: didDiscoverPeripheral: advertisementData: RSSI: 就能获取扫描到的peripheral 通过以上三种方式获取到需要的peripheral后仍然使用connectPeripheral: options:请求重新连接，最后调用相应代理。 [1]: http://oyo48xwkg.bkt.clouddn.com/1254.png]]></content>
      <categories>
        <category>iOS</category>
        <category>功能开发</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime一对象和方法的本质]]></title>
    <url>%2Farticle%2FRuntime%E4%B8%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8.html</url>
    <content type="text"><![CDATA[在objc4-750.1源码自定义target中新建Person类，写点属性和方法，然后在main.m中创建实例并调用方法。 Person.h12345@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) int age;- (void)run:(NSInteger)distance;+ (void)walk; main.m12345Person *p = [[Person alloc] init];[p run:100];[Person walk]; 编译c++代码 将main.m和Person.m编译成arm64对应的 c++ 代码。终端执行下面的命令，会在同级目录下生成main.cpp和Person.cpp的文件。 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -framework UIKit main.m（Person.m替换） 打开 c++文件，来到main函数。以下是去除类型强转后的代码 main.cpp12345678910111213int main(int argc, const char * argv[]) &#123; // 对象的实例化 Person *p = objc_msgSend(objc_msgSend(objc_getClass("Person"), sel_registerName("alloc")), sel_registerName("init")); // 对象调用实例方法 objc_msgSend(p, sel_registerName("run"), 100); // 类对象调用类方法 objc_msgSend(objc_getClass("Person"), sel_registerName("walk")); &#125; return 0;&#125; 对象的本质对象是一个结构体 来到 c++ 中对实例对象类型Person的声明。 Person.cpp1typedef struct objc_object Person; 很明显，Person实例对象其实是个名为objc_object结构体 objc-private.h12345struct objc_object &#123;private: isa_t isa; // 省略一大波&#125; 平时我们还能听到类对象的说法。通过[p class]能获取实例对象的类，它的返回值类型为 Class。 Object.mm1typedef struct objc_class *Class; objc-rutime-new.h12345678910111213struct objc_class : objc_object &#123; // Class ISA; // 继承的 isa Class superclass; // 父类 cache_t cache; // 方法缓存 class_data_bits_t bits; // 类数据 class_rw_t *data() &#123; return bits.data(); &#125; void setData(class_rw_t *newData) &#123; bits.setData(newData); // 省略一大波&#125; 在 Object2 中类也被当成对象来处理，也有 isa 指向。这也是为什么说 OC中万物皆对象 的原因。看完这两个对象结构体能得出对象都有 isa，只有类对象才有 superclass。但是我们平常为什么也能调用实例对象的superclass方法呢？ Object.mm123456789101112131415- (Class)superclass &#123; return [self class]-&gt;superclass;&#125; - (Class)class &#123; // 获取对象的 isa 指向 return object_getClass(self);&#125;Class object_getClass(id obj)&#123; // 获取 isa if (obj) return obj-&gt;getIsa(); else return Nil;&#125; 原来还是获取类对象的superclass，而且能得出对象的类的获取是通过 isa 得到的。 对象的 isa objc_object结构体只有有一个isa成员变量，其他都是成员函数。isa 实际是一个union联合体。 objc-object.h12345678910111213union isa_t &#123; // 构造函数 isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; // struct objc_class * 指针 8 bytes uintptr_t bits; // unsigned long 8 bytes#if defined(ISA_BITFIELD) struct &#123; // 64位的 结构体位域 ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125; arm64下的 isa不再只是一个指针。 OC 并没有完全利用64位地址。为了节省内存和提高响应速度 Runtime 利用一些额外二进制位来存储对象的部分信息，比如引用计数或是否是弱引用等等。 Greg Parker,Non-pointer isa 联合体包含的3个成员变量Class、uintptr_t和一个结构体位域都是8个字节，所有该联合体的大小是 8 bytes。之前一直以为 isa 是指针所以才是 8 个字节。 union 同一时刻只能操作一个成员，不同时刻可以操作不同成员。 比如我们可以对 bits 赋值，我却可以通过结构体位域去操作一个或几个 bit，得到不同的值，达到存储简单信息的目的。由于成员都是8个字节，我可以一次性赋值或读取，也可以按位赋值或读取。在后面能看到苹果通过不同的 MASK 和 bits 按位与得到不同的值。 位域都是从低地址开始存储。 注意不同 cpu 结构是有区别的。具体的位域值 对象 isa 的获取 获取 isa 指向的两个函数：ISA()和getIsa()。 objc-private.h12345678struct objc_object &#123;private: isa_t isa; public: Class ISA(); // 获取 isa 指向 Class getIsa();// 省略一大波&#125; 当对象指针不是taggedPointer时，getIsa()函数也是调用的ISA()。这里就不贴代码了，直接到下一步。 如何获取 isa 指向的类对象 objc-object.h12345678910111213inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); #if SUPPORT_INDEXED_ISA if (isa.nonpointer) &#123; uintptr_t slot = isa.indexcls; return classForIndex((unsigned)slot); &#125; return (Class)isa.bits;#else return (Class)(isa.bits &amp; ISA_MASK);#endif&#125; SUPPORT_INDEXED_ISA 不用理，ARM64、X86_64 不支持。 这里调试下来是执行了 else 中的语句。arm64 下ISA_MASK 就是 0x0000000ffffffff8。 isa.bits 就需要了解 isa是如何被初始化的。所幸苹果将重要的方法都写在结构体前面的，一眼就找到初始化的几个函数。如果没有，就只能新建对象，一步一步调试了。 objc-private.h12345678910111213141516struct objc_object &#123;private: isa_t isa; public: Class ISA(); // 获取 isa 指向 Class getIsa(); // initIsa() 应该仅用于初始化新对象的 isa，也会用于以下情况之外的对象 // initInstanceIsa(): 初始化没有自定义allocWithZone 和 RR?的实例对象 的 isa （指向所属的类对象） // initClassIsa(): 初始化类对象isa (指向元类对象) // initProtocolIsa(): 初始化协议对象的 isa void initIsa(Class cls /*nonpointer=false*/); void initClassIsa(Class cls /*nonpointer=maybe*/); void initProtocolIsa(Class cls /*nonpointer=maybe*/); void initInstanceIsa(Class cls, bool hasCxxDtor);// 省略一大波&#125; 对象 isa 的初始化 上面的各种初始化接口最终调用私有的 initIsa(Class cls, bool nonpointer, bool hasCxxDtor)函数。传入参数依次为类对象指针，是否是 nonpointer，是否有自定义析构函数 123456789101112131415inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) &#123; // 临时变量 isa_t newisa(0); // ISA_MAGIC_VALUE : 0x000001a000000001，该值包含了 nonpointer(低第一位)和 magic (第37~第42位) newisa.bits = ISA_MAGIC_VALUE; // 是否有析构函数，根据参数是 0 newisa.has_cxx_dtor = hasCxxDtor; // 移除类对象地址后3位的0 newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3; isa = newisa; 再看 isa.bits &amp; ISA_MASK, 就是将取第0~35位，并将低三位置0了。得到的结果就是(元)类对象的地址。这个过程其实是上面cls &gt;&gt; 3的逆过程。至于原因请查看shiftcls字段的介绍 方法的本质 从编译后代码看到，OC 方法都被编译成了objc_msgSend的 c++函数。亦即 OC 方法的本质：消息发送。 不管是实例对象还是类本身，都会将调用方法的对象和方法的编号作为该函数的第一、二个实参。如果方法有其他参数，则会从第三个实参开始往后排。 按照上面的编译方法将Person.m也编译成 c++文件。然后找到实例方法 run 的 c++实现。 main.cpp123static void _I_Person_run_(Person * self, SEL _cmd, NSInteger dis) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_07_13f7q65d7sj09t7q2sj3dymm0000gn_T_Person_390a3b_mi_1, dis);&#125; 编译后的函数默认添加了self和_cmd两个形参，然后才是我们自己方法的形参。而objc_msgSend函数会根据传入对象的isa指针找到对应类，然后根据方法编号_cmd去查找对应的实现。所以self其实是指向方法调用者的指针，我们才能在方法中使用self来调用本类方法和属性。而_cmd就是当前方法的编号。这两者和objc_msgSend的实参是一一对应的。 方法查询走位 向对象发送消息时，先根据对象的 isa 指针查找对象所属类的的方法列表(类的实例方法)，然后根据类的 super_class 指针走父类链直到根类。走位图]]></content>
      <categories>
        <category>iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git初级使用]]></title>
    <url>%2Farticle%2FGit%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[一点点重要的Tip 所有的版本控制系统，只能跟踪文本文件的改动。媒体文件内容不能追踪，只能追踪媒体文件属性，如大小、时间等。 创建SSH连接Github 网上很多教程，但是有可能不完整，所以最好还是对照Github官网上的教程。 创建时遇到的问题问题1：参考链接 12The authenticity of host &apos;github.com (192.30.253.113)&apos; can&apos;t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? ~~ 啥？操作半天你说不能建立···一步步来的，哪儿错老嘛！！！于是no。殊不知这里不用管，直接yes就到下一步，然后就等着成功就对了。! _ ! ~~ 这里是为防止中间人攻击，首次 ssh 链接时，询问是否将 github 公钥保存到本地。之后再连接时，看是否能匹配，否则可能存在信息泄露的风险。 前期配置Git参考链接 1. 查看配置git config --list：列出当前配置项重点关注name、email及url。 2. 修改配置12git config --global user.name Github用户名git config --global user.email Github注册邮箱 使用 在Github新建一个代码仓MyReponsitory。记得选取.gitignore 1. 直接使用服务器代码仓 git clone git@github.com:Github用户名/MyReponsitory.git 2. 本地创建代码仓，再push到Github cd 到根目录 git init 初始化本地目录为代码仓。 git add . 或具体文件名. git开始追踪本地文件。 git status 查看是否还有未提交的修改 git commit -m 描述 提交此次修改 git remote add origin git@github.com:用户名/MyReponsitory.git 把本地仓与Github远程仓库关联 git pull origin master --allow-unrelated-histories将服务器数据先拉取到本地。 git push -u origin master 将本地更改推送到远程服务器。 最好还是先从服务器clone一个版本仓下来，然后往里面加东西，直接add后commit就行了。 3. 修改了文件内容 git status: 查看文件状态 staged：文件被暂存(commit了) modified, unstaged：文件被修改了但是没有被暂存 untracked：文件没有被跟踪 commit或push前检查一下，总是个好习惯。 git pull: 从服务器拉取最新的版本。push前总是保持本地仓和服务器一致，本地仓出问题好过服务器版本出问题，毕竟解决本地仓的冲突要容易的多。 git commit: 提交最新修改内容，尽量简洁概括并包含你所有修改部分。 git push: 记住一定要先pull,上一步commit时没做，此时也一定要做。 4. 添加.gitignore vi .gitignore或者用文本编辑器打开(前提是要显示隐藏文件)。在文件最后添加 12345678910111213# mac系统下用于存储当前文件夹的一些Meta信息，不需要。*.DS_Store # 忽略pods项目中的xcworkspace, 使用了CocoaPods，只需要上传Podfile即可。*.xcuserstateUserInterfaceState.xcuserstate# * 通配符；表示不对后缀.xcworkspace的所有文件追踪*.xcworkspace/# / 目录； 表示对所有名为xcuserdata的目录及其下文件不追踪xcuserdata/UserInterface.xcuserstate # 忽略PodsPods/Podfile.lock 但是有时可能遇到.gitignore失效的情况，这种多半是因为已经commit了。对已经添加版本控制的文件再加入.gitignore是无效的，此时需要删除下缓存。 1234567// 删除前总是先看一下清单，免得误删git rm -n -r –cached 需要忽略的文件(夹-r)// 执行删除git rm -r –cached 需要忽略的文件(夹-r)// 告知服务器git commit -m 删除xx以移除版本控制git push 这种方式也可以用来将指定文件(夹)移除版本控制。 &gt;要移除本地文件版本控制？`sudo rm -R .git`即可 &gt; &gt;**注意： .gitignore只能忽略那些原来没有被track的文件。** 6. 遇到的问题 Github中文件夹不能进入，不可用。使用git status看到子目录状态是ｕｎtrackｅｄ。可能因为子目录也含有.git,删除后回根目录重新init一次 fatal: refusing to merge unrelated histories “git merge” used to allow merging two branches that have no common base by default, which led to a brand new history of an existing project created and then get pulled by an unsuspecting maintainer, which allowed an unnecessary parallel history merged into the existing project. The command has been taught not to allow this by default — @Mark Amery 以前可以直接合并两个不同项目，现在需要加上--allow-unrelated-histories。大概是为了防止一个项目的版本历史被pull到另一个项目上，导致覆盖吧！原谅我只能看个浅意。 不过我这里就是要合并，所以执行下面这句。 git pull origin master --allow-unrelated-histories Please make sure you have the correct access rights and the repository exists. 问题已经提示很明显了，可能是ssh密钥匹配不上，或者是仓库名出错。 前者：执行ssh -v -t git@github.com检查连接，匹配不上说明需要重新上传rsa_pub,详情戳Github官网 后者：就需要检查你的remote连接了。我就是仓库地址出错。可以在终端重新git remote add origin 仓库地址或者vi .git/config，然后修改里面的url。url最好从Github上去复制。]]></content>
      <categories>
        <category>工具</category>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发为app配置代理]]></title>
    <url>%2Farticle%2FiOS%E5%BC%80%E5%8F%91%E4%B8%BAapp%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86.html</url>
    <content type="text"><![CDATA[由于对某款app的租房信息的筛选条件不满意，所以爬取了它的api以便能够根据自己的需求进行筛选。根据自己的初级爬虫经验，为了防止app封禁我的ip，所以准备通过代理服务器去访问。过程是相当纠结啊，尝试的太多，这里就只放结论了。 先决条件： http方式的代理只能访问http网站。 https方式的代理只能访问https网站。注：上面的“只能”指的是访问失败或者能访问但隐藏不了ip。ps：有时代理稳定性也很重要，不行就换换吧。 验证方式： http代理：http://www.whatismyip.com.tw https代理：https://ip.cn 百度搜索“ip”，然后使用浏览器那串网址(嗯···记录时临时想的，我没试过⊙v⊙)。 上代码(Swift)：笔者使用的URLSession，初始化前配置URLSessionConfiguration对象的connectionProxyDictionary即可。 使用http代理，两种任一12345&#123; String(kCFNetworkProxiesHTTPEnable) : true, String(kCFNetworkProxiesHTTPPort) : httpPort, String(kCFNetworkProxiesHTTPProxy) : httpHost,&#125; 12345&#123; &quot;HTTPEnable&quot; : true, &quot;HTTPProxy&quot; : httpHost, &quot;HTTPPort&quot; : httpPort&#125; ps：使用http时，需要添加ATS白名单 2. 使用https代理 12345&#123; &quot;HTTPSEnable&quot; : true, &quot;HTTPSProxy&quot; : httpsHost, &quot;HTTPSPort&quot; : httpsPort&#125; 注：两种代理方式貌似不能同时使用，不确定是因为我测试时上一秒代理还好好的，下一秒就挂了。 另外，过程中遇到最多的就是1200错误码：无法与服务器建立安全连接。网上大多数意见是服务器SSL版本不够，因为iOS最低要就使用TLSv1.2的版本。以下是网上给出的解决方法：(未能验证)1234567891011121314151617&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;your.https.server&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionMinimumTLSVersion&lt;/key&gt; &lt;string&gt;TLSv1.0&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt; 由于我这里是代理字典https key用错了，才导致的1200。所以只能先在这mark一下。这里推荐一个测试TLS的命令：nscurl --ats-diagnostics --verbose https://xxxxxxxxx这里能自动测试哪种key能通过，随便找个https的网站试一下吧。 最后，这个问题困扰了我一天多。在网上各种找，尝试种种方案，一直报1200的错误。然后，然后我就打开苹果开发者官网搜了下proxy。我只想说What the F···。一般来说官方文档是了解一门技术的最好方式，为什么我才想起呢？ 再遇到这种牛角尖问题： 借助官方文档!!! 借助官方文档!!! 借助官方文档!!! 附上connectionProxyDictionary keys 参见Table 3-7https://developer.apple.com/library/content/documentation/Networking/Conceptual/SystemConfigFrameworks/SC_UnderstandSchema/SC_UnderstandSchema.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>app代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime底层-alloc和init]]></title>
    <url>%2Farticle%2FRuntime%E4%B8%89%E5%BA%95%E5%B1%82-alloc%E5%92%8Cinit.html</url>
    <content type="text"><![CDATA[上篇我们创建了一个对象 Person *person = [[Person alloc] init];， 在这句前面先打上断点。我们今天就来探索一下对象到底是如何被创建的？ 对象是在什么时候创建和初始化的 alloc 做了哪些事 由于在我们的对象创建前，OC 底层还会创建其他的对象，都会使用 alloc 底层函数。因此断点调试时，如果底层函数有断点，但是获取的值跟实际推论有区别，很有可能调用 alloc 的不是 Person 类。建议调试时，先只启用对象创建这一个断点。等断住后再去启用底层的断点。 alloc 流程计算对象的实例空间大小 创建对象，从底层来说就是开辟一段内存空间，将对应地址的空间初始化，然后将该段内存的首地址赋值给一个对象指针。要开辟内存，就需要先计算出对象需要多大的空间，这其中还需要考虑内存对齐(目前 iOS App 都是64位，所以对象中成员的内存布局以8字节对齐) 一路step into来到函数callAlloc，笔者将其转化成伪代码 1234567891011121314static idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123; if 类或父类没有自定义 alloc/allocWithZone 开辟新的新的内存空间??? else // 创建实例并返回 id obj = class_createInstance(cls, 0); return obj; if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];&#125; oc 都是有默认 alloc 的，所以我们直接来到 class_createInstance, 最后来到核心函数 _class_createInstanceFromZone。代码省略了大部分，只列出了主要流程的函数。 123456789101112131415id _class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil)&#123; // 实例空间对齐后的大小 size_t size = cls-&gt;instanceSize(extraBytes); // 系统开辟对象所需的内存空间大小 obj = (id)calloc(1, size); // isa 的初始化 obj-&gt;initInstanceIsa(cls, hasCxxDtor); if (cxxConstruct &amp;&amp; hasCxxCtor) &#123; obj = _objc_constructOrFree(obj, cls); &#125; return obj;&#125; 类数据成员所占实例空间的获取。 oc 对象本质是一个结构体，由于 cpu 运行效率的问题，内存空间的开辟需要涉及到内存对齐。 1234567size_t instanceSize(size_t extraBytes) &#123; // 对齐后的实例空间大小 + 额外指定的大小(这里为0) size_t size = alignedInstanceSize() + extraBytes; // CoreFoundation 对象至少需要 16 字节空间 if (size &lt; 16) size = 16; return size;&#125; 进到函数alignedInstanceSize中，从类中获取数据成员实际大小(未对齐)，并调用word_align进行 8 字节对齐(OC 现在只支持64位 app)。 问题：未对齐函数结果和对齐的是一样？？属性是一个 nsstring 和 int 。 12345678910uint32_t alignedInstanceSize() &#123; return word_align(unalignedInstanceSize());&#125;# define WORD_MASK 7UL # 0000 0111 8字节static inline uint32_t word_align(uint32_t x) &#123; // 8 字节对齐算法 WORD_MASK = 7 return (x + WORD_MASK) &amp; ~WORD_MASK;&#125; 以 person 对象为例， x = 8(NSString *) + 4(int) = 12 bytes，对齐后的结果就是 16 bytes 12345(12 + 7) &amp; ~7 0001 0011 # 22 + 7&amp; 1111 1000 # ~7 0001 0000 # 10进制的 16 自己动手算一算，结果都会是”离待对齐值最近的8的倍数”。 回到核心函数_class_createInstanceFromZone中，size_t size = 16 bytes 吗？ 我们使用控制台打印却得到size = 24。原因很简单，不要忘了OC 中的对象都是结构体objc_object，默认有一个 isa 的联合体成员变量。 1234struct objc_object &#123; private: isa_t isa;&#125; 因此 OC 对象会自动继承一个 isa 成员变量。该联合体中的成员都是 8 bytes，所以整个 isa 占 8 个字节。所以 size = ( 8(isa) + 8(NSSTring *) + 4(int) ) &amp; 字节对齐 = 24 bytes。 分配内存空间 获取实例空间的大小后，使用calloc函数分配真实的内存空间大小。成功分配内存后，该函数会返回该段内存的首地址。我们先看看系统分配了多大的空间 实际内存分配 32 bytes。如何改变的呢？其实是又做了一次 16 字节对齐操作。( OC 对象) 该函数属于libmalloc库，我们需要另一个项目来调试。打开可编译的libmalloc，在main函数中直接调用void *p = calloc(1, 24)，断点进入。函数内部又使用了其他对象的 calloc 函数，因此最好不要使用 Xcode 鼠标单击进入函数，而是利用断点调试。这样才好进入正确的函数，来到最终的对齐函数 12345678910111213 static MALLOC_INLINE size_t segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)&#123; size_t k, slot_bytes; if (0 == size) &#123; size = NANO_REGIME_QUANTA_SIZE; // Historical behavior &#125; k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size *pKey = k - 1; // Zero-based! return slot_bytes;&#125; 其实两点： OC 对象最低分配 16 bytes 第二种对齐算法(16字节对齐): (x + 15) &gt;&gt; 4 &lt;&lt; 4 问题：为什么16字节对齐？实例空间按照8字节对齐是因为 64位 系统。笔者没找到资料来解释，难道是王八的屁股？☺☺ 内存空间分配完毕，接下来是 isa 的初始化了。 isa初始完毕，对象就正式存在于内存中了。 init 做了什么 其实到这里一个对象已经创建完毕，已经可以调用方法了。 123Person *p = [Person alloc];p.name = @&quot;songyang&quot;;p.age = 20; 但是为什么还要有个 init方法呢？来到 它的底层实现 1234567891011- (id)init &#123; return _objc_rootInit(self);&#125;id _objc_rootInit(id obj)&#123; // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. return obj;&#125; 可以看到最后其实就是将 self 指向的对象( alloc 创建的对象)直接返回。 init可以看成是工厂方法，方便子类自定义初始化方法。 探讨：既然alloc已经将对象创建完毕，笔者在这里认为系统的init方法其实可以不用了。由于objc_msgSend有默认形参 self，它就会指向alloc创建的对象。就算是自定义初始化方法，也能在其中使用 self。 宏定义 slowpath 和 fastpath 相关链接 实际是函数 __builtin_expect(bool, bool)， 当第二个 bool 值为 0 时是 slowpath；为 1 时是 fastpath。作用是允许程序员将最有可能执行的分支告诉编译器，以帮助编译器进行汇编代码的优化。]]></content>
      <categories>
        <category>iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>alloc</tag>
        <tag>init</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libmalloc源码编译]]></title>
    <url>%2Farticle%2Flibmalloc%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91.html</url>
    <content type="text"><![CDATA[编译环境 macOS 10.14.3 Xcode 10.1 源码下载链接：libmalloc-166.220.1 相关包下载 libplatform-177.200.16 xnu-4903.221.2 将上面的源码包（包括 libmalloc）解压到一个文件夹，比如source编译 先删掉多余的 target 编译应该会出现 BSD.xcconfig does not exist 和 unable to find sdk macosx.internal 两个错误 利用源码根目录中include文件夹, 用来存放需要补充的文件。在Building Settings - System Header Search Paths中添加路径$(SRCROOT)/include 在 source文件夹中搜索缺失的头文件，并拖到当前的 include 文件夹。如果提示中含有前缀路径，需要在include文件夹新建对应的文件夹。提示file not found的文件如下 sys/reason.h radix_tree.h、radix_tree_internal.h，这两个根据错误提示 fix 一下就好。 _simple.h platform/string.h 选取 libplatform下的 mach-o/dyld_priv.h os/internal/internal_shared.h os/base_private.h resolver.h os/internal/atomic.h 选取 libplatform下的 os/internal/crashlog.h 选取 libplatform下的 os/lock_private.h os/once_private.h os/tsd.h machine/cpu_capabilities.h resolver_internal.h 其他错误 宏定义报错_COMM_PAGE_MEMORY_SIZE、_COMM_PAGE_NCPUS、_COMM_PAGE_START_ADDRESS、_COMM_PAGE64_BASE_ADDRESS、_COMM_PAGE_PHYSICAL_CPUS、_COMM_PAGE_LOGICAL_CPUS 在magazine_inline.c 文件头部添加 123456 #define _COMM_PAGE_MEMORY_SIZE (_COMM_PAGE_START_ADDRESS+0x038)#define _COMM_PAGE_NCPUS (_COMM_PAGE_START_ADDRESS+0x022)#define _COMM_PAGE_START_ADDRESS _COMM_PAGE64_BASE_ADDRESS#define _COMM_PAGE64_BASE_ADDRESS ( 0x00007fffffe00000ULL )#define _COMM_PAGE_PHYSICAL_CPUS (_COMM_PAGE_START_ADDRESS+0x035)#define _COMM_PAGE_LOGICAL_CPUS (_COMM_PAGE_START_ADDRESS+0x036) 宏定义报错 _COMM_PAGE_VERSION ，直接注释报错的那段代码。 宏定义报错 以NOTE开头的7个宏定义错，直接注释报错的两段函数。 link command failed 链接错误 上图已经提示了错误在nano_malloc_common.c文件。在 Xcode 中查找上面4个函数，注意去掉前面的下划线。然后将对应文件中的注释。 笔者解决完这个编译不再报错。 添加 target 进行调试 新建 target 创建好后别忘了选择你新建的 scheme。然后在 main函数中键入以下代码 1234#import &lt;malloc/malloc.h&gt;void *t = calloc(1, 24);NSLog(@&quot;%d&quot;, malloc_size(t)); 就可以调试 calloc这个函数了。不能跟踪源码再看下面 最后附上可编译项目]]></content>
      <categories>
        <category>iOS</category>
        <category>源码编译</category>
      </categories>
      <tags>
        <tag>libmalloc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中代码在内存的地址]]></title>
    <url>%2Farticle%2FiOS%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%9C%B0%E5%9D%80.html</url>
    <content type="text"><![CDATA[iOS中代码在内存的地址 App 运行在内存中，每一个函数、变量都会有地址。拿到这个地址我们就可以拿到汇编代码进行修改。如何得到这个地址呢？ 以viewDidLoad方法为例，其他变量等地址求值相同。方法在内存中的实际地址是这样的如何得到这个值(0x10236c700)呢？ 注意： 使用bt命令得到的是当前的函数调用栈。而frame1打印的是当前断点语句的地址。因此Xcode 中断点要下在方法名上。 首先看看viewDidLoad在 MachO 文件中的位置。 图中箭头所指就是OC方法viewDidLoad在 MachO 文件的偏移值 0x1700。注意这是方法的 IMP 地址，位于_TEXT段下的_text分区中。 一定和方法的SEL地址区分，它位于_TEXT段下的_objc_methodname分区中。 其次要知道我们的 app 在内存中的位置 图中就是 app 在运行时内存的首地址 0x10236b000。这个地址值会随每一次启动而变化。 补充： 实际上变化的内存地址由两部分组成：0x100000000+0x236b000。前部分也叫PAGEZERO，是一个虚拟空间，64位下保持不变。后一部分是 ASLR (Address Space Layout Randomization)，地址空间布局随机化。这是一种缓冲区溢出保护技术。它的原理和应用可以在百科看到。这项技术使 App 加载进内存时，其内存地址是随机的。该操作由系统内核完成。 计算：0x10236b000+ 0x1700 = 0x10236c700即MachO 文件中函数在内存中实际地址：PAGEZERO（64位固定0x100000000） + 函数在 MachO 文件中偏移地址 + 模块（程序、app）在内存中的偏移值（不包含PAGEZERO的部分）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>函数地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[objc750.1编译]]></title>
    <url>%2Farticle%2Fobjc750-1%E7%BC%96%E8%AF%91.html</url>
    <content type="text"><![CDATA[本文内容：macOS 10.14.3下编译objc4_750.1源码。笔者不能保证在其他系统版本下编译成功，但是解决方法大同小异。 编译环境 macOS 10.14.1 Xcode 10.1 Objc-750.1, 可编译的版本 准备工作 macOS 10.14.1 所有源码目录 objc4-750.1源码下载链接 其他相关包下载链接。下载并解压到一个文件夹tarballs下，方便搜索。 libplatform-177.200.16 xnu-4903.221.2 libpthread-330.220.2 libmalloc-166.220.1 libdispatch-1008.220.2 libclosure-73 Libc-1272.200.26 libauto-187 dyld-635.2 pthread_machdep.h CrashReporterClient.h 在源码根目录中新建文件夹include, 用来存放需要补充的文件。然后打开项目，在Building Settings - System Header Search Paths中添加路径$(SRCROOT)/include 开始编译 编译，不出意外会出现错误The i386 architecture is deprecated.··· 先解决头文件缺失的错误，再处理其他的。 报错一：头文件缺失 再编译，出现&#39;sys/reason.h&#39; file not found。在tarballs文件夹下搜索reason.h。 由于前面有一个路径，需要在include下再新建一个文件夹sys，然后将reason.h复制到该文件夹下。 接下来就是一顿搜索加复制，如果提示缺失的头文件前有路径，需要自行创建；如果没有，那就直接放在include文件夹下。然后再次编译，处理新的错误直到成功。有区别的地方会做特殊说明。 使用相同操作的头文件还有 mach-o/dyld_priv.h os/lock_private.h os/base_private.h pthread/tsd_private.h System/machine/cpu_capabilities.h, 该文件会搜索到3个，使用上级文件夹为machine的那个。 os/tsd.h，使用上级文件夹为os那个。 pthread/spinlock_private.h 提示System/pthread_machdep.h not found, 下载该头文件 放到 include/System 可以直接注释 提示CrashReporterClient.h not found, 下载CrashReporterClient.h 放到include下。 编译仍会提示not found，在Build Settings - Preprocessor Macros - Debug中添加字段LIBC_NO_LIBCRASHREPORTERCLIENT Block_private.h not found, 搜索复制BlocksRuntime下的该文件到include。同样的还有 objc-shared-cache.h _simple.h &#39;objc/objc-block-trampolines.h&#39; file not found 直接注释即可 其他错误 在dyld_priv.h中报错Expected &#39;,&#39;，这个问题有点无语，因为源文件中格式没有问题啊。笔者通过删除bridgeos(3.0)通过编译。希望有人能告知这是什么情况··· Typedef redefinition with different types (&#39;int&#39; vs &#39;volatile OSSpinLock&#39; (aka &#39;volatile int&#39;)) 重定义错误，说明其他地方也有相同的定义。把报错的那个注释即可 Static declaration of &#39;_pthread_has_direct_tsd&#39; follows non-static declaration 一共有三个函数报错，全部注释即可。出现的原因是重定义。 _pthread_has_direct_tsd _pthread_getspecific_direct _pthread_setspecific_direct isa.h file not found 文件在项目根目录下的runtime文件夹下，只是没有引入。在Building Settings - System Header Search Paths中添加路径$(SRCROOT)/runtime Use of undeclared identifier &#39;DYLD_MACOSX_VERSION_10_13&#39; 系统版本号的宏定义找不到，类似的还有10.11，10.12，10.14的。 在dyld_priv.h头部添加以下宏 1234#define DYLD_MACOSX_VERSION_10_11 0x000A0B00#define DYLD_MACOSX_VERSION_10_12 0x000A0C00#define DYLD_MACOSX_VERSION_10_13 0x000A0D00#define DYLD_MACOSX_VERSION_10_14 0x000A0E00 按照上面这个节奏，如果有macOS 10.15, 那也许在对应的objc4源码中还要加上(16进制) 1#define DYLD_MACOSX_VERSION_10_15 0x000A0F00 linker command failed with exit code 1 在Build Settings - Other Linker Flags - Debug和Release中删除-lCrashReporterClient字段 在Build Settings - Order File中路径改为$(SRCROOT)/libobjc.order SDK &quot;macosx.internal&quot; cannot be located. 在Build Phrases - Run Script中删掉.internal no such public header file: &#39;/tmp/objc.dst/usr/include/objc/ObjectiveC.apinotes&#39; 删除 Build Settings - Other Text-Based installAPI Flags 下的所有值 修改 Text-Based InstallAPI Verification Mode 为 Errors Ony 编译成功，可以开始调试 OC 底层源码了。 添加调试 Target 项目配的架构是 x86_64的，所以 Target 需要是 macOS 下的。都是同一个妈生的，macOS 下调试和 iOS 下调试都差不多的。 推荐使用command line tool，体积小 创建好后别忘了选择你新建的 scheme 如果添加 target 后，断点不能进入到源码中。Xcode 菜单 Product - Scheme - Edit Scheme, 在Build一栏下添加源码的 target。再运行，笔者这里就能进入源码了。 参考链接 https://www.jianshu.com/p/9e0fc8295c4b https://www.imooc.com/article/268031?block_id=tuijian_wz]]></content>
      <categories>
        <category>iOS</category>
        <category>源码编译</category>
      </categories>
      <tags>
        <tag>objc4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绿皮书]]></title>
    <url>%2Farticle%2F%E7%BB%BF%E7%9A%AE%E4%B9%A6.html</url>
    <content type="text"><![CDATA[The world’s full of lonely people afraid to make the first step! 世上有太多的人害怕踏出第一步!]]></content>
      <categories>
        <category>gossip</category>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vps安全]]></title>
    <url>%2Farticle%2Fvps%E5%AE%89%E5%85%A8.html</url>
    <content type="text"><![CDATA[这篇文章是简书作者@乜明文章 的 CentOS 6 64位版本。 修改 ssh 默认端口（远程连接安全） 查看要修改的端口是否被占用 123 netstat -anp | grep 2101 ``` * 修改`/etc/ssh/sshd_config` Port 22 Port 2101 12 先不要关闭22端口，以免出现问题不能登录。* 重启 ssh 服务 /etc/init.d/sshd restart 1* 使用新端口链接 ssh -p 2101 root@IP 12* 链接成功再去吧22端口删掉，并重启 ssh* 如果失败，尝试开启 2101 端口并通过防火墙。笔者没用下面这句是成功了，所以并不清楚会出现什么问题。 查看防火墙，每行前面的 ACCEPT 和 REJECT 表明端口是通过还是拒绝 /etc/init.d/iptables status /sbin/iptables -I INPUT -p tcp —dport 2101 -j ACCEPT service iptables save 123456 #### 禁止非 wheel 组用户提升到 root 权限（服务器主机安全） 由于`root`权限身份金贵，一般配置使用普通用户就好。如果有需要高级权限，再通过`su`命令登录为`root`用户。并且还可以指定用户才能`su`,这样就能提高一些安全系数。* 首先确定除了 `root`之外，你还拥有自己的账户 cat /etc/passwd 1234然后会列出一堆用户及其信息![linux_get_all_users](https://i.loli.net/2019/07/12/5d27e98f10eb593204.jpg)每一行就是一个用户，其格式如下： 用户名:密码(当然不会明文):用户ID:用户组ID:备注:用户根目录:用户shell脚本目录 12 * 如果没有自己创建的用户，建议新建一个。如果有，忽略下面这步。 adduser git passwd git // 然后按提示输入两次密码 12* 禁止非`wheel`组用户使用`su`命令 vi /etc/pam.d/su 打开下面这句的注释，注意看清楚，看清楚，看清楚!!! auth required pam_wheel.so use_uid 12保存后，再使用`git`用户登录。即使密码输入正确也会提示错误或者无权限。 // 登录 git 用户 su git // 登录 root 用户 su // su: incorrect passwd sudo -i // git is not in the sudoers file. This incident will be reported. 123456789 ![linux_no_wheel_login](https://i.loli.net/2019/07/12/5d27e97bec01b53173.jpg)* 要登录`root`，需要将 `git` 用户添加到 `wheel` 组。再执行上面的命令就 ok。 [usermod命令](https://blog.csdn.net/beitiandijun/article/details/41681215) [linux用户操作详解](https://www.cnblogs.com/jackyyou/p/5498083.html) [linux用户操作](https://www.cnblogs.com/xiohao/p/5877256.html) // 退回到 root 用户 exit // 添加进组 usermod -G wheel git // 查看 wheel 组用户 cat /etc/group | grep wheel 1234 ![linux_get_wheel_user](https://i.loli.net/2019/07/12/5d27e97c1f1b975630.jpg) 好吧，我猜错了，总之`su`是登录不上了。查了一下，`sudo -i`需要修改`/etc/sudoers`文件。[解决 is not in the sudoers file](https://blog.csdn.net/gouxf_0219/article/details/80592773) * 这里只是记录命令，如何将用户移出组和删除用户。 // 将用户移出wheel组，如果前面使用的是 usermod -G gpasswd -d test_user sheel // 修改用户所属组，如果前面使用的是 usermod -g usermod -g git:git // 删除用户及其下的目录 userdel -r test_user 1234#### 禁止 ssh 以 root 用户登录，需要在 root 下操作。（远程连接安全）* 前提你要有其他用户可以ssh, 比如上面的git，并且git已经加入了 wheel 用户组。 vi /etc/ssh/sshd_config // 打开下面的注释，并将值修改为no PermitRootLogin no // 重启 ssh 服务 service sshd restart 1234567891011 ![forbid_ssh_root](https://i.loli.net/2019/07/12/5d27e97c0cf2514423.jpg)* 现在笔者就只能使用 git 用户登录了 ![ssh_login_git](https://i.loli.net/2019/07/12/5d27e97c2c37d10002.jpg) #### 设置 ssh 免密登录并禁止密码登录（远程连接安全） 密码登录有一定风险，万一泄露或者黑客暴力破解就不好了。使用 RSA 就不容易破解了，除非黑客又黑掉你本地电脑，拿到你的私钥文件。 注意以下操作是基于服务器登录用户为 `git`。* 本地生成密钥对 cd ~/.ssh ssh-keygen -t rsa -b 4096 -C “你的邮箱，随意” -f server_rsa 123 接下来一直回车即可。`~/.ssh`目录下生成`server_rsa.pub`和`server_rsa`文件。 * 将本地公钥复制到服务器 `git` 用户`~/.ssh/authorized_keys`文件中 ssh-copy-id -i ~/.ssh/server_rsa.pub -p 端口号 git@服务器IP 12345678* 传输过程跟网速有关，最后会需要输入 `git` 用户的密码。完成后就可以免密登录。 ![ssh-copy-id](https://i.loli.net/2019/07/12/5d27e989211a883816.jpg) * 设置别名并且使用公钥登录 在服务器使用root用户编辑`/etc/ssh/sshd_config`文件，将`PubkeyAuthentication`修改为`yes`； 将`AuthorizedKeysFile path/to/authorized_keys`前面加上`#`去掉，并且修改`path`为登录用户`authorized_keys`文件的绝对路径。 上面的方式每次登录都需要输入端口号和 IP，略显麻烦。本地编辑`~/.ssh/config`文件 for personal server Host vultr # 别名 HostName 服务器IP User git # 登录用户名 Port 端口号 PreferredAuthentications publickey IdentityFile ~/.ssh/blog_server_rsa # 本地私钥文件路径 12345现在就可以使用`ssh vultr`免密登录了。如果失败，先确认上面文件路径是否正确。* 禁止密码登录。成功后使用`ssh ip`方式登录就不会再提示输入密码。 `git`用户登录服务端设置 // 切换到 root 用户 su // 修改配置文件 vi /etc/ssh/sshd_config // 打开以下注释, 并将其值改为 no PasswordAuthentication no // 重启 ssh 服务 service sshd restart ```]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo自定义展示分类页面]]></title>
    <url>%2Farticle%2Fhexo%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%95%E7%A4%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2.html</url>
    <content type="text"><![CDATA[需求：笔者想写技术类和碎碎念类文章。但是想把他们分别展示，比如主页就展示技术类文章，另起一个随笔分类展示碎碎念文章。这是我的博客地址 开始动手 修改themes/next/_config.yml，在menu字段下新增一个gossip，使用categories/gossip分类。也可以使用中文分类。 123menu: home: / || home gossip: /categories/gossip || coffee 在themes/next/languages/zh-CN.yml中增加对应的中文 123menu: home: 首页 gossip: 随笔 修改themes/next/layout/category.swig，在entends后面引入一个模板。Github代码（由于 hexo 使用的 swig 模板引擎会解析 MarkDown代码块中 swig 语法。所以会受影响的代码块都使用 Github 代码链接代替😔😔😔😔😔😔） 我们在点击某一个分类时，它只展示了该分类下的文章title 因为渲染模板使用的是post-collapse.swig。但是笔者想要它像主页一样展示一些摘要。所以在上面引入了post.swig模板。 接下来我们需要添加一个if语句，效果是只在笔者gossip分类下使用post.swig，其他分类还是使用原来的。Github代码 最后这一步必不可少，要在博客根目录下public/category/下生成 gossip分类。必须至少存在一篇使用该分类的文章。否则出现访问404。 博客根目录下 1hexo new 写一篇占位文章吧.md 打开刚才的文件，在front-matter中增加gossip分类。 1234---categories: - gossip--- 接下来我们修改themes/next/layout/index.swig，在主页中屏蔽掉gossip分类下的文章。Github 代码。这样我们的需求就搞定了。 现在 hexo g``hexo s本地浏览，如果没问题就可以发布了。 一些问题，还请不吝赐教 最好是自定义一个模板custom_name.swig去渲染。但是笔者没找到category.swig是在哪被谁调用的，所以自定义的模板不知道在哪去include。 BUG: 因为使用的是category/gossip，所以点击gossip时，category分类菜单也会处于选中状态。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps服务器搭建hexo博客]]></title>
    <url>%2Farticle%2Fvps%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[一直在 vultr 上用 vps 搭梯子，感觉还挺浪费的。现在将博客拉上来占占空间···不过远程链接，而且是国外，慢是必须的。买国内的 vps 应该要好些，比如阿里云。 准备 注册、充值、开服务器，就不介绍了。挺容易上手的。另外笔者使用的是 CentOS 6 64位，和 CentOs 7 的命令有部分不同。 ssh 链接远程服务器。ip 和密码在服务器开启后可以查看。 本地操作 1ssh root@服务器 ip 提示一下，链接后如果长时间不操作，链接会断开。如果嫌麻烦，可以在开启服务器的网页点击view console操作。但是个人体验不是很友好··· 安装 nginx 服务 服务器操作 安装 nginx 1yum install -y nginx 启动 nginx 12345// centos 6 系统service nginx start// centos 7 系统systemctl start nginx.service 设置开机启动 nginx 12345// centos 6 系统chkconfig --add httpchkconfig nginx on// centos 7 系统systemctl enable nginx.service 防火墙允许 nginx 通过默认的 80 端口访问 123456789// centos 6// 端口可以改成需要的, 但是这里先暂时不改/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT// 保存配置/etc/rc.d/init.d/iptables save// centos 7firewall-cmd --service=http --add-port=80/tcp --permanentfirewall-cmd --reload 也有的博客在这一步直接关闭防火墙，个人觉得没那个必要。需要哪个端口允许通过就可了。https://www.cnblogs.com/eaglezb/p/6073739.html 1234567// 关闭防火墙的命令// centos 6 系统/etc/init.d/iptables stop// centos 7 系统firewall-cmd --add-service=http --permanentfirewall-cmd --reload 在浏览器输入 ip，应该能看到 nginx 欢迎信息，nginx 开启成功。相当于建了一个最简单的网站。 默认网站根目录为/usr/share/nginx/html 默认网站的配置文件是/etc/nginx/conf.d/default.conf 配置一个自定义的 nginx 网站 服务器操作 新建自己的博客文件夹,并添加一个 index.html文件。index.html内容随意，目前只是用于提示。路径可以自己修改。这个文件夹将来存放我们博客的静态资源。 123mkdir /root/hexocd /root/hexovi index.html 开放自定义端口 友情提示：不要为了感觉6就使用6666端口，由于存在安全风险，部分浏览器禁止访问该端口。浪费我好多时间···详情点击 不建议修改，因为域名解析默认就是80端口。如果修改了端口，使用域名访问需要手动加端口号，对用户来说是灾难。（也可以使用 url 转发） 12345678910111213141516// 查看指定端口是否被占用netstat -anp | grep 8123// centos 6系统/sbin/iptables -I INPUT -p tcp -m tcp --dport 8123 -j ACCEPT/etc/rc.d/init.d/iptables save// 查看开放的端口/etc/init.d/iptables status// centos 7系统semanage port -a -t http_port_t -p tcp 8123firewall-cmd --service=http --add-port=8123/tcp --permanentfirewall-cmd --reload &gt; iptables 使用一 iptables 使用二 端口已通过防火墙,还是不能访问,看这篇文末 修改 nginx 默认配置 /etc/nginx/conf.d/default.conf。建议备份一下cp default.conf default_old.co，有个对照。注意后缀千万不能和源文件相同。 12345678# 修改监听端口为刚才新开放的# ipv4listen 8123 default_server;# ipv6listen [::]:8123 default_server;# 修改网站静态资源文件路径，一定要绝对路径root /root/hexo; 修改完毕后保存，重新加载 nginx 服务nginx -s reload。 此时在浏览器通过ip:新端口号访问，如果出现index.html中的内容说明配置成功 出现 403 错误 1.首先确认default.conf正确配置，root字段必须是绝对路径，即便~路径标识都不行。2.然后确认绝对路径上的每一个文件夹或文件都有可读权限。chmod 755 xxx3.其他403网上自己搜搜吧试试4.在/etc/nginx/nginx.conf中有这么一句 12# 导入路径下所有后缀为 conf 的配置文件include /etc/nginx/conf.d/*.conf 这就是上面笔者提醒备份文件后缀不能保持一致的原因。如果不改，备份的配置可能覆盖真正的配置文件，导致无限403。因为谨慎起见给自己挖了个大坑，人生无常啊😂😂🤣 安装 git 服务，建立服务仓 服务端操作 安装 git 服务器 1yum -y install git 添加一个用户 git，在/home/下 1adduser git 在 git 用户下创建代码仓 123456789mkdir /home/git/repocd /home/git/repo// 初始化代码仓, 更改所有者为 git 用户git init --bare hexo.gitchown -R git:git /home/git/repo/hexo.git// 更改博客资源文件夹所有者为 git 用户chown -R git:git /root/hexo 配置 git 自动部署脚本。我们push代码后，git 自动运行脚本部署到博客资源文件夹 12345cd hexo.git/hooks// 创建配置文件，添加执行权限touch post-receivechmod +x post-receive 在配置文件中输入以下命令 1git --work-tree=/root/hexo --git-dir=/home/git/repo/hexo.git checkout -f --work-tree: 博客静态资源文件夹 --git-dir: 刚才初始化的 git 代码仓 配置 git 用户 ssh 免密登录 服务端在 git 用户文件夹下创建 ssh 配置文件 123456789101112cd /home/git // 创建 .ssh文件夹，修改权限及所有权mkdir .sshchmod 700 /home/git/.sshchown -R git:git /home/git/.ssh // 创建 authorized_keys文件，修改权限cd .sshtouch authorized_keyschmod 600 /home/git/.ssh/authorized_keyschown -R git:git /home/git/.ssh/authorized_keys 服务端开启权限，修改/etc/ssh/sshd_config文件 123RSAAuthentication yes PubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 文件中只是被注释了，打开即可。 本地终端生成新的 RSA 密钥对 1234cd ~/.ssh// 生成秘钥对, -f 后的名字可以自定义ssh-keygen -t rsa -b 4096 -C &quot;sjy457346652@aliyun.com&quot; -f blog_server_rsa 本地复制公钥到刚才服务端新建的authorized_keys文件中 12// 本地执行ssh-copy-id -i ~/.ssh/blog_server_rsa.pub -p 端口号 git@服务器IP 免密登录测试 1ssh git@ip 如果还是需要输入密码 1.确定 authorized_keys中是对应的公钥2.确定权限3.以下确定文件及文件夹的拥有者为 git .ssh 文件夹 authorized_keys 文件 chown -R git:git 要修改拥有者的文件或文件夹 设置 ssh 登录别名，自动登录用户设为 git本地修改~.ssh/config文件，增加以下内容 12345Host vultr HostName 服务器ip User git Port 22 IdentityFile ~/.ssh/blog_server_rsa Host: 别名，自定义 User: 必须为 git Port: ssh 的端口号,netstat -anp |grep ssh查看，一般默认22 IdentityFile: 本地私钥文件路径 注意字段和值之间有一个空格 小提示: config 文件的权限必须是600，否则报bad owner or permission错误。chmod 600 ~/.ssh/config 安装 node.js 服务端 各种 node 版本 https://github.com/nodesource/distributions https://nodejs.org/dist 安装 https://www.cnblogs.com/savokiss/p/9692684.html 如果你用的32位 centos，看这32位 centos 安装 nodejs 123456789// 用管道将CURL输出的内容（下载下来的脚本）使用Root权限用Bash运行curl -sL https://deb.nodesource.com/setup_11.x | sudo -E bash -// 安装yum -y install nodejs// 检查是否成功node -vnpm -v 本地修改 hexo 博客配置文件 修改_config.yml 1234567deploy: - type: git # 使用 Github 部署 repo: github: git@github.com:roastduckcd/roastduckcd.github.io.git # SSH 方式的 Github 仓,博客静态文件部署的分支 branch: master - type: git # 自己的服务器部署 repo: vultr:/home/git/repo/hexo.git repo: 自定义ssh别名:服务端代码仓路径 本地部署博客 1hexo g -d 浏览器服务器ip:端口号访问博客 nginx 中使用 hexo 中的 404 页面 服务器操作 修改/etc/nginx/conf.d/default.conf, 打开一个注释并修改路径。 1error_page 404 /404/index.html /404/index.html 是 hexo 博客中public目录下的 404 页面路径。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC中不能直接对frame成员赋值]]></title>
    <url>%2Farticle%2FOC%E4%B8%AD%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%AF%B9frame%E6%88%90%E5%91%98%E8%B5%8B%E5%80%BC.html</url>
    <content type="text"><![CDATA[原因是点语法的不同。 前半部分view.frameOC中UI对象的点语法，本质是getter方法：- (CGRect)frame{}，是一个方法。同过view.frame 即 - [vew frame]得到的值是一个方法返回值，并且是一个值类型。在C语言中是不能当左值的，也就是只能出现在=的右边。所以编译时出现Expression is not assignable。 后半部分frame本身是一个CGRect的结构体，.表示指针指向。 但是也许我们能看到 1[UIButton buttonWithType:UIButtonTypeSystem].backgroundColor = [UIColor redColor]; 方法返回值还是出现在左边，但没报错。那是因为OC的setter方法，这一句其实是 1[[UIButton buttonWithType:UIButtonTypeSystem] setBackgroundColor:[UIColor redColor]]; 实际上是方法的调用。 所以我们要修改frame必须要先创建CGRect的结构体，再通过调用view的setFrame方法。 123456// 只能作右值CGRect newFrame = self.view.frame;// 修改结构体newFrame.origin.x = 50;// 调用setter方法self.view.frame = newFrame; 扩展： 1234567891011121314151617181920212223typedef struct rect &#123; int a; int b;&#125;MyRect;MyRect * check();int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... NSLog(@&quot;Hello, World!&quot;); // 函数返回值不能当左值// check().a = 6; // 函数返回值是指针可以当左值。 check() -&gt; a = 6; &#125; return 0;&#125;MyRect * check() &#123; struct rect test = &#123;3, 4&#125;; // 要这样用必须有typedef MyRect r = &#123;3, 4&#125;; MyRect *p = &amp;r; return p;&#125;]]></content>
      <categories>
        <category>ObjectiveC</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客之next主题配置]]></title>
    <url>%2Farticle%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%94.html</url>
    <content type="text"><![CDATA[本文主要参照一下两篇文章，自己边配置边重新记录了下。 https://blog.csdn.net/kunkun5love/article/category/7416724 https://blog.csdn.net/qq_33699981/article/details/72716951 首先推荐异步动画默认动画是同步的，个人感觉加载有点慢。 修改themes/next/_config.yml 1234# Use velocity to animate everything.motion: enable: true # 启用动画 async: true # 异步动画 修改网站结构在主题配置文件themes/next/_config.yml中如图，next 目前支持4中布局，打开对应的注释即可。 修改网站语言在 hexo 博客根目录中的_config.yml中修改1language: zh-CN 添加菜单比如要添加一个标签页(tags),分类(categories)也一样 在博客根目录中执行 1hexo new page tags 执行后会在source/tags下生成index.md文件 修改index.md文件 123456---title: tagsdate: 2019-02-01 23:16:15type: &quot;tags&quot; # 如果是分类页，则改为&quot;categories&quot;comments: false # 关闭评论--- 然后修改themes/next/_config.yml中打开对应的注释。通过调整关键字的顺序可以改变菜单顺序。 格式： 菜单名 对应index页位置 菜单前面的图标 tags /tags/ tags https://fontawesome.com/ 图标默认来自这个网站，选好后直接修改图标名即可。笔者没有实现自定义图标，有知道的读者请留个言，谢谢。 1234567891011121314menu: home: / || home tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat about: /about/ || user# Enable/Disable menu icons / item badges.menu_settings: icons: true badges: false 站内搜索 安装插件 1npm install hexo-generator-searchdb --save 修改博客根目录下的配置文件_config.yml 12345search: path: search.xml field: post format: html limit: 10000 修改themes/next/_config.yml中 12local_search: enable: true 网站图标 图标默认搜索路径是themes/next/source文件夹下 在themes/next/_config.yml搜索faviconurl 使用相对路径 123favicon: small: /images/roastduck16x16.png medium: /images/roastduck32x32.png 这里我只修改了两种图片，位置在themes/next/source/images下。 侧边栏头像 图标默认搜索路径是themes/next/source文件夹下 在themes/next/_config.yml搜索avatar 12345avatar: url: /jianxiu.png # 头像路径 rounded: false # 圆角 opacity: 1 # 透明度 rotated: false # 鼠标移入是否旋转 我这里图片放在了themes/next/source/下。 文章设定以下都是在themes/next/_config.yml中配置 保持上一次浏览位置1save_scroll: false 主页展示文章摘要1excerpt_description: true 在文章中合适的地方后添加&lt;!-- more --&gt;，首页中就只会展示标记之前的文章 文章标记12345678# Post meta display settingspost_meta: item_text: true # 标记前面的描述 created_at: true # 文章发布时间 updated_at: # 文章更新时间 enabled: false another_day: true categories: true # 分类 代码块设定123456789# 边框设定codeblock: border_radius: 0 # 代码块圆角大小 copy_button: enable: true # 展示复制按钮 show_result: false# 背景色: # next 提供5种：normal、night、night eighties、night blue、night brighthighlight_theme: normal 如果需要自定义样式，可以修改themes/next/source/css/_custom/custom.styl，添加以下代码1234567891011121314151617181920212223242526// 小代码块的样式code &#123; color: #ff7600; // 字体颜色 background: #fbf7f8; // 背景色 margin: 2px; // 和相邻元素的间距&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 1px 0; padding: 1px; border-radius: 3px; background: #FDF6E4 // 代码块背景色 // color: #F5390F; // 字体颜色&#125;// 代码前景色.highlight .code pre &#123; background: #FDF6E4&#125;// 代码块边框大小、粗细、颜色.highlight, code, pre &#123; border: 1px solid #d6d6d6; &#125;// 代码与边框 margin.table-container &#123; margin: 1px 0;&#125; 版权信息1. 在目录`themes/next/layout/_macro/`下添加模板`my-copyright.swig`, 复制 [Github代码](https://github.com/roastduckcd/hexo-theme-next/blob/master/layout/_macro/my-copyright.swig) 2. 在`themes/next/source/css/_common/components/post/`下添加样式`my-post-copyright.styl`, 复制 [Github代码](https://github.com/roastduckcd/hexo-theme-next/blob/master/source/css/_common/components/post/my-post-copyright.styl) 3. 修改文章模板`next/layout/_macro/post.swig`，在注释 123&#123;#################&#125;&#123;### END POST BODY ###&#125;&#123;#################&#125; 之后加入以下代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 最后在`themes/next/source/css/_common/components/post/post.styl`最后一行添加 1@import &quot;my-post-copyright&quot; 使用方法：在文章最前面的`front matter`中添加`copyright: true`即可。 添加背景图片原文链接：https://www.jianshu.com/p/30bf702f533c 修改 themes\next\source\css\ _custom\custom.styl, 添加 123456789101112131415161718192021// 背景图body &#123; background:url(/images/code_background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%;&#125;// 头部透明//.header-inner &#123;// opacity: 0.1//&#125;// 增加背景透明度.main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.8; min-height: 500px;&#125; 图片可以是网络路径，或者是themes/next/source路径下的图片路径。推荐使用网络路径，加载更快。 配置侧边栏个人链接 格式： 链接名称 链接地址 前面的图标 https://fontawesome.com/ 图标默认来自这个网站，选好后直接修改图标名即可。12345678910# 设定链接social: GitHub: https://github.com/roastduckcd || github 简书: https://www.jianshu.com/u/8f6ea27db0c7 # 链接图片social_icons:enable: trueicons_only: falsetransition: false 文章末尾标签去除”#”如图所示，”#”影响页面效果。我们可以在themes/next/layout/_macro/post.swig中搜索tag.name。删掉前面的”#”即可。如果需要在前面加个图标，可以将”#”替换成下面的代码1&lt;i class=&quot;fa fa-tags&quot;&gt;&lt;/i&gt; 代码来自 https://fontawesome.com/，搜索到想要的图片后, 进入就能看到图片的代码。需要注意的是网站给的代码12&lt;i class=&quot;fas fa-tags&quot;&gt;&lt;/i&gt; // 无效&lt;i class=&quot;fa fa-tags&quot;&gt;&lt;/i&gt; // 有效 要将 fas 改为 fa，否则无效。不清楚什么原因？？ 页面点击小红心 /themes/next/source/js/src下新建love.js, 复制Github代码 在themes/next/layout/_layout.swig 文件, 在标签&lt;/body&gt;前面添加 1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 重新生成博客即可。 主页文章添加阴影效果主页中，文章间默认是看不出分隔的。添加阴影效果来区分以下。 在\themes\next\source\css\_custom\custom.styl末尾添加如下代码 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 10px; margin-bottom: 10px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; Fork me on Github 选取样式 https://github.blog/2008-12-19-github-ribbons/ http://tholman.com/github-corners/ 选好后复制旁边的代码，来到themes/next/layout/_layout.swig中添加代码，位置如下 12345&lt;div class="headband"&gt;&lt;/div&gt; ###刚才复制的代码###&lt;header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"&gt; &lt;div class="header-inner"&gt;&#123;% include '_partials/header/index.swig' %&#125;&lt;/div&gt;&lt;/header&gt; 重新 hexo g生成新的 html 即可。 来必力评论来必力官网：https://www.livere.com/注册(貌似有点慢)后来到管理页面-代码管理复制UID。由于 next 主题已经集成了来必力，我们只需要在themes/next/_config.yml中搜索livere_uid配置 uid 即可。1livere_uid: 刚才复制的 UID 开启分享功能next 自带 NeedMoreShare2，基本 QQ、 微信分享还是有的。 在themes/next下执行 1git submodule add https://github.com/theme-next/theme-next-needmoreshare2.git source/lib/needsharebutton 在themes/next/_config.yml中启用。 一种是固定在文章底部postbottom，一种是固定在页面左下角float。需要哪种修改enable为 ture即可。 另外postion选项修改的弹出后菜单的位置。笔者一度以为是个 bug，整半天按钮不挪位置··· 样式看图吧设置的格式：top / middle / bottom + Left / Center / Right 123456789needmoreshare2: enable: true float: enable: true options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook DaoVoice 在线留言 注册 DaoVoice 并获取 appid 然后打开/themes/next/layout/_partials/head/head.swig,在文件末尾添加 123456789&#123;% if theme.daovoice %&#125;&lt;script&gt;(function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/58b50729.js&quot;,&quot;daovoice&quot;)daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;&#125;);daovoice(&apos;update&apos;);&lt;/script&gt;&#123;% endif %&#125; 第三步修改themes/next/_config.yml, 末尾添加 123# DaoVoice Online contact daovoice: truedaovoice_app_id: 刚才获取的 appid 默认的刀言图标是在右下角，可以在刀言控制台进行配置 统计字数 https://github.com/theme-next/hexo-symbols-count-time 博客根目录下安装插件 npm install hexo-symbols-count-time --save 修改博客根目录下的 hexo 配置文件 _config.yml 12345symbols_count_time: symbols: true # 开启统计 time: true # 文章阅读时间预计 total_symbols: true # 博客总字数 total_time: false # 博客总阅读时间预计 修改主题目录下的配置文件 _config.yml 123456symbols_count_time: separated_meta: false # 分割线,true无false有··· item_text_post: true # 显示中文的&quot;阅读时间&quot;等 item_text_total: true # 显示中文的&quot;博客总字数&quot; awl: 4 # 一个词平均字符长度，中文较多就设为2 wpm: 275 # 阅读速度 最后重新hexo g生成并部署即可。 不过有一点不好的是，默认生成的字段会自动换行。原因是插件作者采用的 div 标签。打开next/layout/_macro/post.swig, 搜索symbols_count_time,修改接下来的第一对div标签，改为span标签。保存刷新就不会换行了。 实现公益404页面 在博客根目录下执行 1hexo new page 404 然后进入博客根目录source/404/，修改其中的index.md为index.html。然后打开文件添加代码1234567891011&lt; !DOCTYPE html&gt;&lt;html lang =&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面暂时飞走了&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实现 PC 版点击空白区域关闭侧边栏 目前 js 小白，如果有更好的方法请不吝赐教。 修改themes/next/source/js/src/motion.js搜索var sidebarToggleMotion, 提升变量作用域(放到最前面)。这样子就可以在外面拿到关闭侧边栏函数。修改后如下，代码省略了很多 12345var sidebarToggleMotion;$(document).ready(function() &#123; ········ sidebarToggleMotion = &#123;····&#125;&#125;); 还是motion.js, 修改 clickHandler函数，阻止事件冒泡。这个函数就是右下角控制侧边栏开闭的按钮事件。 1234567// 添加一个函数参数 e，页面点击事件clickHandler: function(e) &#123; this.isSidebarVisible ? this.hideSidebar() : this.showSidebar(); this.isSidebarVisible = !this.isSidebarVisible; // 添加阻止事件冒泡 e.stopPropagation(); &#125;, 在themes/next/source/js/src下新建一个close-sidebar.js文件 12345678910111213$(document).ready(function(e)&#123; $(document.body).on(&apos;click&apos;, function(e)&#123; if (sidebarToggleMotion.isSidebarVisible) &#123; sidebarToggleMotion.hideSidebar(); sidebarToggleMotion.isSidebarVisible = !sidebarToggleMotion.isSidebarVisible; &#125; &#125;); // 阻止侧边栏的事件冒泡 sidebarEL = $(&apos;.sidebar&apos;); sidebarEL.on(&apos;click&apos;, function(e) &#123; e.stopPropagation(); &#125;);&#125;); 在themes/next/layout_layout.swig末尾的`&lt;/body&gt;标签前添加 12&lt;!-- 点击窗口关闭侧边栏 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/close-sidebar.js&quot;&gt;&lt;/script&gt; 目前存在的 bug：如果点击文章还是会看到侧边栏关闭的动画，应该直接跳转。如果其他 bug 请留言，尽力解决。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github + Hexo + yilia 主题+ travis 自动部署个人博客(自动部署+双线部署)]]></title>
    <url>%2Farticle%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%9B%9B.html</url>
    <content type="text"><![CDATA[先说一下笔者的部署情况： 本地博客可以hexo g -d发布到服务器，所以已经配置了到服务器的免密登录，并且使用了别名 ssh 登录。 笔者需要将源代码上传到 Github。这样每次都要 git push 和 hexo d 发布。所以想到自动部署，只需要将代码 push 到 Github，travis 监控 git 仓变动，开始自动构建并部署到服务器。 自动部署到 Github 的配置使用 Github 账号登录 travis 点击sign in with Github, 授权后登入 travis。点击头像就进入Github 仓库列表。点击博客前的按钮激活。有的博客说要进入settings选择build only if .travil.yml presents，只有 Github 仓中存在 travis 配置文件才构建。不过现在好像是默认了，没有这个选项。要是看到就点上吧。 生成 GitHub Access Token生成 Access Token 后一定要复制，一旦离开页面就再看到了，只能重新生成一个。 配置 Access Token 到 travis 编辑配置文件 .travis.yml12345678910111213141516171819202122232425language: node_js # 指定博客源码语言环境node_js: - &apos;11&apos; # 指定语言版本cache: npm # 指定 npm 缓存方案，会缓存 $HOME/.npm 或 node_modules 文件夹branches: # 指定要构建的分支 only: # only 表示只构建以下分支 - source # Github 源代码分支 before_install: # install 阶段之前执行 - export TZ=&apos;Asia/Beijing&apos; # 设置时区 - npm install -g hexo-cli # 全局安装 Hexo 命令行工具install: - npm install # 安装 package.json 中的依赖script: - hexo clean - hexo generate # Hexo 常规命令，执行清理和生成after_success: # script 阶段成功时执行，构建失败不会执行，其他同上 - git config --local user.name &quot;roastduckcd&quot; - git config --local user.email &quot;sjy457346652@aliyun.com&quot; # 配置 hexo _config.yml 中的 deploy 字段。也就是博客部署的分支 - sed -i&apos;&apos; &quot;s~git@github.com:~https://$&#123;GITHUB_TOKEN&#125;@github.com/~&quot; _config.yml - hexo deploy # 通过 Hexo 的 deploy 命令部署博客 注意上面倒数第二句 sed命令中 GITHUB_TOKEN就是上面配置 Access Token中 的环境变量名 branches中的分支是你的源代码分支。我的情况是只创建了一个 Github 仓，用 master 分支部署博客，另建了一个 source 分支同步源码。部署成功后的页面。如果部署没成功，Job log 中会列出错误信息。如果连这个页面都没有，那就到 Requests 标签页中查看我这里是因为.travis.yml文件中写多了其他命令导致travis 解析配置文件失败。 自动部署到个人服务器的配置个人服务器搭建 请先确保本地已经生成密钥对,并且公钥已经上传到服务器。 来到博客根目录下，即.travis.yml所在文件夹。终端执行 12// 使用 travis 命令加密私钥travis encrypt-file ~/.ssh/blog_server_rsa(私钥文件路径) --add travis会在博客根目录下生成blog_server_rsa.enc的文件，该文件不要移动。另外不要把私钥文件放到博客目录中。一旦上传到 Github，别人下载下来就可能用你的私钥登录你的服务器。 同时该命令会自动在.travis.yml中添加一句openssl解密命令。为避免权限问题，我们还需在该条语句后手动加一条chmod命令。 123before_install: - openssl aes-256-cbc -K $encrypted_d89376f3278d_key -iv $encrypted_d89376f3278d_iv -in id_rsa.enc -out ~/.ssh/id_rsa -d - chmod 600 ~/.ssh/id_rsa 由于笔者博客的repo已经配置成了别名方式，在 travis 也需要配置别名 笔者博客根目录下的_config.yml 1234567deploy: - type: git # 使用 Github 部署 repo: github: git@github.com:roastduckcd/roastduckcd.github.io.git # SSH 方式的 Github 仓,博客静态文件部署的分支 branch: master - type: git repo: vultr:/home/git/repo/hexo.git # 个人服务器 repo 首先需要在 travis 设置页面中配置敏感字段。比如这里我不想再.travis.yml中直接写服务器 IP 和端口号，否则上传到 Github 大家都能看到了。配置方法和上文配置 Access Token 到 travis相同。我这里使用的名字是HostName和Port, 在.travis.yml中就可以使用$变量的方式取值来代替明文显示。 接下来还是在.travis.yml中的befor_install字段下配置别名 1234567891011121314# 避免 config 的权限问题- chmod 600 ~/.ssh/config# 配置别名，一定要用 &gt;&gt; 符号表示追加，否则是覆盖文件- echo &quot;Host vultr&quot; &gt;&gt; ~/.ssh/config- echo &quot; HostName $HostName&quot; &gt;&gt; ~/.ssh/config- echo &quot; User git&quot; &gt;&gt; ~/.ssh/config- echo &quot; Port $Port&quot; &gt;&gt; ~/.ssh/config- echo &quot; StrictHostKeyChecking no&quot; &gt;&gt; ~/.ssh/config- echo &quot; IdentityFile ~/.ssh/blog_server_rsa&quot; &gt;&gt; ~/.ssh/config# openssl 解密- openssl aes-256-cbc -K $encrypted_2c1446b86c6a_key -iv $encrypted_2c1446b86c6a_iv -in blog_server_rsa.enc -out ~/.ssh/blog_server_rsa -d- chmod 600 ~/.ssh/blog_server_rsa 小提示: &gt;&gt;一定是两个右尖括号，否则会覆盖原来的文件。 问题: 有些博客中将echo语句合并一句，使用\n隔开。但是笔者试了。travis 报错Could not resolve hostname devsrv: Name or service not known然后笔者分段写入，编译成功。出现该问题也可能需要修改hosts 由于设置了StrictHostKeyChecking no, 又出现Warning: Permanently added (RSA) to the list of known hosts该警告不影响部署，但是笔者觉得碍眼。改为 yes 改为 yes后竟然报错···No RSA host key is known for [[secure]]:[secure] and you have requested strict checking.。其实StrictHostKeyChecking 字段是为防止中间人攻击。值为yes时，会在~/.ssh/known_hosts中按IP寻找保存的公钥，然后和服务器公钥比对，以确定是否遭到中间人攻击。这个报错就是因为没有找到。 非要解决的话，笔者思路：复制服务器公钥以 travis 变量方式保存，在.travis.yml中使用$变量的方式添加到known_hosts文件。有兴趣可以自行尝试。这里结论还是改回no。 参考链接: 使用 travis 进行持续集成 使用 Travis 将 GitHub 文件上传传至服务器 双线部署到腾讯代码仓 (已 Quit)流程和 Github 大体相同。 新建仓库，名字必须为：用户名.coding.me，一定要公开源码，不然貌似不能 clone。 需要手动到 pages 服务中一键开启 pages 服务。 Access Token被叫做 访问令牌，位置在个人设置-访问令牌。同样只需选择仓库控制一个权限即可。 复制访问令牌，add 到 travis 中。这里我取名CODING_TOKEN 既然要部署两个，那么需要修改博客配置文件_config.yml 1234567deploy: type: git # 使用 Github 部署 repo: github: git@github.com:roastduckcd/roastduckcd.github.io.git # 添加 coding 的 git 地址 coding: git@git.dev.tencent.com:roastduckcd/roastduckcd.coding.me.git branch: master 修改博客根目录下.travis.yml，添加一句 sed 命令 1234567after_success: - git config --local user.name &quot;roastduckcd&quot; - git config --local user.email &quot;sjy457346652@aliyun.com&quot; - sed -i&apos;&apos; &quot;s~git@github.com:~https://$&#123;GITHUB_TOKEN&#125;@github.com/~&quot; _config.yml # 添加下面这句 - sed -i&apos;&apos; &quot;s~git@git.dev.tencent.com:~https://$&#123;CODING_TOKEN&#125;@git.dev.tencent.com/~&quot; _config.yml - hexo deploy 但是目前 coding 上使用 访问令牌能 clone 不能 push，上面那句会提示输入密码。不知道是不是 coding 的 bug？？？提 issue 也没说出到底哪的问题。放弃。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>travis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github + Hexo + yilia 主题+ travis 自动部署个人博客(yilia主题待续)]]></title>
    <url>%2Farticle%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%89.html</url>
    <content type="text"><![CDATA[目前已经使用 next 主题，详情点击 安装 yilia 进入博客根目录 1git clone https://github.com/roastduckcd/hexo-theme-yilia themes/yilia yilia 的源文件就 clone 到了thems/yilia文件夹下 配置 _config.yml, 修改 theme 字段 1theme: yilia hexo g + hexo s 本地先查看一下 点击”所有文章“，多半会像下面一样，提示缺失模块。 1npm i hexo-generator-json-content --save 安装好后打开_config.yml配置如下内容。 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 再次hexo g + hexo s 检查无误后hexo d部署到 Github Pages。接下来就开始润色博客了。 打造自己的博客 如何使文章只展示一部分，在你想要展示的部分后面添加标签&lt;!--more--&gt;即可。不过这样可能会在网页中出现more&gt;&gt;的链接按钮。由于笔者使用的是 yilia 主题，右下角本来就有展示原文。如何去掉呢？ 进入 themes/yilia 文件夹下，修改_config.yml文件中的excerpt_link: more，删掉 more 即可。注意冒号后有一个空格。 同时&lt;!--more--&gt;标签之前必须有文章内容，但是front matter不算。 如何在一行输入多个 tag tags: [tag1, tag2 ···] 开启目录: 在文章中的front matter区域添加 toc: true，按钮在右下角。样式修改yilia/layout/_partial/archive.ejs 修改代码块样式: 修改的字段： 背景色: 修改.article-entry .highlight字段中的color属性值。 代码字体颜色: .article-entry .highlight .line字段中的 color 值。 修改的位置： theme\yilia\source\main.0cf68a.css修改该文件不需要编译。 yilia\source-src\css\highlight.scss修改该文件需要编译。 123npm installnpm run devnpm run dist 配置 yilia 时 npm 相关错误 第一种错误：由于 webpack 的升级导致yilia/webpack.config.js配置文件中语法的变化。这种虽然看到一大坨红字，但是下面已经给出了修改提示。 第二种错误：The provided value “*” is not an absolute path! 需要绝对路径。yilia/webpack.config.js顶部引入 var path = require(&quot;path&quot;)并更改提示需要绝对路径的输出为： 1path: path.resolve(__dirname, &apos;路径&apos;), 第三种错误：需要安装对应安装包。 首先升级已有安装包(package.json -&gt; dependences字段) 123456789101112 // 安装检查更新的插件 npm install npm-check-updates -g // 检查depedencies中的最新版本 npm-check-updates // 更新dependencies到最新版本 ncu -u // 如果想更新全部depedencies到最新版本（包括当前指定版本范围满足最新版本号） ncu -a ``` 2. 先再执行`npm install`，如果还有提示`missing modual`就缺啥安啥。* `Plugin/Preset files are not allowed to export objects, only functions.`原因可能是包被废弃了。以前的`babel-preset-*`都由`babel-present-env`替代了。 // 先卸载原来的包npm uninstall —save-dev babel-preset-es2015npm install —save-dev babel-preset-env@next 1然后修改`yilia/.babelrc`文件 { “presets”: [ “env” ], …} 12345&gt;`--save--dev`: 保存包信息到`package.json -&gt; devDependences`&gt;`--save`: 保存包信息到`package.json -&gt; dependences`* `TypeError: this.setDynamic is not a function` // 我的这个在 package.json -&gt; dependences中，需要放在 package.json -&gt; devDependences // npm install --save-dev babel-plugin-transform-runtime npm install --save @babel/runtime ```]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github + Hexo + yilia 主题+ travis 自动部署个人博客(hexo进阶)]]></title>
    <url>%2Farticle%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%BA%8C.html</url>
    <content type="text"><![CDATA[常用命令中括号表示可选参数。 hexo s: 开启本地服务，可以通过http://localhost:4000访问博客。建议每次发布前使用一次，确定本地文件没有问题。 hexo new [layout] 文件名.md: 创建新的 MarkDown 文件并应用 layout 布局(版式)。😴 网上找个顺手的 MarkDown 软件就好了··· hexo g [-d]: 生成网页文件并立即部署。 hexo d [-g]: 部署到网站前先生成网页。 hexo clean: 清除public文件夹，这里面包含所有生成的静态网页。慎用。 更多命令，请访问官网配置。 _config.yml 配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Sitetitle: 烤鸭的小火炉 # 博客标题subtitle: 一只喜欢看布袋戏的烤鸭 # 博客副标题description: 蹉跎错,消磨过,最是光阴化浮沫 # 博客描述, 硬生生干成座右铭keywords: iOS, Swift, 程序猿 # 不知道是不是博客的搜索关键字author: 阳仔 # 博客作者language: # 博客使用的语言timezone: # 博客使用的时区, 默认使用电脑时区# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://roastduckcd.github.io # 博客地址root: / # 博客根目录permalink: :year/:month/:day/:title/ # 博客链接的格式permalink_defaults:# Directorysource_dir: source # 源文件夹public_dir: public # 静态网页文件夹tag_dir: tags # 标签archive_dir: archives # 归档category_dir: categories # 分类code_dir: downloads/code # ？？i18n_dir: :lang # 国际化skip_render: # # Writingnew_post_name: :title.md # 新 MarkDown 文件名default_layout: post # 预设布局（网页版式）titlecase: false # 标题首字母大写external_link: true # 在新标签中打开链接filename_case: 0 # 文件名小写(1)大写(2)render_drafts: false # 显示草稿post_asset_folder: false # 图片上传需要设置为 truerelative_link: false # 相对路径，默认是绝对路径future: true # 显示之后的文件highlight: # 代码块设置 enable: true line_number: true auto_detect: false tab_replace: # Home page settingindex_generator: path: &apos;&apos; # index.html 文件路径 per_page: 10 # 每页显示博文数量 order_by: -date # 博文排序方式，默认日期降序 # Category &amp; Tagdefault_category: uncategorized # 博文默认分类category_map: # 分类别名tag_map: # 标签分类# Date / Time format## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD time_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscape # 默认主题theme: yilia# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 使用 Github 部署 repo: git@github.com:roastduckcd/roastduckcd.github.io.git # SSH 方式的 Github 仓 branch: master # 博客静态文件部署的分支 插件安装 以映射 google 站点地图插件为例 12// 安装npm install hexo-generator-sitemap --save 选项--save会将插件版本信息保存到 package.json文件中。 插件安装好后需要到 _config.yml配置。 12sitemap: path: sitemap.xml 配置好后 hexo g生成站点地图文件，位置在public文件夹下。 百度收录 sitemap：https://blog.csdn.net/qq_28804275/article/details/80891969 各个插件具体如何配置，需要到插件链接页去自信了解。 hexo 官方插件页 front matter 的设置注意所有冒号后有一个空格 layout: post布局 title: Github + Hexo + yilia 主题+ travis 自动部署个人博客(hexo进阶)标题 toc: true目录 date: 1550432254000创建日期 updated: 1563189378542更新日期, 无效？？ permalink: 自定义，你想怎样就怎样替换默认的文章链接, 规则随意，使用 /分隔。如果你想统一格式，又不想每次都在文章中改。可以修改博客根目录下的_config.yml中的字段。permalink: article/:year:title.html规则也是自定义，我这里 article 自定义，然后使用了 hexo 自带的变量。变量冒号不用空格。 comments: true是否开启文章评论,true / false categories:分类,如果有多个分类,第二个之后的会成为第一个的分类 categories:- 分类1- 分类2 tags:标签 tags:- tag1- tag2]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github + Hexo + yilia 主题+ travis 自动部署个人博客(搭建)]]></title>
    <url>%2Farticle%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%80.html</url>
    <content type="text"><![CDATA[前期准备 Github 账号注册、仓库建立、SSH 的配置等请参考这里 这里说说 SSH 的配置。Github SSH 免密连接和自动部署都需要密钥对(公钥+私钥)，所以有必要命名区分。但是注意如果指定了文件名，密钥对就在当前目录生成。如果没有指定，默认就会在~/.ssh/下生成id_rsa和id_rsa.pub密钥对。这样很可能不小心就覆盖掉，所以推荐自命名。 hexo 搭建博客 创建一个博客文件夹，我命为 BLOG,以后就称为博客根文件夹。 cd 进入 安装 hexo 12// -g 表示命令全局有效npm install hexo-cli -g 初始化 hexo 1hexo init 初始化成功后根文件夹的目录 现在可以本地访问你的博客了 1hexo server (简写 hexo s) 浏览器中输入http://localhost:4000，一个简单博客就呈现了。ctrl+c退出 hexo server, 博客也就再不能访问。 接下来我们将博客部署到 Github，以便网络访问。首先配置根文件夹下的 _config.yml。目前我们就配置deployment下的就可以。这里先着重说一下 branch 字段的配置. 如果你的仓库名是用户名.github.io,那部署博客的 branch 必须为 master。 如果你还像我一样需要将源码上传(之后自动部署要用)，那必须创建新分支，源码 push 到新分支。否则 hexo 部署时会将 master 中的内容覆盖 branch 不用提前创建，hexo 部署时会自动根据你的配置创建或更新 branch ==注意yml文件对空格敏感，以下倒数3行前有两个空格，冒号后一个空格。== 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 使用 Github 部署 repo: git@github.com:roastduckcd/roastduckcd.github.io.git # SSH 方式的 Github 仓 branch: master # 博客静态文件部署的分支 Github 仓地址： 安装 Git 发布插件 1234npm install hexo-deployer-git --save// 上面执行完后如果提示了 npm WARN babel-eslint@10.0.1 requires a peer of eslint@&gt;= 4.12.1 but none is installed// 再按照这个（根据提示,缺什么装什么）npm install eslint --save 发布 1hexo g -d // 生成静态网页并发布 看到图中这个说明部署完成。等上一会就可以访问你的博客你的用户名.github.io。万一访问不了，先到仓库看看是什么问题进入后往下拉，查看 Pages 标签中提示什么问题。我这里是博客根目录下thems/landscape/README.md文件GithubPages读不了。看了下文件，是因为有个 markdown 格式的代码块。毛病!!!可有可无的文件，直接删了即可。点击图中链接访问博客。 Tip: 推荐发布前先启用本地服务hexo s检查是否能访问博客，提前处理错误。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLDB部分命令列举]]></title>
    <url>%2Farticle%2FLLDB%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4%E5%88%97%E4%B8%BE.html</url>
    <content type="text"><![CDATA[官网 完整的 lldb 命令点击进入 终端中输入 lldb 即可进入环境。本文是在 Xcode 中调试。 流程控制命令 c（continue）:继续运行到下一个断点处 s（step into）:进入函数 si:进入函数，汇编级别指令 n:单步向下过掉==一条源码==语句，不会进入函数 ni:单步向下过掉==一条汇编==语句，不会进入函数 finish:进入到函数后，退出当前函数，回到上一个函数 对象操作命令 expression一般我们用来查看变量的值，二般写些简单语句。 缩写为 p 或 e + 语句 在 lldb 中新变量的声明和使用都必须在前面加 $。调试程序中的变量直接使用 12345(lldb) expression int $a = 10;(lldb) p aerror: use of undeclared identifier 'a'(lldb) p $a(int) $a = 10 ==p 表达式: 动态执行语句== p 对象: 打印对象所有信息，包括类型、地址、值等 1234567891011(lldb) p NSString *$str = @"string1";(lldb) p $str(NSTaggedPointerString *) $str = 0x8692ace9390c5ac2 @"string1"(lldb) p NSArray *$arr = @[@1, @"string2"];(lldb) p $arr(__NSArrayI *) $arr = 0x00006000039b2ac0 @"2 elements"(lldb) p jinmao(Dog *) $0 = 0x00006000039be820(lldb) p jinmao.name(__NSCFConstantString *) $1 = 0x0000000108b80070 @"jinmao"(lldb) po 对象: 调用对象的 description 方法。如果是 OC 基本类型对象，只打印值。我们可以重写对象的-description方法来改变该调试语句的输出。 123456789101112// 上面的po打印(lldb) po $strstring1(lldb) po $arr&lt;__NSArrayI 0x6000039b2ac0&gt;(1,string2)(lldb) po jinmao&lt;Dog: 0x6000039be820&gt;(lldb) po jinmao.namejinmao 当程序被断住时，我们可以操作当前作用域的变量、调用对象方法等。 123456// 取值(lldb) p self.view.backgroundColor(UIDeviceRGBColor *) $10 = 0x0000600002cb4140// 修改值、调用方法(lldb) p self.view.backgroundColor = [UIColor redColor];(UICachedDeviceRGBColor *) $11 = 0x0000600002ca0b40 p 命令操作属性或成员变量时会自动分配一个$n局部变量来接收值。我们也可以直接操作这个变量。 123456(lldb) p jinmao(Dog *) $0 = 0x0000600002892980(lldb) po jinmao.namejinmao(lldb) po $0.name = @"erha"erha 和操作原对象没什么区别。注意也许有的 lldb $n变量并不能直接使用点语法。这时需要在前面显示指明类型即可。(lldb) po (Dog *)$0.name 指定不同打印格式 12// 16 进制打印p/x 断点命令 help breakpoint 断点命令参数列表, 区分大小写 breakpoint 可缩写为 break 查看断点 breakpoint list, 缩写break list断点分组，组号从1开始。每组下的断点也从1开始编号。某个具体断点用 组号.断点号 表示 下断点 breakpoint set -n 函数名breakpoint set 可以缩写为 b b -n &quot;[类 方法]&quot; -n &quot;[类n 方法n:]&quot;，-n可选。同时对 OC 方法设置多个断点，这种方法会将这些断点归为一组, 注意根据方法名称有可能不成功。 b --file 文件名 --selector 方法名为某个文件中的所有同名方法设置断点，省略 file 就是给整个项目中的同名方法设置断点。 b -r xxx 为带有 xxx 字段的所有方法下断点 b -a 函数地址 汇编状态下常用 断点命令 breakpoint command 给某一个断点添加命令 breakpoint command add 断点组号 启用/禁用断点 break enable 组号/断点号 break disable 组号/断点号注意如果先使用组号禁用断点，再使用断点号启用某一个断点会无效。所以如果要禁用某一组的断点，推荐使用break dis 组号.*。*号就表示所有。 删除断点 breakpoint delete 断点组号：删除某组所有断点 breakpoint delete 断点号：禁用某个断点 breakpoint delete 删除所有断点 内存断点 watchpoint 监控某个属性值变化 watchpoint set variable xxx，只能使用对象-&gt;成员变量，不能使用点语法。 target hook 命令，只要触发断点就调用 target stop-hook add -o &quot;frame variable&quot;进入断点需要默认执行的 lldb 命令，此处是已进入断点就打印函数参数。一般写一些每个函数都能触发的通用命令。针对 breakpoint 和 watchpoint 命令。 1target stop-hook add -o &quot;frame variable&quot; list disable / able delete 该命令一旦退出程序就失效。可以使用 lldb 的初始化文件 .lldb 来配置 target-hook 命令使其长期有效，直接将命令写入即可。 堆栈操作命令 查看函数调用栈 bt 查看上(下)一个函数的汇编信息 up/down，不会改变执行流程 查看某一个栈帧的函数的汇编信息 frame select 栈帧编号, 这个栈帧 查看当前栈帧函数的参数 frame variable 断点回滚 thread return 回滚到该函数被调用的地方。 回滚后不会再继续往下执行 相当于在函数开头直接 return。 内存镜像命令 imageimage list 查看加载了哪些动态库列出所有内存中正在运行的模块在系统的路径，和此时在内存中的真实物理地址。 image lookup 当前进程加载的模块列表 崩溃代码定位 先打全局断点，再 image lookup image lookup -a 方法内存地址 模块名在指定模块中查找指定地址的方法信息，不指定模块名就是在所有模块中找。(笔者使用对象地址没有得到任何信息···) 12Dog *a = [[Dog alloc] init];[a performSelector:@selector(run)]; a 调用了一个不存在的 run 方法。此时崩溃由于奔溃地方指向如图位置，给我们定位 bug 带来困难。此时根据图中所示找到奔溃方法的上一个函数栈帧，得到它的地址，然后使用 image lookup这样直接就定位奔溃代码位置在ViewController.m中的第25行。 Tip:这个功能也可以通过Xcode设置异常断点来实现 image lookup -t 类名查看类的成员变量及属性等，但是看不到类的方法。 image lookup -n 函数名查找函数在模块/App中的位置 image dump sections 模块名从内存中导出模块的 MachO section 信息。一定要加模块名，否则是导出内存中所有的模块 image dump symtab 模块名从内存中导出模块的 MachO symbols 信息。千万要加模块名，否则就是内存中所有的模块。笔者跑了三分钟没到个头啊··· 查看内存命令 memorymemory read[/][分组数][进制格式][每组字节数] 中括号表示参数可选。 进制格式：x 16进制(常用)， d 10进制 每组字节数：每组按多少个字节展示 b 1个字节，h 2个字节，w 4个字节，g 8个字节。如果是10进制，该参数无效。 memory read/6xb 0xxxxxxxxx 读取 0xxxxxxxxx 的内容，分成6组，按16进制显示，每1个字节一组。因此总共读取了 6 bytes。 memory read 也可以简写为 x: x/6xb 0xxxxxxxxx memory write memory write 0xxxxxxxx value：向内存 0xxxxxxxx 写入 value 值。 TODO: 后面补充### 寄存器操作命令 register##### register read / write]]></content>
      <categories>
        <category>工具</category>
        <category>调试工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mweb配置七牛云图床]]></title>
    <url>%2Farticle%2FMweb%E9%85%8D%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A.html</url>
    <content type="text"><![CDATA[注意七牛云只有30天有效期，30天过后使用的连接都将失效。我这里仅作验证用。如果要长期有效，需要自己创建域名，但是要付费。要不就去找其他免费云图床··· 首先注册和认证七牛云图床, 并且创建新的存储空间 由于我用的 Mac 版 Mweb，来到偏好设置-发布,点击下面的qiniu.com Name： 可以自定义 API URL： 这里要选上面创建空间时对应的区域。如果没记住，可以在存储空间查看。 Bucket Name：空间名称, 一定要和创建空间时自定义的保持一致。 Access Key和 Secret Key 可以在七牛个人面板-密钥管理中查看 Domain：域名 image URL prefix: 图片前缀，可不填 配置完后就可以使用了写好文章，贴好图片，MWeb 菜单栏发布-上传本地图片 开始上传图片 由于 Mweb 并不能直接将文件中的本地图片路径替换为远程图片链接。所以要么自己一个一个复制粘贴，要么直接Copy Markdown然后覆盖源文件即可。但是这种情况下，文章编辑时图片不能显示，只有在预览中才能看到。]]></content>
      <tags>
        <tag>图床</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中间人攻击]]></title>
    <url>%2Farticle%2F%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.html</url>
    <content type="text"><![CDATA[一次正常RSA 加解密流程：用户发起连接请求，服务器发送公钥给客户端，客户端使用服务端公钥加密相关信息并发送给服务端。服务端使用私钥解密，获取信息进行验证及处理。 中间人攻击：中间人截取用户验证请求，发送中间人公钥给客户端。客户端利用假公钥加密的信息就会被中间人解密。中间人拿到客户端信息再去和服务端交互。服务端返回的数据会先经过中间人再到用户，这样用户的数据就得不到安全保障。因为中间人可以修改用户数据。 ==总结一下就是：中间人对客户端是伪装服务端，对服务端伪装客户端== 简单防护 防护 1：客户端将正常验证请求到的服务端公钥进行保存。之后发起请求时将服务端返回的公钥和本地进行匹配。匹配一致才交互。但是也有弊端，如果服务器确实更换了公钥，那么客户端将连接不上，此时需要删除客户端之前保存的公钥，这也要求服务端一定要及时通知客户端。 防护 2：上面的方法不能保证客户端拿到的公钥就是正确的。这时服务端可以将公钥进行一次 hash 并公布。因为数据的 hash 值是唯一的。因此客户端将拿到的公钥也进行 hash 一次，和服务器公布的 hash 比对，一致才交互。 ··· 其他的防护再补充，想起就补充 !^_^!]]></content>
      <tags>
        <tag>RSA</tag>
        <tag>中间人攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH 连接iPhone]]></title>
    <url>%2Farticle%2FSSH.html</url>
    <content type="text"><![CDATA[passwd 修改密码: mobile权限下需要旧密码，root 下直接覆盖原密码，这就是为什么 root 权限不轻易开放的原因。 登录过程，（RSA， PC 为客户端，手机为服务端）我这里客户端就是 Mac，服务端就是 5s手机。 首先 Mac 发起连接请求，从手机上得到公钥。提示输入密码。(我这里用的 USB 登录演示) 然后 Mac 将输入的密码用手机公钥进行加密，加密后的信息发到手机 手机则使用私钥解密，得到登录密码。然后验证密码正确性。 为防中间人攻击，PC 端将正常登录获取的手机端的公钥以 IP 为 key 都保存在 ~/.ssh/known_hosts 文件中。登录时进行匹配，如果失败则可能遇到中间人攻击。 有时候两台手机可能分配相同的 ip 地址（不同时在一个局域网）。连接后一台手机时 PC 端可能提示中间人攻击。因为PC上同一个 ip 地址已经保存了前一台手机的公钥。这时需要删除之前的公钥才能连接。PC 端通过ssh-keygen -R 手机端(服务端)ip 删除对应的公钥。 手机端公钥文件就是 /etc/ssh/ssh_host_rsa_key.pub文件。配置免密登录(客户端公钥登录)客户端将自己的公钥发给服务器保存。登录时，服务器发送一段随机字符串给客户端。客户端使用自己的私钥加密后发给服务器，服务器使用客户端公钥进行解密，如果字符串匹配。则说明用户可信，不发起密码登录请求。（RSA 签名与验证） 进入 PC 端目录~/.ssh ssh-keygen 生成自己的公钥、私钥。相关信息可以不用输入,直接回车。跟上-f othername 可以生成指定名字的公私钥 ssh-copy-id 用户名@服务器ip地址拷贝到服务器(~/.ssh/authorized_keys) 配置别名登录使用局域网连接 一般登录 ssh 用户名@ip地址 别名登录 ssh 别名, 修改~/.ssh.config，没有则创建。 123Host 别名Hostname ip地址 User 用户名 使用 USB 连接(推荐)123* 127.0.0.1 本地回环地址，网卡地址。ping 不通说明网卡问题。也可以直接写成`localhost`* 192.168.1.3 ip地址，路由器分配地址。ping不通可能路由器问题等。发送数据包到 IP地址，先通过127.0.0.1 再到 ip 地址。 必须先使用 python脚本映射usb 硬件端口映射到本地端口。作者已经将脚本写成可以直接执行的命令。进到enableUSBSSh.command的目录下终端直接执行即可。 每次使用进一长串目录不方便，可以配置脚本或者环境变量。或者像我一样整个快捷方式。~/.bash_profile中添加接下来就可以在终端直接使用USBSSH映射端口。注意默认映射的端口号是 22。你可以使用编辑器打开enableUSBSSh.command文件修改。 一般登录 ssh 用户名@localhost 别名登录 ssh 别名, 修改~/.ssh.config没有则创建。1234Host 别名Hostname 127.0.0.1User 用户名Port 映射的端口号 但USB连接不建议在 config 中取别名。因为如果链接多台手机，又没配置免密登录，PC 端 RSAKEYS 文件中的 127.0.0.1 会对应多个公钥。造成中间人攻击的情况。这种情况推荐使用脚本。 补充：也可以百度iProxy工具映射端口。 使用脚本快速连接 创建 xxx.sh 1ssh root@localhost 这样在脚本目录下，使用终端sh xxx.sh即可快速连接。如果没有配置免密登录会提示输入密码。 全局配置在shell 配置文件中添加如下12export SHELL=~/Desktop/SHELLPATH=:$&#123;PATH&#125;:/bin:/usr/bin:$SHELL 修改路径为你创建 .sh的目录即可。:$SHELL直接添加到你的PATH后。注意:和$不能少。 ~~ * localhost和127.0.0.1虽然代表同一个地址~~但是在known_hosts文件中存储时以字符串保存。所以如果多台手机使用，出现中间人攻击？？？]]></content>
      <categories>
        <category>工具</category>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
